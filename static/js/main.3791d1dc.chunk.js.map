{"version":3,"sources":["../../src/Coordinates.js","../../src/CommonUtils.js","../../src/GzdGraticule.js","../../src/HundredKGraticule.js","../../src/OneKGraticule.js","App.js","index.js"],"names":["utm","require","utmToLl","easting","northing","zoneNumber","zoneLetter","convertUtmToLatLng","llToUtm","lat","lng","_LLtoUTM","lon","llToMgrs","point","resolution","forward","ll","eccPrimeSquared","N","T","C","A","LongOriginRad","ZoneNumber","Lat","Long","a","eccSquared","k0","LatRad","degToRad","LongRad","Math","floor","sqrt","sin","tan","cos","UTMEasting","UTMNorthing","round","getLetterDesignator","deg","PI","LetterDesignator","TEN_K_MGRS_REGEX","getLineSlope","pointOne","pointTwo","NaN","getAdjustedLatitude","slope","adjustedLongitude","unadjustedLatLong","isNaN","getAdjustedLongitude","adjustedLatitude","Error","getNextMgrsGzdCharacter","char","result","String","fromCharCode","charCodeAt","connectToGzdBoundary","direction","grid","gzdEastLongitude","getGZD","match","geometry","coordinates","gzdWestLongitude","gzdNorthLatitude","gzdSouthLatitude","getAllVisibleGzds","nwGzd","neGzd","seGzd","swGzd","GZD_REGEX","nwLongitudeBand","parseInt","nwLatitudeBand","neLongitudeBand","swLatitudeBand","longitudeBands","push","i","toString","initialLongitudeBand","currentLatitudeBand","len","length","flat","longitudeBand","filter","includes","drawLabel","ctx","labelText","textColor","backgroundColor","labelPosition","textWidth","measureText","width","textHeight","fontBoundingBoxAscent","labelX","x","labelY","y","fillStyle","fillRect","fillText","MGRS_REGEX","GzdGraticule","props","map","useMap","canvas","document","createElement","classList","add","g","Graticule","addLayer","currLatInterval","currLngInterval","defaultOptions","showGrid","showLabel","opacity","weight","color","font","fontColor","dashArray","minZoom","options","_panes","overlayPane","appendChild","this","on","reset","removeChild","off","mapSize","getSize","mapLeftTop","containerPointToLayerPoint","style","height","drawGzd","getZoom","getContext","clearRect","lineWidth","strokeStyle","setLineDash","leftTop","containerPointToLatLng","rightBottom","pointPerLat","pointPerLon","drawLatitudeLine","drawLongitudeLine","tick","lngLeft","lngRight","leftEnd","latLngToContainerPoint","rightEnd","beginPath","moveTo","lineTo","stroke","latTop","latBottom","canvasTop","canvasBottom","TOP_OF_W_SERIES_GZD","TOP_OF_V_SERIES_GZD","BOTTOM_OF_V_SERIES_GZD","RIGHT_TOP_OF_GZD","LEFT_TOP_OF_GZD","LEFT_BOTTOM_OF_GZD","RIGHT_BOTTOM_OF_GZD","TOP_LEFT_OF_32_SERIES_GZD","TOP_LEFT_OF_33X_GZD","BOTTOM_LEFT_OF_33X_GZD","TOP_RIGHT_OF_32W_GZD","TOP_LEFT_OF_34_SERIES_GZD","TOP_LEFT_OF_35X_GZD","BOTTOM_LEFT_OF_35X_GZD","TOP_RIGHT_OF_34W_GZD","TOP_LEFT_OF_35_SERIES_GZD","TOP_LEFT_OF_37X_GZD","BOTTOM_LEFT_OF_37X_GZD","TOP_RIGHT_OF_36W_GZD","drawGzdLabels","longitude","labelLatitude","labelLongitude","gzdLabel","error","labelXy","Layer","OneKGraticule","updateVariables","bind","hkColor","hkDashArray","hundredKMinZoom","tenKMinZoom","oneKMinZoom","eastingBottom","NorthingRight","currZoom","mgrsGridInterval","drawGrid","element","label","notHkLine","nwBoundMgrs","getBounds","getNorthWest","neBoundMgrs","getNorthEast","seBoundMgrs","getSouthEast","swBoundMgrs","getSouthWest","visibleGzds","getVizGrids","mapBounds","forEach","gzd","gzdIndex","visibleGridArr","gzdObject","gzdWestBoundary","gzdEastBoundary","gzdNorthBoundary","gzdSouthBoundary","effectiveWestBoundary","getWest","effectiveEastBoundary","getEast","effectiveNorthBoundary","getNorth","effectiveSouthBoundary","getSouth","effectiveBounds","L","latLngBounds","latLng","buffer","swCornerUtm","seCornerUtm","nwCornerUtm","neCornerUtm","startingEasting","getCenter","finalEasting","startingNorthing","finalNorthing","ceil","eastingArray","northingArray","eastingElem","eastingIndex","eastArr","northingElem","northingIndex","northArr","gridIntersectionLl","gridIntersectionXy","_drawLine","e","console","trace","skipRemainder","ea","na","labelLl","adjacentLlNorthing","adjacentLlEasting","currentLl","distanceTo","contains","_getLabelText","App","MapContainer","center","zoom","maxZoom","maxNativeZoom","maxBounds","TileLayer","url","attribution","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.3791d1dc.chunk.js","sourcesContent":["import { forward } from 'mgrs';\r\n\r\nvar utmObj = require('utm-latlng');\r\nvar utm = new utmObj(); // Defaults to WGS-84\r\n\r\nfunction utmToLl(easting, northing, zoneNumber, zoneLetter) {\r\n  return utm.convertUtmToLatLng(easting, northing, zoneNumber, zoneLetter);\r\n}\r\n\r\nfunction llToUtm(lat, lng, resolution = 0) {\r\n  // return utm.convertLatLngToUtm(lat, lng, resolution);\r\n  return _LLtoUTM({ lat: lat, lon: lng });\r\n}\r\n\r\n/**\r\n *\r\n * @param {arr} point [Lng,Lat]\r\n * @param {number} resolution\r\n */\r\nfunction llToMgrs(point, resolution = 1) {\r\n  return forward(point, resolution);\r\n}\r\n\r\nfunction _LLtoUTM(ll) {\r\n  var Lat = ll.lat;\r\n  var Long = ll.lon || ll.lng;\r\n  var a = 6378137.0; //ellip.radius;\r\n  var eccSquared = 0.00669438; //ellip.eccsq;\r\n  var k0 = 0.9996;\r\n  var LongOrigin;\r\n  var eccPrimeSquared;\r\n  var N, T, C, A, M;\r\n  var LatRad = degToRad(Lat);\r\n  var LongRad = degToRad(Long);\r\n  var LongOriginRad;\r\n  var ZoneNumber;\r\n  // (int)\r\n  ZoneNumber = Math.floor((Long + 180) / 6) + 1;\r\n\r\n  //Make sure the longitude 180.00 is in Zone 60\r\n  if (Long === 180) {\r\n    ZoneNumber = 60;\r\n  }\r\n\r\n  // Special zone for Norway\r\n  if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {\r\n    ZoneNumber = 32;\r\n  }\r\n\r\n  // Special zones for Svalbard\r\n  if (Lat >= 72.0 && Lat < 84.0) {\r\n    if (Long >= 0.0 && Long < 9.0) {\r\n      ZoneNumber = 31;\r\n    } else if (Long >= 9.0 && Long < 21.0) {\r\n      ZoneNumber = 33;\r\n    } else if (Long >= 21.0 && Long < 33.0) {\r\n      ZoneNumber = 35;\r\n    } else if (Long >= 33.0 && Long < 42.0) {\r\n      ZoneNumber = 37;\r\n    }\r\n  }\r\n\r\n  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin\r\n  // in middle of\r\n  // zone\r\n  LongOriginRad = degToRad(LongOrigin);\r\n\r\n  eccPrimeSquared = eccSquared / (1 - eccSquared);\r\n\r\n  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));\r\n  T = Math.tan(LatRad) * Math.tan(LatRad);\r\n  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);\r\n  A = Math.cos(LatRad) * (LongRad - LongOriginRad);\r\n\r\n  M =\r\n    a *\r\n    ((1 - eccSquared / 4 - (3 * eccSquared * eccSquared) / 64 - (5 * eccSquared * eccSquared * eccSquared) / 256) *\r\n      LatRad -\r\n      ((3 * eccSquared) / 8 + (3 * eccSquared * eccSquared) / 32 + (45 * eccSquared * eccSquared * eccSquared) / 1024) *\r\n        Math.sin(2 * LatRad) +\r\n      ((15 * eccSquared * eccSquared) / 256 + (45 * eccSquared * eccSquared * eccSquared) / 1024) *\r\n        Math.sin(4 * LatRad) -\r\n      ((35 * eccSquared * eccSquared * eccSquared) / 3072) * Math.sin(6 * LatRad));\r\n\r\n  var UTMEasting =\r\n    k0 *\r\n      N *\r\n      (A +\r\n        ((1 - T + C) * A * A * A) / 6.0 +\r\n        ((5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A) / 120.0) +\r\n    500000.0;\r\n\r\n  var UTMNorthing =\r\n    k0 *\r\n    (M +\r\n      N *\r\n        Math.tan(LatRad) *\r\n        ((A * A) / 2 +\r\n          ((5 - T + 9 * C + 4 * C * C) * A * A * A * A) / 24.0 +\r\n          ((61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A) / 720.0));\r\n  if (Lat < 0.0) {\r\n    UTMNorthing += 10000000.0; //10000000 meter offset for\r\n    // southern hemisphere\r\n  }\r\n\r\n  return {\r\n    northing: Math.round(UTMNorthing),\r\n    easting: Math.round(UTMEasting),\r\n    zoneNumber: ZoneNumber,\r\n    zoneLetter: getLetterDesignator(Lat),\r\n  };\r\n}\r\n\r\n/**\r\n * Conversion from degrees to radians.\r\n *\r\n * @private\r\n * @param {number} deg the angle in degrees.\r\n * @return {number} the angle in radians.\r\n */\r\nfunction degToRad(deg) {\r\n  return deg * (Math.PI / 180.0);\r\n}\r\n\r\n/**\r\n * Calculates the MGRS letter designator for the given latitude.\r\n *\r\n * @private\r\n * @param {number} lat The latitude in WGS84 to get the letter designator\r\n *     for.\r\n * @return {char} The letter designator.\r\n */\r\nfunction getLetterDesignator(lat) {\r\n  //This is here as an error flag to show that the Latitude is\r\n  //outside MGRS limits\r\n  var LetterDesignator = 'Z';\r\n\r\n  if (84 >= lat && lat >= 72) {\r\n    LetterDesignator = 'X';\r\n  } else if (72 > lat && lat >= 64) {\r\n    LetterDesignator = 'W';\r\n  } else if (64 > lat && lat >= 56) {\r\n    LetterDesignator = 'V';\r\n  } else if (56 > lat && lat >= 48) {\r\n    LetterDesignator = 'U';\r\n  } else if (48 > lat && lat >= 40) {\r\n    LetterDesignator = 'T';\r\n  } else if (40 > lat && lat >= 32) {\r\n    LetterDesignator = 'S';\r\n  } else if (32 > lat && lat >= 24) {\r\n    LetterDesignator = 'R';\r\n  } else if (24 > lat && lat >= 16) {\r\n    LetterDesignator = 'Q';\r\n  } else if (16 > lat && lat >= 8) {\r\n    LetterDesignator = 'P';\r\n  } else if (8 > lat && lat >= 0) {\r\n    LetterDesignator = 'N';\r\n  } else if (0 > lat && lat >= -8) {\r\n    LetterDesignator = 'M';\r\n  } else if (-8 > lat && lat >= -16) {\r\n    LetterDesignator = 'L';\r\n  } else if (-16 > lat && lat >= -24) {\r\n    LetterDesignator = 'K';\r\n  } else if (-24 > lat && lat >= -32) {\r\n    LetterDesignator = 'J';\r\n  } else if (-32 > lat && lat >= -40) {\r\n    LetterDesignator = 'H';\r\n  } else if (-40 > lat && lat >= -48) {\r\n    LetterDesignator = 'G';\r\n  } else if (-48 > lat && lat >= -56) {\r\n    LetterDesignator = 'F';\r\n  } else if (-56 > lat && lat >= -64) {\r\n    LetterDesignator = 'E';\r\n  } else if (-64 > lat && lat >= -72) {\r\n    LetterDesignator = 'D';\r\n  } else if (-72 > lat && lat >= -80) {\r\n    LetterDesignator = 'C';\r\n  }\r\n  return LetterDesignator;\r\n}\r\n\r\nexport { utmToLl, llToUtm, llToMgrs };\r\n","import { getGZD } from 'gzd-utils';\r\nimport { forward } from 'mgrs';\r\n\r\n// The following indicies are used to indentify coordinates returned from gzd-utils\r\nconst SW_INDEX = 0;\r\nconst NW_INDEX = 1;\r\nconst NE_INDEX = 2;\r\n\r\nconst LONGITUDE_INDEX = 0;\r\nconst LATITUDE_INDEX = 1;\r\n\r\nconst TEN_K_MGRS_REGEX = /([0-9]+[A-Z])([A-Z]{2})([0-9]{2})/;\r\nconst GZD_INDEX = 1;\r\n/**\r\n *\r\n * @param {*} pointOne\r\n * @param {*} pointTwo\r\n */\r\nfunction getLineSlope(pointOne, pointTwo) {\r\n  if (pointOne === pointTwo) {\r\n    return 0;\r\n  } else if (pointOne.lng === pointTwo.lng) {\r\n    return NaN;\r\n  } else {\r\n    return (pointTwo.lat - pointOne.lat) / (pointTwo.lng - pointOne.lng);\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * @param {*} slope\r\n * @param {*} adjustedLongitude\r\n * @param {*} unadjustedLatLong\r\n */\r\nfunction getAdjustedLatitude(slope, adjustedLongitude, unadjustedLatLong) {\r\n  let result;\r\n  if (!isNaN(slope)) {\r\n    result = unadjustedLatLong.lat + slope * (adjustedLongitude - unadjustedLatLong.lng);\r\n  } else {\r\n    result = unadjustedLatLong.lat;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n *\r\n * @param {*} slope\r\n * @param {*} adjustedLongitude\r\n * @param {*} unadjustedLatLong\r\n */\r\nfunction getAdjustedLongitude(slope, adjustedLatitude, unadjustedLatLong) {\r\n  let result;\r\n  if (slope === 0) {\r\n    const e = new Error('getAdjustedLongitude: Zero slope received');\r\n    throw e;\r\n  } else if (!isNaN(slope)) {\r\n    result = (adjustedLatitude - unadjustedLatLong.lat + slope * unadjustedLatLong.lng) / slope;\r\n  } else {\r\n    result = unadjustedLatLong.lng;\r\n  }\r\n\r\n  return result;\r\n}\r\n/**\r\n *\r\n * @param {string} char\r\n */\r\nfunction getNextMgrsGzdCharacter(char) {\r\n  // I and O are not valid characters for MGRS, so get the next\r\n  // character recursively\r\n  const result = String.fromCharCode(char.charCodeAt(0) + 1);\r\n  if (result === 'I' || result === 'O') {\r\n    return getNextMgrsGzdCharacter(result);\r\n  } else {\r\n    return result;\r\n  }\r\n}\r\n\r\n/**\r\n * Given two points and a direction, will return a new point along the\r\n * line generated by pointOne and pointTwo which rests on the GZD boundary\r\n * @param {Dict} pointOne\r\n * @param {Dict} pointTwo\r\n * @param {String} direction\r\n */\r\nfunction connectToGzdBoundary(pointOne, pointTwo, direction) {\r\n  const slope = getLineSlope(pointOne, pointTwo);\r\n  // 10k mgrs resolution grid - e.g. 18TVR90\r\n  const grid = forward([pointOne.lng, pointOne.lat], 1);\r\n  let adjustedLongitude;\r\n  let adjustedLatitude;\r\n\r\n  switch (direction) {\r\n    case 'East':\r\n      const gzdEastLongitude = getGZD(grid.match(TEN_K_MGRS_REGEX)[GZD_INDEX]).geometry.coordinates[0][NE_INDEX][\r\n        LONGITUDE_INDEX\r\n      ];\r\n\r\n      adjustedLatitude = getAdjustedLatitude(slope, gzdEastLongitude, pointTwo);\r\n      adjustedLongitude = gzdEastLongitude;\r\n\r\n      return { lat: adjustedLatitude, lng: adjustedLongitude };\r\n\r\n    case 'West':\r\n      const gzdWestLongitude = getGZD(grid.match(TEN_K_MGRS_REGEX)[GZD_INDEX]).geometry.coordinates[0][NW_INDEX][\r\n        LONGITUDE_INDEX\r\n      ];\r\n\r\n      adjustedLatitude = getAdjustedLatitude(slope, gzdWestLongitude, pointTwo);\r\n\r\n      adjustedLongitude = gzdWestLongitude;\r\n      return { lat: adjustedLatitude, lng: adjustedLongitude };\r\n    case 'North':\r\n      const gzdNorthLatitude = getGZD(grid.match(TEN_K_MGRS_REGEX)[GZD_INDEX]).geometry.coordinates[0][NW_INDEX][\r\n        LATITUDE_INDEX\r\n      ];\r\n\r\n      adjustedLongitude = getAdjustedLongitude(slope, gzdNorthLatitude, pointTwo);\r\n\r\n      // Handle a special case where the west most 100k easting line in the 32V GZD extends\r\n      // west of the boundary\r\n      const WEST_LNG_32V_BOUNDARY = 3;\r\n      if (\r\n        grid.match(TEN_K_MGRS_REGEX)[GZD_INDEX] === '31V' &&\r\n        adjustedLongitude < WEST_LNG_32V_BOUNDARY &&\r\n        pointTwo.lng > WEST_LNG_32V_BOUNDARY\r\n      ) {\r\n        adjustedLatitude = getAdjustedLatitude(slope, WEST_LNG_32V_BOUNDARY, pointTwo);\r\n        adjustedLongitude = WEST_LNG_32V_BOUNDARY;\r\n      } else {\r\n        adjustedLatitude = gzdNorthLatitude;\r\n      }\r\n\r\n      return { lat: adjustedLatitude, lng: adjustedLongitude };\r\n\r\n    case 'South':\r\n      const gzdSouthLatitude = getGZD(grid.match(TEN_K_MGRS_REGEX)[GZD_INDEX]).geometry.coordinates[0][SW_INDEX][\r\n        LATITUDE_INDEX\r\n      ];\r\n\r\n      adjustedLongitude = getAdjustedLongitude(slope, gzdSouthLatitude, pointTwo);\r\n\r\n      adjustedLatitude = gzdSouthLatitude;\r\n      return { lat: adjustedLatitude, lng: adjustedLongitude };\r\n\r\n    default:\r\n      // TODO - lat/lng are undefined if we use this return statement\r\n      return { lat: adjustedLatitude, lng: adjustedLongitude };\r\n  }\r\n}\r\n\r\n// TODO - REFACTOR HACK\r\nfunction getAllVisibleGzds(nwGzd, neGzd, seGzd, swGzd) {\r\n  const GZD_REGEX = /([0-9]+)([A-Z])/;\r\n  const LONGITUDE_BAND_INDEX = 1;\r\n  const LATITUDE_BAND_INDEX = 2;\r\n\r\n  // Short circuit\r\n  if (nwGzd === seGzd) {\r\n    return [nwGzd];\r\n  }\r\n  const nwLongitudeBand = parseInt(nwGzd.match(GZD_REGEX)[LONGITUDE_BAND_INDEX]);\r\n  const nwLatitudeBand = nwGzd.match(GZD_REGEX)[LATITUDE_BAND_INDEX];\r\n\r\n  const neLongitudeBand = parseInt(neGzd.match(GZD_REGEX)[LONGITUDE_BAND_INDEX]);\r\n\r\n  const swLatitudeBand = swGzd.match(GZD_REGEX)[LATITUDE_BAND_INDEX];\r\n\r\n  let result = [];\r\n\r\n  const longitudeBands = []; // container for the formatted GZDs\r\n\r\n  // If the NW GZD is 32V then also include the relevant 31 series GZDs below it\r\n  // This ensures that grids are displayed (since 32V is larger at the expense of 31V)\r\n  if (nwGzd === '32V') {\r\n    longitudeBands.push('31');\r\n  }\r\n\r\n  // We span at least two vertical bands\r\n  if (nwLongitudeBand !== neLongitudeBand) {\r\n    for (let i = nwLongitudeBand; i <= neLongitudeBand; i++) {\r\n      longitudeBands.push(i.toString());\r\n    }\r\n    if (nwLatitudeBand !== swLatitudeBand) {\r\n      const initialLongitudeBand = [...longitudeBands];\r\n\r\n      let currentLatitudeBand = swLatitudeBand;\r\n      while (currentLatitudeBand <= nwLatitudeBand) {\r\n        const len = initialLongitudeBand.length;\r\n\r\n        for (let i = 0; i < len; i++) {\r\n          result.push(initialLongitudeBand[i] + currentLatitudeBand);\r\n        }\r\n\r\n        currentLatitudeBand = getNextMgrsGzdCharacter(currentLatitudeBand);\r\n      }\r\n\r\n      result = result.flat();\r\n    } else {\r\n      // Append the alpha character to the array of GZDs\r\n      const len = longitudeBands.length;\r\n      for (let i = 0; i < len; i++) {\r\n        longitudeBands[i] = longitudeBands[i].toString() + nwLatitudeBand;\r\n      }\r\n      result = longitudeBands;\r\n    }\r\n  } else {\r\n    // We span a single vertical band\r\n    let currentLatitudeBand = swLatitudeBand;\r\n    const longitudeBand = []; // Container for the formatted GZDs\r\n\r\n    while (currentLatitudeBand <= nwLatitudeBand) {\r\n      longitudeBand.push(nwLongitudeBand.toString() + currentLatitudeBand);\r\n\r\n      currentLatitudeBand = getNextMgrsGzdCharacter(currentLatitudeBand);\r\n    }\r\n    result = longitudeBand;\r\n  }\r\n  // Remove non-existant X series GZDs around Svalbard\r\n  result = result.filter(function (a) {\r\n    return a !== '32X' && a !== '34X' && a !== '36X';\r\n  });\r\n\r\n  // Add 32V if 31W is visible\r\n  // This ensures that grids are displayed (since 32V is larger at the expense of 31V)\r\n  if (result.includes('31W') && !result.includes('32V')) {\r\n    result.push('32V');\r\n  }\r\n\r\n  // Handles a special case where 32V can be the NW and NE GZD, but the algorithm\r\n  // doesn't show the 31U GZD\r\n  if (neGzd === '32V' && seGzd === '32U' && !result.includes('31U')) {\r\n    result.push('31U');\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction drawLabel(ctx, labelText, textColor, backgroundColor, labelPosition) {\r\n  const textWidth = ctx.measureText(labelText).width;\r\n  const textHeight = ctx.measureText(labelText).fontBoundingBoxAscent;\r\n\r\n  // Calculate label xy position\r\n  const labelX = labelPosition.x;\r\n  const labelY = labelPosition.y;\r\n\r\n  ctx.fillStyle = backgroundColor;\r\n  // Magic numbers will centre the rectangle over the text\r\n  ctx.fillRect(labelX - textWidth / 2 - 1, labelY - textHeight + 1, textWidth + 3, textHeight + 2);\r\n  ctx.fillStyle = textColor;\r\n  ctx.fillText(labelText, labelX - textWidth / 2, labelY);\r\n}\r\n\r\nexport {\r\n  connectToGzdBoundary,\r\n  drawLabel,\r\n  getAdjustedLatitude,\r\n  getAdjustedLongitude,\r\n  getAllVisibleGzds,\r\n  getLineSlope,\r\n  getNextMgrsGzdCharacter,\r\n};\r\n","import { llToMgrs } from './Coordinates';\r\nimport { Layer } from 'leaflet';\r\nimport { useMap } from 'react-leaflet';\r\n\r\nimport { drawLabel } from './CommonUtils';\r\n\r\nconst MGRS_REGEX = /([0-9]+[A-Z])([A-Z]{2})(\\d+)/;\r\nconst GZD_INDEX = 1;\r\n\r\nconst GzdGraticule = (props) => {\r\n  let map = useMap();\r\n\r\n  const canvas = document.createElement('canvas');\r\n  canvas.classList.add('leaflet-zoom-animated');\r\n\r\n  let g = new Graticule({ map: map, canvas: canvas });\r\n  map.addLayer(g);\r\n\r\n  return null;\r\n};\r\n\r\nclass Graticule extends Layer {\r\n  constructor(props) {\r\n    super(props);\r\n    this.currLatInterval = 8;\r\n    this.currLngInterval = 6;\r\n\r\n    this.defaultOptions = {\r\n      showGrid: true,\r\n      showLabel: true,\r\n      opacity: 10,\r\n      weight: 3,\r\n      color: '#888888',\r\n      font: '14px Courier New',\r\n      fontColor: '#FFF',\r\n      dashArray: [6, 6],\r\n      minZoom: 3,\r\n    };\r\n\r\n    this.map = props.map;\r\n    this.canvas = props.canvas;\r\n\r\n    this.options = (props && props.options) || this.defaultOptions;\r\n  }\r\n\r\n  onAdd(map) {\r\n    map._panes.overlayPane.appendChild(this.canvas);\r\n    map.on('viewreset', this.reset, this);\r\n    map.on('move', this.reset, this);\r\n\r\n    this.reset();\r\n  }\r\n\r\n  onRemove(map) {\r\n    map._panes.overlayPane.removeChild(this.canvas);\r\n    map.off('viewreset', this.reset, this);\r\n    map.off('move', this.reset, this);\r\n\r\n    this.canvas = null;\r\n    this.map = null;\r\n  }\r\n\r\n  reset() {\r\n    const mapSize = this.map.getSize();\r\n    const mapLeftTop = this.map.containerPointToLayerPoint([0, 0]);\r\n\r\n    this.canvas.style['transform'] = `translate3d(${mapLeftTop.x}px,${mapLeftTop.y}px,0)`;\r\n\r\n    this.canvas.width = mapSize.x;\r\n    this.canvas.height = mapSize.y;\r\n\r\n    this.drawGzd();\r\n  }\r\n\r\n  drawGzd() {\r\n    if (!this.canvas || !this.map) {\r\n      return;\r\n    }\r\n\r\n    if (this.map.getZoom() < this.options.minZoom) {\r\n      return;\r\n    }\r\n\r\n    let ctx = this.canvas.getContext('2d');\r\n    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n    ctx.lineWidth = this.options.weight;\r\n    ctx.strokeStyle = this.options.color;\r\n    ctx.fillStyle = this.options.color;\r\n    ctx.setLineDash(this.options.dashArray);\r\n    if (this.options.font) {\r\n      ctx.font = this.options.font;\r\n    }\r\n\r\n    let leftTop = this.map.containerPointToLatLng({ x: 0, y: 0 });\r\n    let rightBottom = this.map.containerPointToLatLng({\r\n      x: this.canvas.width,\r\n      y: this.canvas.height,\r\n    });\r\n\r\n    let pointPerLat = (leftTop.lat - rightBottom.lat) / (this.canvas.height * 0.2);\r\n    let pointPerLon = (rightBottom.lng - leftTop.lng) / (this.canvas.width * 0.2);\r\n\r\n    if (isNaN(pointPerLat) || isNaN(pointPerLon)) {\r\n      return;\r\n    }\r\n\r\n    if (pointPerLat < 1) {\r\n      pointPerLat = 1;\r\n    }\r\n    if (pointPerLon < 1) {\r\n      pointPerLon = 1;\r\n    }\r\n\r\n    if (rightBottom.lat < -90) {\r\n      rightBottom.lat = -90;\r\n    } else {\r\n      rightBottom.lat = parseInt(rightBottom.lat - pointPerLat, 10);\r\n    }\r\n\r\n    if (leftTop.lat > 90) {\r\n      leftTop.lat = 90;\r\n    } else {\r\n      leftTop.lat = parseInt(leftTop.lat + pointPerLat, 10);\r\n    }\r\n\r\n    if (leftTop.lng > 0 && rightBottom.lng < 0) {\r\n      rightBottom.lng += 360;\r\n    }\r\n    rightBottom.lng = parseInt(rightBottom.lng + pointPerLon, 10);\r\n    leftTop.lng = parseInt(leftTop.lng - pointPerLon, 10);\r\n\r\n    // Northern hemisphere\r\n    for (let i = this.currLatInterval; i <= leftTop.lat; i += this.currLatInterval) {\r\n      if (i >= rightBottom.lat) {\r\n        // Handle 'X' MGRS Zone - Do not need it for the southern equivalent 'C'\r\n        if (i === 80) {\r\n          i = 84;\r\n        }\r\n        this.drawLatitudeLine(ctx, i, leftTop.lng, rightBottom.lng);\r\n      }\r\n    }\r\n\r\n    // Southern hemisphere\r\n    for (let i = 0; i >= rightBottom.lat; i -= this.currLatInterval) {\r\n      if (i <= leftTop.lat) {\r\n        this.drawLatitudeLine(ctx, i, leftTop.lng, rightBottom.lng);\r\n      }\r\n    }\r\n\r\n    // Northern hemisphere\r\n    // HACK - Add six to the right bottom lng to make sure the East 31V boundary is displayed at all times\r\n    for (let i = this.currLngInterval; i <= rightBottom.lng + 6; i += this.currLngInterval) {\r\n      if (i >= leftTop.lng) {\r\n        this.drawLongitudeLine(ctx, i, leftTop.lat, rightBottom.lat);\r\n      }\r\n    }\r\n\r\n    // Southern hemisphere\r\n    for (let i = 0; i >= leftTop.lng; i -= this.currLngInterval) {\r\n      if (i <= rightBottom.lng) {\r\n        this.drawLongitudeLine(ctx, i, leftTop.lat, rightBottom.lat);\r\n      }\r\n    }\r\n  }\r\n\r\n  drawLatitudeLine(ctx, tick, lngLeft, lngRight) {\r\n    const leftEnd = this.map.latLngToContainerPoint({\r\n      lat: tick,\r\n      lng: lngLeft,\r\n    });\r\n\r\n    const rightEnd = this.map.latLngToContainerPoint({\r\n      lat: tick,\r\n      lng: lngRight,\r\n    });\r\n\r\n    ctx.beginPath();\r\n    ctx.moveTo(leftEnd.x, leftEnd.y);\r\n    ctx.lineTo(rightEnd.x, rightEnd.y);\r\n    ctx.stroke();\r\n  }\r\n\r\n  drawLongitudeLine(ctx, tick, latTop, latBottom) {\r\n    if (latTop >= 84) {\r\n      latTop = 84; // Ensure GZD vertical lines do not extend into the arctic\r\n    }\r\n\r\n    if (latBottom <= -80) {\r\n      latBottom = -80; // Ensure GZD vertical lines do not extend into the antarctic\r\n    }\r\n\r\n    const canvasTop = this.map.latLngToContainerPoint({\r\n      lat: latTop,\r\n      lng: tick,\r\n    });\r\n\r\n    const canvasBottom = this.map.latLngToContainerPoint({\r\n      lat: latBottom,\r\n      lng: tick,\r\n    });\r\n\r\n    const TOP_OF_W_SERIES_GZD = 72;\r\n\r\n    ctx.beginPath();\r\n    // Handle Norway\r\n    if (tick === 6) {\r\n      const TOP_OF_V_SERIES_GZD = 64;\r\n      const BOTTOM_OF_V_SERIES_GZD = 56;\r\n      const RIGHT_OF_31_SERIES_GZD = 3;\r\n\r\n      const RIGHT_TOP_OF_GZD = this.map.latLngToContainerPoint({\r\n        lat: TOP_OF_V_SERIES_GZD,\r\n        lng: tick,\r\n      });\r\n\r\n      const LEFT_TOP_OF_GZD = this.map.latLngToContainerPoint({\r\n        lat: TOP_OF_V_SERIES_GZD,\r\n        lng: RIGHT_OF_31_SERIES_GZD,\r\n      });\r\n\r\n      const LEFT_BOTTOM_OF_GZD = this.map.latLngToContainerPoint({\r\n        lat: BOTTOM_OF_V_SERIES_GZD,\r\n        lng: RIGHT_OF_31_SERIES_GZD,\r\n      });\r\n\r\n      const RIGHT_BOTTOM_OF_GZD = this.map.latLngToContainerPoint({\r\n        lat: BOTTOM_OF_V_SERIES_GZD,\r\n        lng: tick,\r\n      });\r\n      if (latTop > TOP_OF_V_SERIES_GZD && latBottom > BOTTOM_OF_V_SERIES_GZD) {\r\n        // Top segment only\r\n        // Do not draw through Svalbard\r\n        if (latTop > TOP_OF_W_SERIES_GZD) {\r\n          const TOP_LEFT_OF_32_SERIES_GZD = this.map.latLngToContainerPoint({\r\n            lat: TOP_OF_W_SERIES_GZD,\r\n            lng: tick,\r\n          });\r\n          ctx.moveTo(TOP_LEFT_OF_32_SERIES_GZD.x, TOP_LEFT_OF_32_SERIES_GZD.y);\r\n        } else {\r\n          ctx.moveTo(canvasTop.x, canvasTop.y);\r\n        }\r\n\r\n        ctx.lineTo(RIGHT_TOP_OF_GZD.x, RIGHT_TOP_OF_GZD.y);\r\n\r\n        ctx.moveTo(LEFT_TOP_OF_GZD.x, LEFT_TOP_OF_GZD.y);\r\n\r\n        ctx.lineTo(LEFT_TOP_OF_GZD.x, canvasBottom.y);\r\n      } else if (\r\n        //Bottom segment only\r\n        latTop < TOP_OF_V_SERIES_GZD &&\r\n        latBottom < BOTTOM_OF_V_SERIES_GZD\r\n      ) {\r\n        ctx.moveTo(LEFT_TOP_OF_GZD.x, canvasTop.y);\r\n\r\n        ctx.lineTo(LEFT_BOTTOM_OF_GZD.x, LEFT_BOTTOM_OF_GZD.y);\r\n\r\n        ctx.moveTo(RIGHT_BOTTOM_OF_GZD.x, RIGHT_BOTTOM_OF_GZD.y);\r\n\r\n        ctx.lineTo(RIGHT_BOTTOM_OF_GZD.x, canvasBottom.y);\r\n      } else if (\r\n        // Entire thing\r\n        latTop >= TOP_OF_V_SERIES_GZD &&\r\n        latBottom <= BOTTOM_OF_V_SERIES_GZD\r\n      ) {\r\n        // Do not draw through Svalbard\r\n        if (latTop > TOP_OF_W_SERIES_GZD) {\r\n          const TOP_LEFT_OF_32_SERIES_GZD = this.map.latLngToContainerPoint({\r\n            lat: TOP_OF_W_SERIES_GZD,\r\n            lng: tick,\r\n          });\r\n          ctx.moveTo(TOP_LEFT_OF_32_SERIES_GZD.x, TOP_LEFT_OF_32_SERIES_GZD.y);\r\n        } else {\r\n          ctx.moveTo(canvasTop.x, canvasTop.y);\r\n        }\r\n\r\n        ctx.lineTo(RIGHT_TOP_OF_GZD.x, RIGHT_TOP_OF_GZD.y);\r\n\r\n        ctx.moveTo(LEFT_TOP_OF_GZD.x, LEFT_TOP_OF_GZD.y);\r\n\r\n        ctx.lineTo(LEFT_BOTTOM_OF_GZD.x, LEFT_BOTTOM_OF_GZD.y);\r\n\r\n        ctx.moveTo(RIGHT_TOP_OF_GZD.x, LEFT_BOTTOM_OF_GZD.y);\r\n\r\n        ctx.lineTo(RIGHT_TOP_OF_GZD.x, canvasBottom.y);\r\n      } else if (\r\n        // Modified vertical only\r\n        latTop <= TOP_OF_V_SERIES_GZD &&\r\n        latBottom >= BOTTOM_OF_V_SERIES_GZD\r\n      ) {\r\n        ctx.moveTo(LEFT_TOP_OF_GZD.x, canvasTop.y);\r\n\r\n        ctx.lineTo(LEFT_BOTTOM_OF_GZD.x, canvasBottom.y);\r\n      }\r\n    } else if (tick === 12) {\r\n      if (latTop > TOP_OF_W_SERIES_GZD && latTop <= 84) {\r\n        // Handle Svalbard\r\n        const TOP_LEFT_OF_33X_GZD = this.map.latLngToContainerPoint({\r\n          lat: latTop,\r\n          lng: 9,\r\n        });\r\n        ctx.moveTo(TOP_LEFT_OF_33X_GZD.x, TOP_LEFT_OF_33X_GZD.y);\r\n\r\n        const BOTTOM_LEFT_OF_33X_GZD = this.map.latLngToContainerPoint({\r\n          lat: TOP_OF_W_SERIES_GZD,\r\n          lng: 9,\r\n        });\r\n\r\n        ctx.lineTo(BOTTOM_LEFT_OF_33X_GZD.x, BOTTOM_LEFT_OF_33X_GZD.y);\r\n\r\n        const TOP_RIGHT_OF_32W_GZD = this.map.latLngToContainerPoint({\r\n          lat: TOP_OF_W_SERIES_GZD,\r\n          lng: tick,\r\n        });\r\n\r\n        ctx.moveTo(TOP_RIGHT_OF_32W_GZD.x, TOP_RIGHT_OF_32W_GZD.y);\r\n\r\n        ctx.lineTo(canvasBottom.x, canvasBottom.y);\r\n      } else {\r\n        // Normal use case\r\n        ctx.moveTo(canvasTop.x, canvasTop.y);\r\n        ctx.lineTo(canvasBottom.x, canvasBottom.y);\r\n      }\r\n    } else if (tick === 18) {\r\n      // Do not draw through Svalbard\r\n      if (latTop > TOP_OF_W_SERIES_GZD) {\r\n        const TOP_LEFT_OF_34_SERIES_GZD = this.map.latLngToContainerPoint({\r\n          lat: TOP_OF_W_SERIES_GZD,\r\n          lng: tick,\r\n        });\r\n        ctx.moveTo(TOP_LEFT_OF_34_SERIES_GZD.x, TOP_LEFT_OF_34_SERIES_GZD.y);\r\n      } else {\r\n        ctx.moveTo(canvasTop.x, canvasTop.y);\r\n      }\r\n      ctx.lineTo(canvasBottom.x, canvasBottom.y);\r\n    } else if (tick === 24) {\r\n      if (latTop > TOP_OF_W_SERIES_GZD && latTop <= 84) {\r\n        // Handle Svalbard\r\n        const TOP_LEFT_OF_35X_GZD = this.map.latLngToContainerPoint({\r\n          lat: latTop,\r\n          lng: 21,\r\n        });\r\n        ctx.moveTo(TOP_LEFT_OF_35X_GZD.x, TOP_LEFT_OF_35X_GZD.y);\r\n\r\n        const BOTTOM_LEFT_OF_35X_GZD = this.map.latLngToContainerPoint({\r\n          lat: TOP_OF_W_SERIES_GZD,\r\n          lng: 21,\r\n        });\r\n\r\n        ctx.lineTo(BOTTOM_LEFT_OF_35X_GZD.x, BOTTOM_LEFT_OF_35X_GZD.y);\r\n\r\n        const TOP_RIGHT_OF_34W_GZD = this.map.latLngToContainerPoint({\r\n          lat: TOP_OF_W_SERIES_GZD,\r\n          lng: tick,\r\n        });\r\n\r\n        ctx.moveTo(TOP_RIGHT_OF_34W_GZD.x, TOP_RIGHT_OF_34W_GZD.y);\r\n\r\n        ctx.lineTo(canvasBottom.x, canvasBottom.y);\r\n      } else {\r\n        // Normal use case\r\n        ctx.moveTo(canvasTop.x, canvasTop.y);\r\n        ctx.lineTo(canvasBottom.x, canvasBottom.y);\r\n      }\r\n    } else if (tick === 30) {\r\n      // Do not draw through Svalbard\r\n      if (latTop > TOP_OF_W_SERIES_GZD) {\r\n        const TOP_LEFT_OF_35_SERIES_GZD = this.map.latLngToContainerPoint({\r\n          lat: TOP_OF_W_SERIES_GZD,\r\n          lng: tick,\r\n        });\r\n        ctx.moveTo(TOP_LEFT_OF_35_SERIES_GZD.x, TOP_LEFT_OF_35_SERIES_GZD.y);\r\n      } else {\r\n        ctx.moveTo(canvasTop.x, canvasTop.y);\r\n      }\r\n      ctx.lineTo(canvasBottom.x, canvasBottom.y);\r\n    } else if (tick === 36) {\r\n      if (latTop > TOP_OF_W_SERIES_GZD && latTop <= 84) {\r\n        // Handle Svalbard\r\n        const TOP_LEFT_OF_37X_GZD = this.map.latLngToContainerPoint({\r\n          lat: latTop,\r\n          lng: 33,\r\n        });\r\n        ctx.moveTo(TOP_LEFT_OF_37X_GZD.x, TOP_LEFT_OF_37X_GZD.y);\r\n\r\n        const BOTTOM_LEFT_OF_37X_GZD = this.map.latLngToContainerPoint({\r\n          lat: TOP_OF_W_SERIES_GZD,\r\n          lng: 33,\r\n        });\r\n\r\n        ctx.lineTo(BOTTOM_LEFT_OF_37X_GZD.x, BOTTOM_LEFT_OF_37X_GZD.y);\r\n\r\n        const TOP_RIGHT_OF_36W_GZD = this.map.latLngToContainerPoint({\r\n          lat: TOP_OF_W_SERIES_GZD,\r\n          lng: tick,\r\n        });\r\n\r\n        ctx.moveTo(TOP_RIGHT_OF_36W_GZD.x, TOP_RIGHT_OF_36W_GZD.y);\r\n\r\n        ctx.lineTo(canvasBottom.x, canvasBottom.y);\r\n      } else {\r\n        // Normal use case\r\n        ctx.moveTo(canvasTop.x, canvasTop.y);\r\n        ctx.lineTo(canvasBottom.x, canvasBottom.y);\r\n      }\r\n    }\r\n    // The rest of the world...\r\n    else {\r\n      ctx.moveTo(canvasTop.x, canvasTop.y);\r\n      ctx.lineTo(canvasBottom.x, canvasBottom.y);\r\n    }\r\n    ctx.stroke();\r\n\r\n    this.drawGzdLabels(ctx, tick);\r\n  }\r\n\r\n  /** This function encapsulates drawing labels for GZDs\r\n   *\r\n   * @param {Obj} ctx - The HTML5 canvas' context\r\n   * @param {Int} longitude - The longitude (representing a boundary of a GZD) for which needs labels drawn for\r\n   */\r\n  drawGzdLabels(ctx, longitude) {\r\n    // -76 = middle latitude of the 'C' band - place the label in the middle\r\n    for (let labelLatitude = -76; labelLatitude < 84; labelLatitude += 8) {\r\n      let labelLongitude;\r\n      if (labelLatitude === 60) {\r\n        if (longitude === 0) {\r\n          //31V\r\n          labelLongitude = 1.5;\r\n        } else if (longitude === 6) {\r\n          //32V\r\n          labelLongitude = 7.5;\r\n        } else {\r\n          labelLongitude = longitude + 3;\r\n        }\r\n      } else if (labelLatitude === 76) {\r\n        if (longitude === 0) {\r\n          //31X\r\n          labelLongitude = 4.5;\r\n        } else if (longitude === 12) {\r\n          //33X\r\n          labelLongitude = 15;\r\n        } else if (longitude === 24) {\r\n          //35X\r\n          labelLongitude = 27;\r\n        } else if (longitude === 36) {\r\n          //37X\r\n          labelLongitude = 37.5;\r\n        } else {\r\n          labelLongitude = longitude + 3;\r\n        }\r\n      } else {\r\n        // Rest of the world...\r\n        labelLongitude = longitude + 3;\r\n      }\r\n\r\n      let gzdLabel;\r\n      try {\r\n        gzdLabel = llToMgrs([labelLongitude, labelLatitude], 1).match(MGRS_REGEX)[GZD_INDEX];\r\n      } catch (error) {\r\n        return; //Invalid MGRS value returned, so no need to try to display a label\r\n      }\r\n\r\n      // Don't want to display duplicates of the following zones\r\n      if (\r\n        !(gzdLabel === '33X' && longitude === 6) &&\r\n        !(gzdLabel === '35X' && longitude === 18) &&\r\n        !(gzdLabel === '37X' && longitude === 30)\r\n      ) {\r\n        const labelXy = this.map.latLngToContainerPoint({\r\n          lat: labelLatitude,\r\n          lng: labelLongitude,\r\n        });\r\n\r\n        drawLabel(ctx, gzdLabel, this.options.fontColor, this.options.color, labelXy);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport { GzdGraticule };\r\n","import { Layer } from 'leaflet';\r\nimport { useMap } from 'react-leaflet';\r\nimport { forward } from 'mgrs';\r\n\r\nimport { connectToGzdBoundary, drawLabel, getAdjustedLatitude, getAllVisibleGzds, getLineSlope } from './CommonUtils';\r\n\r\nimport { getGZD } from 'gzd-utils';\r\n\r\n// The following indicies are used to indentify coordinates returned from gzd-utils\r\nconst SW_INDEX = 0;\r\nconst NW_INDEX = 1;\r\nconst NE_INDEX = 2;\r\nconst SE_INDEX = 3;\r\n\r\nconst LATITUDE_INDEX = 1;\r\nconst LONGITUDE_INDEX = 0;\r\n\r\nconst MGRS_REGEX = /([0-9]+[A-Z])([A-Z]{2})(\\d+)/;\r\nconst GZD_INDEX = 1; //The group index for the 100k identifier in the regex above\r\nconst HK_INDEX = 2;\r\n\r\nvar utmObj = require('utm-latlng');\r\nvar utm = new utmObj(); // Defaults to WGS-84\r\n\r\nconst HundredKGraticule = (props) => {\r\n  let map = useMap();\r\n\r\n  const canvas = document.createElement('canvas');\r\n  canvas.classList.add('leaflet-zoom-animated');\r\n\r\n  let g = new Graticule({ map: map, canvas: canvas });\r\n  map.addLayer(g);\r\n\r\n  return null;\r\n};\r\n\r\nclass Graticule extends Layer {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    this.updateVariables = this.updateVariables.bind(this);\r\n\r\n    this.defaultOptions = {\r\n      showGrid: true,\r\n      showLabel: true,\r\n      opacity: 10,\r\n      weight: 2,\r\n      color: '#990000', //Font background colour and dash colour\r\n      font: '15px Courier New',\r\n      fontColor: '#FFFFFF',\r\n      dashArray: [4, 4],\r\n      eastingArray: [],\r\n      northingArray: [],\r\n      minZoom: 6, //Must be at least at this zoom to see the graticules\r\n      maxZoom: 10,\r\n    };\r\n\r\n    this.options = (props && props.options) || this.defaultOptions;\r\n\r\n    this.map = props.map;\r\n    this.canvas = props.canvas;\r\n    this.northingArray = [];\r\n    this.eastingArray = [];\r\n\r\n    this.HUNDRED_K_GRID_INTERVAL = 100000;\r\n  }\r\n\r\n  updateVariables(props) {\r\n    this.options = (props && props.options) || this.defaultOptions;\r\n  }\r\n\r\n  onAdd(map) {\r\n    map._panes.overlayPane.appendChild(this.canvas);\r\n    map.on('viewreset', this.reset, this);\r\n    map.on('move', this.reset, this);\r\n\r\n    this.reset();\r\n  }\r\n\r\n  onRemove(map) {\r\n    map._panes.overlayPane.removeChild(this.canvas);\r\n    map.off('viewreset', this.reset, this);\r\n    map.off('move', this.reset, this);\r\n\r\n    this.canvas = null;\r\n    this.map = null;\r\n  }\r\n\r\n  /**\r\n   * Called whenever the map is moved.  Redraws the grids.\r\n   */\r\n  reset() {\r\n    const MAP_SIZE = this.map.getSize();\r\n    const MAP_TOP_LEFT = this.map.containerPointToLayerPoint([0, 0]);\r\n\r\n    this.canvas.style['transform'] = `translate3d(${MAP_TOP_LEFT.x}px,${MAP_TOP_LEFT.y}px,0)`;\r\n\r\n    this.canvas.width = MAP_SIZE.x;\r\n    this.canvas.height = MAP_SIZE.y;\r\n    const ZOOM = this.map.getZoom();\r\n\r\n    if (ZOOM > this.options.minZoom && ZOOM < this.options.maxZoom) {\r\n      let visibleGrids = this.getVizGrids();\r\n\r\n      this.eastingArray = [];\r\n      this.northingArray = [];\r\n      this.generateGrids(visibleGrids);\r\n    }\r\n  }\r\n\r\n  getVizGrids() {\r\n    const NW_BOUND_MGRS = forward(\r\n      [this.map.getBounds().getNorthWest()['lng'], this.map.getBounds().getNorthWest()['lat']],\r\n      1\r\n    );\r\n    const NE_BOUND_MGRS = forward(\r\n      [this.map.getBounds().getNorthEast()['lng'], this.map.getBounds().getNorthEast()['lat']],\r\n      1\r\n    );\r\n    const SE_BOUND_MGRS = forward(\r\n      [this.map.getBounds().getSouthEast()['lng'], this.map.getBounds().getSouthEast()['lat']],\r\n      1\r\n    );\r\n    const SW_BOUND_MGRS = forward(\r\n      [this.map.getBounds().getSouthWest()['lng'], this.map.getBounds().getSouthWest()['lat']],\r\n      1\r\n    );\r\n\r\n    let visibleGrids = getAllVisibleGzds(\r\n      NW_BOUND_MGRS.match(MGRS_REGEX)[GZD_INDEX],\r\n      NE_BOUND_MGRS.match(MGRS_REGEX)[GZD_INDEX],\r\n      SE_BOUND_MGRS.match(MGRS_REGEX)[GZD_INDEX],\r\n      SW_BOUND_MGRS.match(MGRS_REGEX)[GZD_INDEX]\r\n    );\r\n\r\n    return visibleGrids;\r\n  }\r\n\r\n  getPaddingOnZoomLevel(currentZoom) {\r\n    switch (currentZoom) {\r\n      case 17:\r\n        return 60;\r\n      case 16:\r\n        return 60;\r\n      case 15:\r\n        return 60;\r\n      case 14:\r\n        return 30;\r\n      case 13:\r\n        return 15;\r\n      case 12:\r\n        return 7;\r\n      case 11:\r\n        return 4;\r\n      case 10:\r\n        return 3;\r\n      case 9:\r\n        return 3;\r\n      case 8:\r\n        return 3;\r\n      case 7:\r\n        return 3;\r\n      case 6:\r\n        return 1;\r\n      default:\r\n        return 1;\r\n    }\r\n  }\r\n\r\n  handle31VLabels(ctx, adjustedLl, coordinateLl) {\r\n    const HALF_DEGREE = 0.5; // Approximate distance used to centre the label in the middle of the HK zone\r\n    const LABEL_XY = this.map.latLngToContainerPoint({\r\n      lat: (adjustedLl.lat + coordinateLl.lat) / 2 + HALF_DEGREE,\r\n      lng: (adjustedLl.lng + coordinateLl.lng) / 2,\r\n    });\r\n\r\n    // This is extra label text\r\n    const LABEL_TEXT = forward([\r\n      (adjustedLl.lng + coordinateLl.lng) / 2,\r\n      (adjustedLl.lat + coordinateLl.lat) / 2 + HALF_DEGREE,\r\n    ]).match(MGRS_REGEX)[HK_INDEX];\r\n\r\n    drawLabel(ctx, LABEL_TEXT, this.options.fontColor, this.options.color, LABEL_XY);\r\n  }\r\n\r\n  handle31V(ctx, elemUtm, coordinateLl) {\r\n    const ZONE_BOUNDARIES = getGZD('31V');\r\n    const WEST_GZD_LONGITUDE = ZONE_BOUNDARIES['geometry']['coordinates'][0][NW_INDEX][LONGITUDE_INDEX];\r\n    const EAST_GZD_LONGITUDE = ZONE_BOUNDARIES['geometry']['coordinates'][0][NE_INDEX][LONGITUDE_INDEX];\r\n\r\n    // 60km east of elem at the same northing - The shortest segment was measured to be around 65k\r\n    const TEMP_POINT_LL = utm.convertUtmToLatLng(\r\n      elemUtm.easting + 60000,\r\n      elemUtm.northing,\r\n      elemUtm.zoneNumber,\r\n      elemUtm.zoneLetter\r\n    );\r\n\r\n    const SLOPE = getLineSlope(coordinateLl, TEMP_POINT_LL);\r\n\r\n    // From the line slope derive the intersecting point with the GZD boundary\r\n    const ADJUSTED_EAST_LATITUDE = getAdjustedLatitude(SLOPE, EAST_GZD_LONGITUDE, TEMP_POINT_LL);\r\n\r\n    const EAST_GZD_BOUNDARY_POINT = this.map.latLngToContainerPoint({\r\n      lat: ADJUSTED_EAST_LATITUDE,\r\n      lng: EAST_GZD_LONGITUDE,\r\n    });\r\n\r\n    // Derive the west intersecting point using the same slope.\r\n    const ADJUSTED_WEST_LATITUDE = getAdjustedLatitude(SLOPE, WEST_GZD_LONGITUDE, TEMP_POINT_LL);\r\n\r\n    const WEST_GZD_BOUNDARY_POINT = this.map.latLngToContainerPoint({\r\n      lat: ADJUSTED_WEST_LATITUDE,\r\n      lng: WEST_GZD_LONGITUDE,\r\n    });\r\n    ctx.moveTo(WEST_GZD_BOUNDARY_POINT.x, WEST_GZD_BOUNDARY_POINT.y);\r\n    ctx.lineTo(EAST_GZD_BOUNDARY_POINT.x, EAST_GZD_BOUNDARY_POINT.y);\r\n\r\n    // Eastern 31V Labels\r\n    this.handle31VLabels(ctx, { lat: ADJUSTED_EAST_LATITUDE, lng: EAST_GZD_LONGITUDE }, coordinateLl);\r\n\r\n    // Western 31V Labels\r\n    this.handle31VLabels(ctx, { lat: ADJUSTED_WEST_LATITUDE, lng: WEST_GZD_LONGITUDE }, coordinateLl);\r\n  }\r\n\r\n  processEastingsAndNorthings(startingNorthingUtm, startingEastingUtm, finalNorthingUtm, finalEastingUtm) {\r\n    let northingIterator = startingNorthingUtm.Northing;\r\n    let eastingIterator = startingEastingUtm.Easting;\r\n\r\n    //Round to nearest 100k metres -- the loop will need to iterate to there anyways\r\n    northingIterator = Math.ceil(northingIterator / this.HUNDRED_K_GRID_INTERVAL) * this.HUNDRED_K_GRID_INTERVAL;\r\n    eastingIterator = Math.ceil(eastingIterator / this.HUNDRED_K_GRID_INTERVAL) * this.HUNDRED_K_GRID_INTERVAL;\r\n\r\n    // HACK - Workaround for conversion error\r\n    if (startingNorthingUtm.ZoneNumber.toString() + startingNorthingUtm.ZoneLetter === '31W') {\r\n      northingIterator = 7100000; // Round down for special case\r\n    }\r\n\r\n    // Find all northing grids that are divisible by 100,000\r\n    if (startingNorthingUtm.ZoneLetter === finalNorthingUtm.ZoneLetter) {\r\n      while (northingIterator <= finalNorthingUtm.Northing) {\r\n        // This loop checks to make sure the easting grid is divisible by 100K\r\n        if (northingIterator % this.HUNDRED_K_GRID_INTERVAL === 0) {\r\n          this.northingArray.push({\r\n            northing: northingIterator,\r\n            zoneNumber: startingNorthingUtm.ZoneNumber,\r\n            zoneLetter: startingNorthingUtm.ZoneLetter,\r\n          });\r\n        }\r\n        northingIterator += this.HUNDRED_K_GRID_INTERVAL;\r\n      }\r\n    }\r\n    // Find all easting grids that are divisible by 100,000\r\n    if (startingEastingUtm.ZoneLetter === finalEastingUtm.ZoneLetter) {\r\n      while (eastingIterator <= finalEastingUtm.Easting) {\r\n        if (eastingIterator % this.HUNDRED_K_GRID_INTERVAL === 0) {\r\n          this.eastingArray.push({\r\n            easting: eastingIterator,\r\n            zoneNumber: startingEastingUtm.ZoneNumber,\r\n            zoneLetter: startingEastingUtm.ZoneLetter,\r\n          });\r\n        }\r\n        eastingIterator += this.HUNDRED_K_GRID_INTERVAL;\r\n      }\r\n    }\r\n  }\r\n\r\n  processGridIntersection(mapBounds, eastingElem, northingElem) {\r\n    if (eastingElem.zoneNumber === northingElem.zoneNumber && eastingElem.zoneLetter === northingElem.zoneLetter) {\r\n      const GRID_INTERSECTION = {\r\n        northing: northingElem.northing,\r\n        easting: eastingElem.easting,\r\n        zoneNumber: northingElem.zoneNumber,\r\n        zoneLetter: northingElem.zoneLetter,\r\n      };\r\n\r\n      if (\r\n        mapBounds.contains(\r\n          utm.convertUtmToLatLng(\r\n            GRID_INTERSECTION.easting,\r\n            GRID_INTERSECTION.northing,\r\n            GRID_INTERSECTION.zoneNumber,\r\n            GRID_INTERSECTION.zoneLetter\r\n          )\r\n        )\r\n      ) {\r\n        return GRID_INTERSECTION;\r\n      }\r\n    }\r\n  }\r\n\r\n  handleEquatorLabels(ctx, firstIntersection, secondIntersection) {\r\n    let labelCoordinateLl = utm.convertUtmToLatLng(\r\n      Math.floor((firstIntersection.easting + secondIntersection.easting) / 2),\r\n      Math.floor(firstIntersection.northing - 50000),\r\n      firstIntersection.zoneNumber,\r\n      firstIntersection.zoneLetter\r\n    );\r\n\r\n    let labelText = forward([labelCoordinateLl.lng, labelCoordinateLl.lat]).match(MGRS_REGEX)[HK_INDEX];\r\n\r\n    drawLabel(\r\n      ctx,\r\n      labelText,\r\n      this.options.fontColor,\r\n      this.options.color,\r\n      this.map.latLngToContainerPoint({\r\n        lat: labelCoordinateLl.lat,\r\n        lng: labelCoordinateLl.lng,\r\n      })\r\n    );\r\n  }\r\n\r\n  generateGrids(visibleGzds) {\r\n    let ctx = this.canvas.getContext('2d');\r\n    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n    ctx.lineWidth = this.options.weight;\r\n    ctx.strokeStyle = this.options.color;\r\n    ctx.fillStyle = this.options.color;\r\n    ctx.setLineDash(this.options.dashArray);\r\n    ctx.font = this.options.font;\r\n\r\n    visibleGzds.forEach((gzd) => {\r\n      // Get Lat/Long bounds for each GZD\r\n      let zoneBoundaries;\r\n      try {\r\n        zoneBoundaries = getGZD(gzd);\r\n      } catch (error) {\r\n        return; //Invalid MGRS value returned, so no need to try to display the grid\r\n      }\r\n\r\n      const SW_CORNER_LL = zoneBoundaries['geometry']['coordinates'][0][SW_INDEX];\r\n      const NW_CORNER_LL = zoneBoundaries['geometry']['coordinates'][0][NW_INDEX];\r\n      const NE_CORNER_LL = zoneBoundaries['geometry']['coordinates'][0][NE_INDEX];\r\n      const SE_CORNER_LL = zoneBoundaries['geometry']['coordinates'][0][SE_INDEX];\r\n\r\n      const UTM_RESOLUTION = 0; //No decimal places when returning the UTM location\r\n\r\n      const BUFFER = 0.00001; // HACK - This buffer shrinks the UTM.  Very magical.\r\n\r\n      //BUG - Incorrect conversion from LL to UTM in the SW corner of the 33V GZD will make\r\n      // it think that it is in the 32V GZD.  Without manually setting it the algorithm will\r\n      // create a second set of lines over Norway and leave Sweden blank.\r\n      const SW_CORNER_UTM =\r\n        gzd === '33V'\r\n          ? {\r\n              ZoneLetter: 'V',\r\n              ZoneNumber: 33,\r\n              Easting: 312900,\r\n              Northing: 6210142,\r\n            }\r\n          : utm.convertLatLngToUtm(\r\n              SW_CORNER_LL[LATITUDE_INDEX] + BUFFER,\r\n              SW_CORNER_LL[LONGITUDE_INDEX] + BUFFER,\r\n              UTM_RESOLUTION\r\n            );\r\n      const NW_CORNER_UTM = utm.convertLatLngToUtm(\r\n        NW_CORNER_LL[LATITUDE_INDEX] - BUFFER,\r\n        NW_CORNER_LL[LONGITUDE_INDEX] + BUFFER,\r\n        UTM_RESOLUTION\r\n      );\r\n      const NE_CORNER_UTM = utm.convertLatLngToUtm(\r\n        NE_CORNER_LL[LATITUDE_INDEX] - BUFFER,\r\n        NE_CORNER_LL[LONGITUDE_INDEX] - BUFFER,\r\n        UTM_RESOLUTION\r\n      );\r\n      const SE_CORNER_UTM = utm.convertLatLngToUtm(\r\n        SE_CORNER_LL[LATITUDE_INDEX] + BUFFER,\r\n        SE_CORNER_LL[LONGITUDE_INDEX] - BUFFER,\r\n        UTM_RESOLUTION\r\n      );\r\n\r\n      const HEMISPHERE = this.map.getCenter().lat <= 0 ? 'South' : 'North';\r\n\r\n      switch (HEMISPHERE) {\r\n        case 'North':\r\n          this.processEastingsAndNorthings(SW_CORNER_UTM, SW_CORNER_UTM, NE_CORNER_UTM, SE_CORNER_UTM);\r\n          break;\r\n        case 'South':\r\n          this.processEastingsAndNorthings(SW_CORNER_UTM, NW_CORNER_UTM, NE_CORNER_UTM, NE_CORNER_UTM);\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n    });\r\n\r\n    const MAP_BOUNDS = this.map.getBounds().pad(this.getPaddingOnZoomLevel(this.map.getZoom()));\r\n    this.northingArray.forEach((northingElem) => {\r\n      let northingGridsArray = [];\r\n\r\n      this.eastingArray.forEach((eastingElem) => {\r\n        let intersection = this.processGridIntersection(MAP_BOUNDS, eastingElem, northingElem);\r\n        if (intersection) {\r\n          northingGridsArray.push(intersection);\r\n        }\r\n      });\r\n\r\n      northingGridsArray.forEach((elem, index, array) => {\r\n        let COORDINATE_LL = utm.convertUtmToLatLng(elem.easting, elem.northing, elem.zoneNumber, elem.zoneLetter);\r\n\r\n        let COORDINATE_XY = this.map.latLngToContainerPoint({\r\n          lat: COORDINATE_LL.lat,\r\n          lng: COORDINATE_LL.lng,\r\n        });\r\n\r\n        let gzd = elem.zoneNumber.toString() + elem.zoneLetter;\r\n        // Since there is only one northing array in zone 31V, we need to treat this zone\r\n        // specially.  For each point in 31V, we will traverse the grid horizontally in\r\n        // order to get a second point to derive a line from. From there it will be expanded\r\n        // to cover the entire GZD.\r\n        if (gzd === '31V') {\r\n          this.handle31V(ctx, elem, COORDINATE_LL);\r\n        } else {\r\n          if (index === 0) {\r\n            if (northingGridsArray[index]) {\r\n              const NEXT_COORDINATE_LL = utm.convertUtmToLatLng(\r\n                northingGridsArray[index].easting,\r\n                northingGridsArray[index].northing,\r\n                northingGridsArray[index].zoneNumber,\r\n                northingGridsArray[index].zoneLetter\r\n              );\r\n\r\n              // Get Lat/Long bounds for each GZD\r\n              const WEST_GZD_LONGITUDE = getGZD(gzd)['geometry']['coordinates'][0][NW_INDEX][LONGITUDE_INDEX];\r\n\r\n              // If the first point is west of the GZD western boundary\r\n              if (COORDINATE_LL.lng < WEST_GZD_LONGITUDE) {\r\n                let slope = getLineSlope(COORDINATE_LL, NEXT_COORDINATE_LL);\r\n\r\n                let adjustedLatitude = getAdjustedLatitude(slope, WEST_GZD_LONGITUDE, NEXT_COORDINATE_LL);\r\n\r\n                COORDINATE_XY = this.map.latLngToContainerPoint({\r\n                  lat: adjustedLatitude,\r\n                  lng: WEST_GZD_LONGITUDE,\r\n                });\r\n                // If the first point is east of the GZD western boundary\r\n              } else if (COORDINATE_LL.lng > WEST_GZD_LONGITUDE) {\r\n                let additionalPoint = connectToGzdBoundary(COORDINATE_LL, NEXT_COORDINATE_LL, 'West');\r\n\r\n                let cachedCoordinateXy = COORDINATE_XY; // Used to determine whether we actually display the label\r\n\r\n                COORDINATE_XY = this.map.latLngToContainerPoint({\r\n                  lat: additionalPoint.lat,\r\n                  lng: additionalPoint.lng,\r\n                });\r\n\r\n                // This is extra label text\r\n                let labelText = forward([additionalPoint.lng, additionalPoint.lat]).match(MGRS_REGEX)[HK_INDEX];\r\n\r\n                let labelWidth = ctx.measureText(labelText).width;\r\n\r\n                // If the label is wider than the zone it represents (with a scale factor), don't display\r\n                if (Math.abs(cachedCoordinateXy.x - COORDINATE_XY.x) / 1.5 > labelWidth) {\r\n                  drawLabel(\r\n                    ctx,\r\n                    labelText,\r\n                    this.options.fontColor,\r\n                    this.options.color,\r\n                    this.map.latLngToContainerPoint({\r\n                      lat: Math.abs(additionalPoint.lng - COORDINATE_LL.lng) / 2 + additionalPoint.lat,\r\n                      lng: (additionalPoint.lng + COORDINATE_LL.lng) / 2,\r\n                    })\r\n                  );\r\n                }\r\n\r\n                // Handle a special case in a GZD adjacent to the Norway special zones\r\n                if (labelText === 'LT' && gzd === '32W') {\r\n                  labelText = forward([\r\n                    (additionalPoint.lng + COORDINATE_LL.lng) / 2,\r\n                    Math.abs(additionalPoint.lng - COORDINATE_LL.lng) / 2 - additionalPoint.lat,\r\n                  ]).match(MGRS_REGEX)[HK_INDEX];\r\n\r\n                  labelWidth = ctx.measureText(labelText).width;\r\n\r\n                  // If the label is wider than the zone it represents (with a scale factor), don't display\r\n                  if (Math.abs(cachedCoordinateXy.x - COORDINATE_XY.x) / 1.5 > labelWidth) {\r\n                    drawLabel(\r\n                      ctx,\r\n                      labelText,\r\n                      this.options.fontColor,\r\n                      this.options.color,\r\n                      this.map.latLngToContainerPoint({\r\n                        lat: additionalPoint.lat - Math.abs(additionalPoint.lng - COORDINATE_LL.lng) / 2,\r\n                        lng: (additionalPoint.lng + COORDINATE_LL.lng) / 2,\r\n                      })\r\n                    );\r\n                  }\r\n                }\r\n              }\r\n\r\n              let labelCoordinateLl = utm.convertUtmToLatLng(\r\n                Math.floor((northingGridsArray[index].easting + northingGridsArray[index + 1].easting) / 2),\r\n                Math.floor(northingGridsArray[index].northing + 50000),\r\n                northingGridsArray[index].zoneNumber,\r\n                northingGridsArray[index].zoneLetter\r\n              );\r\n\r\n              let labelText = forward([labelCoordinateLl.lng, labelCoordinateLl.lat]).match(MGRS_REGEX)[HK_INDEX];\r\n\r\n              if (!(labelText === 'EM' && gzd === '32V')) {\r\n                drawLabel(\r\n                  ctx,\r\n                  labelText,\r\n                  this.options.fontColor,\r\n                  this.options.color,\r\n                  this.map.latLngToContainerPoint({\r\n                    lat: labelCoordinateLl.lat,\r\n                    lng: labelCoordinateLl.lng,\r\n                  })\r\n                );\r\n              }\r\n\r\n              if (elem.zoneLetter === 'N') {\r\n                this.handleEquatorLabels(ctx, northingGridsArray[index], northingGridsArray[index + 1]);\r\n              }\r\n            }\r\n            ctx.beginPath();\r\n\r\n            ctx.moveTo(COORDINATE_XY.x, COORDINATE_XY.y);\r\n          } else {\r\n            // Last element in the northing grids array\r\n            if (index === array.length - 1) {\r\n              const EAST_GZD_LONGITUDE = getGZD(gzd)['geometry']['coordinates'][0][NE_INDEX][LONGITUDE_INDEX];\r\n              const PREV_COORDINATE_LL = utm.convertUtmToLatLng(\r\n                northingGridsArray[index - 1].easting,\r\n                northingGridsArray[index - 1].northing,\r\n                northingGridsArray[index - 1].zoneNumber,\r\n                northingGridsArray[index - 1].zoneLetter\r\n              );\r\n              // The final point is to the east of the eastern GZD boundary, so it needs\r\n              // to be moved back to the boundary\r\n              if (COORDINATE_LL.lng > EAST_GZD_LONGITUDE) {\r\n                let slope = getLineSlope(COORDINATE_LL, PREV_COORDINATE_LL);\r\n\r\n                let adjustedLatitude = getAdjustedLatitude(slope, EAST_GZD_LONGITUDE, PREV_COORDINATE_LL);\r\n\r\n                COORDINATE_XY = this.map.latLngToContainerPoint({\r\n                  lat: adjustedLatitude,\r\n                  lng: EAST_GZD_LONGITUDE,\r\n                });\r\n                // The final point is to the west of the eastern GZD boundary, so another\r\n                // point needs to be made to account for the additional 100k zone\r\n              } else if (COORDINATE_LL.lng <= EAST_GZD_LONGITUDE) {\r\n                let additionalPoint = connectToGzdBoundary(COORDINATE_LL, PREV_COORDINATE_LL, 'East');\r\n\r\n                let cachedCoordinateXy = COORDINATE_XY; // Used to determine whether we actually display the label\r\n\r\n                COORDINATE_XY = this.map.latLngToContainerPoint({\r\n                  lat: additionalPoint.lat,\r\n                  lng: additionalPoint.lng,\r\n                });\r\n\r\n                // This is extra label text\r\n                let labelText = forward([COORDINATE_LL.lng, COORDINATE_LL.lat]).match(MGRS_REGEX)[HK_INDEX];\r\n\r\n                let labelWidth = ctx.measureText(labelText).width;\r\n\r\n                // If the label is wider than the zone it represents (with a scale factor), don't display\r\n                if (Math.abs(cachedCoordinateXy.x - COORDINATE_XY.x) / 1.5 > labelWidth) {\r\n                  drawLabel(\r\n                    ctx,\r\n                    labelText,\r\n                    this.options.fontColor,\r\n                    this.options.color,\r\n                    this.map.latLngToContainerPoint({\r\n                      lat: Math.abs(additionalPoint.lng - COORDINATE_LL.lng) / 2 + additionalPoint.lat,\r\n                      lng: (additionalPoint.lng + COORDINATE_LL.lng) / 2,\r\n                    })\r\n                  );\r\n                }\r\n              }\r\n\r\n              let labelCoordinateLl = utm.convertUtmToLatLng(\r\n                Math.floor((northingGridsArray[index].easting + northingGridsArray[index - 1].easting) / 2),\r\n                Math.floor(northingGridsArray[index].northing + 50000),\r\n                northingGridsArray[index].zoneNumber,\r\n                northingGridsArray[index].zoneLetter\r\n              );\r\n\r\n              let labelText = forward([labelCoordinateLl.lng, labelCoordinateLl.lat]).match(MGRS_REGEX)[HK_INDEX];\r\n\r\n              drawLabel(\r\n                ctx,\r\n                labelText,\r\n                this.options.fontColor,\r\n                this.options.color,\r\n                this.map.latLngToContainerPoint({\r\n                  lat: labelCoordinateLl.lat,\r\n                  lng: labelCoordinateLl.lng,\r\n                })\r\n              );\r\n            } else {\r\n              let labelCoordinateLl = utm.convertUtmToLatLng(\r\n                Math.floor((northingGridsArray[index].easting + northingGridsArray[index + 1].easting) / 2),\r\n                Math.floor(northingGridsArray[index].northing + 50000),\r\n                northingGridsArray[index].zoneNumber,\r\n                northingGridsArray[index].zoneLetter\r\n              );\r\n\r\n              let labelText = forward([labelCoordinateLl.lng, labelCoordinateLl.lat]).match(MGRS_REGEX)[HK_INDEX];\r\n              if (!(labelText === 'FM' && gzd === '32V')) {\r\n                drawLabel(\r\n                  ctx,\r\n                  labelText,\r\n                  this.options.fontColor,\r\n                  this.options.color,\r\n                  this.map.latLngToContainerPoint({\r\n                    lat: labelCoordinateLl.lat,\r\n                    lng: labelCoordinateLl.lng,\r\n                  })\r\n                );\r\n              }\r\n\r\n              if (elem.zoneLetter === 'N') {\r\n                this.handleEquatorLabels(ctx, northingGridsArray[index], northingGridsArray[index + 1]);\r\n              }\r\n            }\r\n            ctx.lineTo(COORDINATE_XY.x, COORDINATE_XY.y);\r\n          }\r\n        }\r\n      });\r\n      ctx.stroke();\r\n    });\r\n\r\n    this.eastingArray.forEach((eastingElem) => {\r\n      let eastingGridsArray = [];\r\n\r\n      this.northingArray.forEach((northingElem) => {\r\n        let intersection = this.processGridIntersection(MAP_BOUNDS, eastingElem, northingElem);\r\n        if (intersection) {\r\n          eastingGridsArray.push(intersection);\r\n        }\r\n      });\r\n      let shouldSkip = false; // Can't break out of a forEach loop using 'break'\r\n      eastingGridsArray.forEach((elem, index, array) => {\r\n        if (shouldSkip) {\r\n          return;\r\n        }\r\n\r\n        let COORDINATE_LL = utm.convertUtmToLatLng(elem.easting, elem.northing, elem.zoneNumber, elem.zoneLetter);\r\n\r\n        let COORDINATE_XY = this.map.latLngToContainerPoint({\r\n          lat: COORDINATE_LL.lat,\r\n          lng: COORDINATE_LL.lng,\r\n        });\r\n\r\n        let gzd = elem.zoneNumber.toString() + elem.zoneLetter;\r\n\r\n        const SW_GZD_POINT = getGZD(gzd)['geometry']['coordinates'][0][SW_INDEX];\r\n\r\n        // The first index in the array of northings\r\n        if (index === 0) {\r\n          ctx.beginPath();\r\n\r\n          // If the first northing coordinate is north of the south boundary of the GZD,\r\n          // we need to extend a line to touch the bottom of the GZD\r\n          if (COORDINATE_LL.lat > SW_GZD_POINT[LATITUDE_INDEX] && eastingGridsArray[index + 1]) {\r\n            const NEXT_COORDINATE_LL = utm.convertUtmToLatLng(\r\n              eastingGridsArray[index + 1].easting,\r\n              eastingGridsArray[index + 1].northing,\r\n              eastingGridsArray[index + 1].zoneNumber,\r\n              eastingGridsArray[index + 1].zoneLetter\r\n            );\r\n\r\n            let adjustedPoint = connectToGzdBoundary(COORDINATE_LL, NEXT_COORDINATE_LL, 'South');\r\n\r\n            COORDINATE_XY = this.map.latLngToContainerPoint({\r\n              lat: adjustedPoint.lat,\r\n              lng: adjustedPoint.lng,\r\n            });\r\n          }\r\n          ctx.moveTo(COORDINATE_XY.x, COORDINATE_XY.y);\r\n        } else {\r\n          // Get Lat/Long bounds for each GZD\r\n          const NE_GZD_POINT = getGZD(gzd)['geometry']['coordinates'][0][NE_INDEX];\r\n\r\n          const PREV_COORDINATE_LL = utm.convertUtmToLatLng(\r\n            eastingGridsArray[index - 1].easting,\r\n            eastingGridsArray[index - 1].northing,\r\n            eastingGridsArray[index - 1].zoneNumber,\r\n            eastingGridsArray[index - 1].zoneLetter\r\n          );\r\n\r\n          let slope = getLineSlope(COORDINATE_LL, PREV_COORDINATE_LL);\r\n          // If the point in the easting array is outside of its GZD, calculate the slope\r\n          // of the line with the previous point in the array and adjust the end point latitude\r\n          // as if it were resting right on the GZD boundary.\r\n          if (COORDINATE_LL.lng <= SW_GZD_POINT[LONGITUDE_INDEX]) {\r\n            COORDINATE_XY = this.getAdjustedXy(slope, SW_GZD_POINT[LONGITUDE_INDEX], PREV_COORDINATE_LL);\r\n            // If the value is outside of the GZD, then all subsequent ones will be too\r\n            // This means they do not need to be displayed.  You can't break out of a\r\n            // forEach loop, so using a boolean instead.\r\n            shouldSkip = true;\r\n          } else if (COORDINATE_LL.lng > NE_GZD_POINT[LONGITUDE_INDEX]) {\r\n            COORDINATE_XY = this.getAdjustedXy(slope, NE_GZD_POINT[LONGITUDE_INDEX], PREV_COORDINATE_LL);\r\n\r\n            shouldSkip = true;\r\n          }\r\n\r\n          ctx.lineTo(COORDINATE_XY.x, COORDINATE_XY.y);\r\n          // Connect to the GZD northern boundary\r\n          if (array.length - 1 === index && COORDINATE_LL.lat < NE_GZD_POINT[LATITUDE_INDEX]) {\r\n            let adjustedPoint = connectToGzdBoundary(COORDINATE_LL, PREV_COORDINATE_LL, 'North');\r\n            COORDINATE_XY = this.map.latLngToContainerPoint({\r\n              lat: adjustedPoint.lat,\r\n              lng: adjustedPoint.lng,\r\n            });\r\n\r\n            ctx.lineTo(COORDINATE_XY.x, COORDINATE_XY.y);\r\n          }\r\n        }\r\n      });\r\n      ctx.stroke();\r\n    });\r\n  }\r\n\r\n  // Small wrapper function to get the adjusted XY coordinates for when a HK point\r\n  // lies west/east of the GZD boundary\r\n  getAdjustedXy(slope, boundaryPoint, coordinateLl) {\r\n    let adjustedLatitude = getAdjustedLatitude(slope, boundaryPoint, coordinateLl);\r\n\r\n    let COORDINATE_XY = this.map.latLngToContainerPoint({\r\n      lat: adjustedLatitude,\r\n      lng: boundaryPoint,\r\n    });\r\n    return COORDINATE_XY;\r\n  }\r\n}\r\n\r\nexport { HundredKGraticule };\r\n","import { utmToLl, llToUtm, llToMgrs } from './Coordinates';\r\nimport { Bounds, latLng, Layer } from 'leaflet';\r\nimport { useMap } from 'react-leaflet';\r\nimport {\r\n  connectToGzdBoundary,\r\n  drawLabel,\r\n  getAdjustedLatitude,\r\n  getAdjustedLongitude,\r\n  getAllVisibleGzds,\r\n  getLineSlope,\r\n} from './CommonUtils';\r\nimport { getGZD } from 'gzd-utils';\r\n\r\n// The following indicies are used to indentify coordinates returned from gzd-utils\r\nconst SW_INDEX = 0;\r\nconst NW_INDEX = 1;\r\nconst NE_INDEX = 2;\r\n\r\nconst LATITUDE_INDEX = 1;\r\nconst LONGITUDE_INDEX = 0;\r\n\r\nconst MGRS_REGEX = /([0-9]+[A-Z])([A-Z]{2})(\\d+)/;\r\nconst GZD_INDEX = 1;\r\nconst HK_INDEX = 2;\r\nconst GRID_INDEX = 3;\r\n\r\nvar utmObj = require('utm-latlng');\r\nvar utm = new utmObj(); // Defaults to WGS-84\r\n\r\nconst OneKGraticule = (props) => {\r\n  let map = useMap();\r\n\r\n  const canvas = document.createElement('canvas');\r\n  canvas.classList.add('leaflet-zoom-animated');\r\n\r\n  let g = new Graticule({ map: map, canvas: canvas });\r\n  map.addLayer(g);\r\n\r\n  return null;\r\n};\r\nclass Graticule extends Layer {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    this.updateVariables = this.updateVariables.bind(this);\r\n\r\n    this.defaultOptions = {\r\n      showGrid: true,\r\n      showLabel: true,\r\n      opacity: 10,\r\n      weight: 1.5,\r\n      color: '#000',\r\n      hkColor: '#990000', //Font background colour and dash colour\r\n      hkDashArray: [4, 4],\r\n      font: '14px Courier New',\r\n      fontColor: '#FFF',\r\n      dashArray: [],\r\n      hundredKMinZoom: 6,\r\n      tenKMinZoom: 9,\r\n      oneKMinZoom: 12,\r\n      eastingBottom: true, // Display the eastings at the bottom the screen, else display at top\r\n      NorthingRight: true, // Display the northings at the right the screen, else display at left\r\n    };\r\n\r\n    this.options = (props && props.options) || this.defaultOptions;\r\n\r\n    this.map = props.map;\r\n    this.canvas = props.canvas;\r\n    this.currZoom = null;\r\n    this.mgrsGridInterval = null;\r\n  }\r\n\r\n  updateVariables(props) {\r\n    this.options = (props && props.options) || this.defaultOptions;\r\n  }\r\n\r\n  onAdd(map) {\r\n    map._panes.overlayPane.appendChild(this.canvas);\r\n    map.on('viewreset', this.reset, this);\r\n    map.on('move', this.reset, this);\r\n\r\n    this.reset();\r\n  }\r\n\r\n  onRemove(map) {\r\n    map._panes.overlayPane.removeChild(this.canvas);\r\n    map.off('viewreset', this.reset, this);\r\n    map.off('move', this.reset, this);\r\n\r\n    this.canvas = null;\r\n    this.map = null;\r\n  }\r\n\r\n  reset() {\r\n    const mapSize = this.map.getSize();\r\n    const mapLeftTop = this.map.containerPointToLayerPoint([0, 0]);\r\n\r\n    this.canvas.style['transform'] = `translate3d(${mapLeftTop.x}px,${mapLeftTop.y}px,0)`;\r\n\r\n    this.canvas.width = mapSize.x;\r\n    this.canvas.height = mapSize.y;\r\n\r\n    if (this.map.getZoom() > this.options.oneKMinZoom) {\r\n      this.mgrsGridInterval = 1000; //1k resolution\r\n    } else if (this.map.getZoom() > this.options.tenKMinZoom) {\r\n      this.mgrsGridInterval = 10000; //10k resolution\r\n    } else if (this.map.getZoom() > this.options.hundredKMinZoom) {\r\n      this.mgrsGridInterval = 100000; //100k resolution\r\n    } else {\r\n      this.mgrsGridInterval = null;\r\n    }\r\n\r\n    this.drawGrid();\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {String} element - A UTM easting or northing element\r\n   */\r\n  _getLabelText(element) {\r\n    // Divide by 1000 so that the labels will always be correct (10k vs 1k resolution)\r\n    let label = ((element % 100000) / 1000).toString();\r\n\r\n    if (this.mgrsGridInterval === 10000 && label === '0') {\r\n      label = '00';\r\n    }\r\n\r\n    return label;\r\n  }\r\n\r\n  _drawLine(ctx, notHkLine) {\r\n    if (notHkLine) {\r\n      ctx.setLineDash(this.options.dashArray);\r\n      ctx.lineWidth = this.options.weight + 1;\r\n      ctx.strokeStyle = this.options.fontColor;\r\n      ctx.stroke();\r\n      ctx.lineWidth = this.options.weight;\r\n      ctx.strokeStyle = this.options.color;\r\n      ctx.stroke();\r\n    } else {\r\n      ctx.lineWidth = this.options.weight;\r\n      ctx.strokeStyle = this.options.hkColor;\r\n      ctx.setLineDash(this.options.hkDashArray);\r\n      ctx.stroke();\r\n    }\r\n  }\r\n\r\n  getVizGrids() {\r\n    const nwBoundMgrs = llToMgrs(\r\n      [this.map.getBounds().getNorthWest()['lng'], this.map.getBounds().getNorthWest()['lat']],\r\n      1\r\n    );\r\n    const neBoundMgrs = llToMgrs(\r\n      [this.map.getBounds().getNorthEast()['lng'], this.map.getBounds().getNorthEast()['lat']],\r\n      1\r\n    );\r\n    const seBoundMgrs = llToMgrs(\r\n      [this.map.getBounds().getSouthEast()['lng'], this.map.getBounds().getSouthEast()['lat']],\r\n      1\r\n    );\r\n    const swBoundMgrs = llToMgrs(\r\n      [this.map.getBounds().getSouthWest()['lng'], this.map.getBounds().getSouthWest()['lat']],\r\n      1\r\n    );\r\n\r\n    let visibleGrids = getAllVisibleGzds(\r\n      nwBoundMgrs.match(MGRS_REGEX)[GZD_INDEX],\r\n      neBoundMgrs.match(MGRS_REGEX)[GZD_INDEX],\r\n      seBoundMgrs.match(MGRS_REGEX)[GZD_INDEX],\r\n      swBoundMgrs.match(MGRS_REGEX)[GZD_INDEX]\r\n    );\r\n\r\n    return visibleGrids;\r\n  }\r\n\r\n  drawGrid() {\r\n    if (!this.canvas || !this.map) {\r\n      return;\r\n    }\r\n\r\n    if (this.map.getZoom() < this.options.hundredKMinZoom) {\r\n      return;\r\n    }\r\n\r\n    let ctx = this.canvas.getContext('2d');\r\n    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n    ctx.lineWidth = this.options.weight + 0.75;\r\n    ctx.strokeStyle = '#FFF';\r\n    ctx.fillStyle = this.options.color;\r\n    ctx.setLineDash(this.options.dashArray);\r\n    ctx.font = this.options.font;\r\n    const visibleGzds = this.getVizGrids();\r\n\r\n    const mapBounds = this.map.getBounds();\r\n\r\n    visibleGzds.forEach((gzd, gzdIndex, visibleGridArr) => {\r\n      // TODO - New LLtoUTM will give GZD long bands that are not valid (<1 and >60)\r\n      const gzdObject = getGZD(gzd);\r\n\r\n      const gzdWestBoundary = gzdObject['geometry']['coordinates'][0][NW_INDEX][LONGITUDE_INDEX];\r\n      const gzdEastBoundary = gzdObject['geometry']['coordinates'][0][NE_INDEX][LONGITUDE_INDEX];\r\n      const gzdNorthBoundary = gzdObject['geometry']['coordinates'][0][NW_INDEX][LATITUDE_INDEX];\r\n      const gzdSouthBoundary = gzdObject['geometry']['coordinates'][0][SW_INDEX][LATITUDE_INDEX];\r\n\r\n      // If drawing HK grids, just draw the entire GZD regardless\r\n      let effectiveWestBoundary =\r\n        gzdWestBoundary < mapBounds.getWest() && this.mgrsGridInterval !== 100000\r\n          ? mapBounds.getWest()\r\n          : gzdWestBoundary;\r\n      let effectiveEastBoundary =\r\n        gzdEastBoundary > mapBounds.getEast() && this.mgrsGridInterval !== 100000\r\n          ? mapBounds.getEast()\r\n          : gzdEastBoundary;\r\n      let effectiveNorthBoundary = gzdNorthBoundary > mapBounds.getNorth() ? mapBounds.getNorth() : gzdNorthBoundary;\r\n      let effectiveSouthBoundary = gzdSouthBoundary < mapBounds.getSouth() ? mapBounds.getSouth() : gzdSouthBoundary;\r\n\r\n      const effectiveBounds = L.latLngBounds(\r\n        L.latLng(effectiveNorthBoundary, effectiveWestBoundary),\r\n        L.latLng(effectiveSouthBoundary, effectiveEastBoundary)\r\n      );\r\n\r\n      // Buffer is used to ensure that if we're right on the GZD boundary that we don't get the adjacent GZD\r\n      const buffer = 0.00001;\r\n      const swCornerUtm = llToUtm(effectiveSouthBoundary + buffer, effectiveWestBoundary + buffer);\r\n      const seCornerUtm = llToUtm(effectiveSouthBoundary + buffer, effectiveEastBoundary - buffer);\r\n      const nwCornerUtm = llToUtm(effectiveNorthBoundary - buffer, effectiveWestBoundary + buffer);\r\n      const neCornerUtm = llToUtm(effectiveNorthBoundary - buffer, effectiveEastBoundary - buffer);\r\n\r\n      let startingEasting = this.map.getCenter().lat >= 0 ? swCornerUtm.easting : nwCornerUtm.easting;\r\n      let finalEasting = this.map.getCenter().lat >= 0 ? seCornerUtm.easting : neCornerUtm.easting;\r\n\r\n      let startingNorthing = swCornerUtm.northing;\r\n      let finalNorthing = neCornerUtm.northing;\r\n\r\n      startingEasting = Math.floor(startingEasting / this.mgrsGridInterval) * this.mgrsGridInterval;\r\n      finalEasting = Math.ceil(finalEasting / this.mgrsGridInterval) * this.mgrsGridInterval;\r\n      startingNorthing = Math.floor(startingNorthing / this.mgrsGridInterval) * this.mgrsGridInterval;\r\n      finalNorthing = Math.ceil(finalNorthing / this.mgrsGridInterval) * this.mgrsGridInterval;\r\n\r\n      let eastingArray = [];\r\n      for (let i = startingEasting; i <= finalEasting; i += this.mgrsGridInterval) {\r\n        eastingArray.push(i);\r\n      }\r\n\r\n      let northingArray = [];\r\n      for (let i = startingNorthing; i <= finalNorthing; i += this.mgrsGridInterval) {\r\n        northingArray.push(i);\r\n      }\r\n\r\n      let zoneLetter = nwCornerUtm.zoneLetter;\r\n      let zoneNumber = nwCornerUtm.zoneNumber;\r\n\r\n      // Lines of constant Eastings\r\n\r\n      eastingArray.forEach((eastingElem, eastingIndex, eastArr) => {\r\n        northingArray.forEach((northingElem, northingIndex, northArr) => {\r\n          let gridIntersectionLl = utmToLl(eastingElem, northingElem, zoneNumber, zoneLetter);\r\n\r\n          // The grid array is larger than the GZD.  As such the first and last elements of the easting/northing\r\n          // arrays will be outside of the GZD.  These points are required because they are used to derive the\r\n          // point of intersection with the GZD boundary.\r\n          if (gridIntersectionLl.lng > gzdEastBoundary) {\r\n            return;\r\n          } else if (gridIntersectionLl.lng < gzdWestBoundary) {\r\n            return;\r\n          }\r\n          // This block will truncate the line at the southern boundary of the GZD\r\n          if (gridIntersectionLl.lat <= gzdSouthBoundary) {\r\n            let nextIntersectionLl = utmToLl(eastingElem, northArr[northingIndex + 1], zoneNumber, zoneLetter);\r\n            gridIntersectionLl = connectToGzdBoundary(gridIntersectionLl, nextIntersectionLl, 'North');\r\n            // This block will truncate the line at the northern boundary of the GZD\r\n          } else if (gridIntersectionLl.lat > gzdNorthBoundary) {\r\n            let previousIntersectionLl = utmToLl(eastingElem, northArr[northingIndex - 1], zoneNumber, zoneLetter);\r\n\r\n            gridIntersectionLl = connectToGzdBoundary(gridIntersectionLl, previousIntersectionLl, 'South');\r\n          }\r\n          let gridIntersectionXy;\r\n          if (gridIntersectionLl.lat && gridIntersectionLl.lng) {\r\n            gridIntersectionXy = this.map.latLngToContainerPoint(gridIntersectionLl);\r\n          } else {\r\n            return;\r\n          }\r\n\r\n          if (northingIndex === 0) {\r\n            ctx.beginPath();\r\n            ctx.moveTo(gridIntersectionXy.x, gridIntersectionXy.y);\r\n          } else {\r\n            ctx.lineTo(gridIntersectionXy.x, gridIntersectionXy.y);\r\n          }\r\n        });\r\n        const notHkLine = eastingElem % 100000 !== 0;\r\n        this._drawLine(ctx, notHkLine);\r\n        // HACK - Begin path doesn't appear to get called in edge cases in the following loop\r\n        ctx.beginPath();\r\n      });\r\n\r\n      // Lines of constant Northings\r\n      northingArray.forEach((northingElem, northingIndex, northArr) => {\r\n        eastingArray.forEach((eastingElem, eastingIndex, eastArr) => {\r\n          let gridIntersectionLl = utmToLl(eastingElem, northingElem, zoneNumber, zoneLetter);\r\n\r\n          // The grid array is larger than the GZD.  As such the first and last elements of the easting/northing\r\n          // arrays will be outside of the GZD.  These points are required because they are used to derive the\r\n          // point of intersection with the GZD boundary.\r\n          if (gridIntersectionLl.lat > gzdNorthBoundary || gridIntersectionLl.lat < gzdSouthBoundary) {\r\n            return;\r\n          }\r\n          let gridIntersectionXy = this.map.latLngToContainerPoint(gridIntersectionLl);\r\n          if (eastingIndex === 0) {\r\n            ctx.beginPath();\r\n            // Truncate the line to the effective western boundary\r\n            if (gridIntersectionLl.lng < effectiveWestBoundary) {\r\n              const nextGridIntersectionLl = utmToLl(eastArr[eastingIndex + 1], northingElem, zoneNumber, zoneLetter);\r\n              const slope = getLineSlope(gridIntersectionLl, nextGridIntersectionLl);\r\n\r\n              try {\r\n                gridIntersectionLl.lat = getAdjustedLatitude(slope, effectiveWestBoundary, gridIntersectionLl);\r\n\r\n                gridIntersectionLl.lng = effectiveWestBoundary;\r\n\r\n                gridIntersectionXy = this.map.latLngToContainerPoint(gridIntersectionLl);\r\n              } catch (e) {\r\n                console.error(e);\r\n                console.trace();\r\n              }\r\n            }\r\n\r\n            ctx.moveTo(gridIntersectionXy.x, gridIntersectionXy.y);\r\n          } else {\r\n            // Truncate the line to the effective eastern boundary\r\n            if (gridIntersectionLl.lng > effectiveEastBoundary) {\r\n              const previousGridIntersectionLl = utmToLl(\r\n                eastArr[eastingIndex - 1],\r\n                northingElem,\r\n                zoneNumber,\r\n                zoneLetter\r\n              );\r\n              const slope = getLineSlope(gridIntersectionLl, previousGridIntersectionLl);\r\n\r\n              try {\r\n                gridIntersectionLl.lat = getAdjustedLatitude(slope, effectiveEastBoundary, gridIntersectionLl);\r\n\r\n                gridIntersectionLl.lng = effectiveEastBoundary;\r\n\r\n                gridIntersectionXy = this.map.latLngToContainerPoint(gridIntersectionLl);\r\n              } catch (e) {\r\n                console.error(e);\r\n                console.trace();\r\n              }\r\n            }\r\n            ctx.lineTo(gridIntersectionXy.x, gridIntersectionXy.y);\r\n          }\r\n        });\r\n\r\n        const notHkLine = northingElem % 100000 !== 0;\r\n        this._drawLine(ctx, notHkLine);\r\n      });\r\n\r\n      let skipRemainder = false;\r\n      // Draw the labels\r\n      if (this.mgrsGridInterval === 100000) {\r\n        eastingArray.forEach((eastingElem, eastingIndex, ea) => {\r\n          if (skipRemainder) {\r\n            return;\r\n          }\r\n          northingArray.forEach((northingElem, northingIndex, na) => {\r\n            let labelLl;\r\n            let currentLl = utmToLl(eastingElem, northingElem, zoneNumber, zoneLetter);\r\n            let adjacentLlNorthing;\r\n            let adjacentLlEasting;\r\n\r\n            if (eastingIndex !== ea.length - 1) {\r\n              adjacentLlEasting = utmToLl(ea[eastingIndex + 1], northingElem, zoneNumber, zoneLetter);\r\n              if (adjacentLlEasting.lng > effectiveEastBoundary) {\r\n                const slope = getLineSlope(currentLl, adjacentLlEasting);\r\n                adjacentLlEasting.lat = getAdjustedLatitude(slope, effectiveEastBoundary, adjacentLlEasting);\r\n                adjacentLlEasting.lng = effectiveEastBoundary;\r\n                skipRemainder = true;\r\n              }\r\n            } else {\r\n              adjacentLlEasting = utmToLl(ea[eastingIndex - 1], northingElem, zoneNumber, zoneLetter);\r\n            }\r\n\r\n            if (northingIndex !== na.length - 1) {\r\n              adjacentLlNorthing = utmToLl(eastingElem, na[northingIndex + 1], zoneNumber, zoneLetter);\r\n            } else {\r\n              adjacentLlNorthing = utmToLl(eastingElem, na[northingIndex - 1], zoneNumber, zoneLetter);\r\n            }\r\n\r\n            if (currentLl.lng < effectiveWestBoundary) {\r\n              const slope = getLineSlope(currentLl, adjacentLlEasting);\r\n              currentLl.lat = getAdjustedLatitude(slope, effectiveWestBoundary, currentLl);\r\n              currentLl.lng = effectiveWestBoundary;\r\n            } else if (currentLl.lng > effectiveEastBoundary) {\r\n              const slope = getLineSlope(currentLl, adjacentLlEasting);\r\n              currentLl.lat = getAdjustedLatitude(slope, effectiveEastBoundary, currentLl);\r\n              currentLl.lng = effectiveEastBoundary;\r\n            }\r\n\r\n            if (L.latLng(currentLl).distanceTo(adjacentLlEasting) < 10000) {\r\n              return;\r\n            }\r\n\r\n            labelLl = {\r\n              lat: (currentLl.lat + adjacentLlNorthing.lat) / 2,\r\n              lng: (currentLl.lng + adjacentLlEasting.lng) / 2,\r\n            };\r\n\r\n            try {\r\n              if (labelLl && effectiveBounds.contains(labelLl)) {\r\n                let labelText = llToMgrs([labelLl.lng, labelLl.lat]).match(MGRS_REGEX)[HK_INDEX];\r\n\r\n                drawLabel(\r\n                  ctx,\r\n                  labelText,\r\n                  this.options.fontColor,\r\n                  this.options.hkColor,\r\n                  this.map.latLngToContainerPoint(labelLl)\r\n                );\r\n              }\r\n            } catch (e) {\r\n              return;\r\n            }\r\n          });\r\n        });\r\n      } else {\r\n        eastingArray.forEach((eastingElem, eastingIndex, ea) => {\r\n          if (!(eastingIndex === 0 || eastingIndex === ea.length - 1)) {\r\n            let labelXy;\r\n            try {\r\n              let labelLl = utmToLl(eastingElem, northingArray[1], zoneNumber, zoneLetter);\r\n\r\n              labelXy = this.map.latLngToContainerPoint({ lat: effectiveSouthBoundary, lng: labelLl.lng });\r\n            } catch (e) {\r\n              return;\r\n            }\r\n\r\n            let labelText = this._getLabelText(eastingElem);\r\n\r\n            drawLabel(ctx, labelText, this.options.fontColor, this.options.color, { x: labelXy.x, y: labelXy.y - 15 });\r\n          }\r\n        });\r\n\r\n        northingArray.forEach((northingElem, northingIndex, na) => {\r\n          let labelXy;\r\n          try {\r\n            let labelLl = utmToLl(eastingArray[eastingArray.length - 1], northingElem, zoneNumber, zoneLetter);\r\n\r\n            labelXy = this.map.latLngToContainerPoint({ lat: labelLl.lat, lng: effectiveEastBoundary });\r\n          } catch (e) {\r\n            return;\r\n          }\r\n\r\n          let labelText = this._getLabelText(northingElem);\r\n\r\n          drawLabel(ctx, labelText, this.options.fontColor, this.options.color, { x: labelXy.x - 15, y: labelXy.y });\r\n        });\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexport { OneKGraticule };\r\n","import React from 'react';\r\nimport { MapContainer, TileLayer } from 'react-leaflet';\r\nimport { GzdGraticule, OneKGraticule } from 'react-leaflet-mgrs-graticule';\r\nimport './App.css';\r\n\r\nfunction App() {\r\n  return (\r\n    <MapContainer\r\n      center={[45.4, -75.7]}\r\n      zoom={7}\r\n      minZoom={3}\r\n      maxZoom={16}\r\n      maxNativeZoom={15}\r\n      maxBounds={[\r\n        [-90, -180],\r\n        [90, 180],\r\n      ]}\r\n    >\r\n      <TileLayer\r\n        // url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\r\n        // attribution='&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\r\n        // ESRI Clarity Sat\r\n        // url=\"https://clarity.maptiles.arcgis.com/arcgis/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\"\r\n        // ESRI Sat\r\n        url=\"https://services.arcgisonline.com/arcgis/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\"\r\n        attribution='&copy; <a href=\"https://wiki.openstreetmap.org/wiki/Esri\"></a> contributors'\r\n      />\r\n      <OneKGraticule />\r\n      {/* <HundredKGraticule /> */}\r\n      <GzdGraticule />\r\n    </MapContainer>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}