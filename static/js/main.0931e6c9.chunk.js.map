{"version":3,"sources":["../../src/CommonUtils.js","../../src/GzdGraticule.js","../../src/HundredKGraticule.js","../../src/OneKGraticule.js","App.js","index.js"],"names":["TEN_K_MGRS_REGEX","getLineSlope","pointOne","pointTwo","lng","NaN","lat","getAdjustedLatitude","slope","adjustedLongitude","unadjustedLatLong","isNaN","getAdjustedLongitude","adjustedLatitude","Error","getNextMgrsGzdCharacter","char","result","String","fromCharCode","charCodeAt","latLngToCanvasPoint","map","latLng","projectedPoint","project","_subtract","getPixelOrigin","_add","_getMapPanePos","connectToGzdBoundary","direction","grid","forward","gzdEastLongitude","getGZD","match","geometry","coordinates","gzdWestLongitude","gzdNorthLatitude","gzdSouthLatitude","getAllVisibleGzds","nwGzd","neGzd","seGzd","swGzd","GZD_REGEX","NW_LONGITUDE_BAND","parseInt","NW_LATITUDE_BAND","NE_LONGITUDE_BAND","SW_LATITUDE_BAND","longitudeBands","push","i","toString","INITIAL_LONGITUDE_BAND","currentLatitudeBand","len","length","flat","longitudeBand","filter","a","includes","drawLabel","ctx","labelText","textColor","backgroundColor","labelPosition","TEXT_WIDTH","measureText","width","TEXT_HEIGHT","fontBoundingBoxAscent","LABEL_X","x","LABEL_Y","y","fillStyle","fillRect","fillText","MGRS_REGEX","GzdGraticule","props","useMap","canvas","document","createElement","classList","add","g","Graticule","addLayer","currLatInterval","currLngInterval","defaultOptions","showGrid","showLabel","opacity","weight","color","font","fontColor","dashArray","minZoom","options","_panes","overlayPane","appendChild","this","on","reset","removeChild","off","MAP_SIZE","getSize","MAP_LEFT_TOP","containerPointToLayerPoint","_leaflet_pos","style","height","drawGzd","getZoom","getContext","clearRect","lineWidth","strokeStyle","setLineDash","leftTop","containerPointToLatLng","rightBottom","pointPerLat","pointPerLon","drawLatitudeLine","drawLongitudeLine","tick","lngLeft","lngRight","LEFT_END","RIGHT_END","beginPath","moveTo","lineTo","stroke","latTop","latBottom","CANVAS_TOP","CANVAS_BOTTOM","TOP_OF_W_SERIES_GZD","TOP_OF_V_SERIES_GZD","BOTTOM_OF_V_SERIES_GZD","RIGHT_TOP_OF_GZD","LEFT_TOP_OF_GZD","LEFT_BOTTOM_OF_GZD","RIGHT_BOTTOM_OF_GZD","TOP_LEFT_OF_32_SERIES_GZD","TOP_LEFT_OF_33X_GZD","BOTTOM_LEFT_OF_33X_GZD","TOP_RIGHT_OF_32W_GZD","TOP_LEFT_OF_34_SERIES_GZD","TOP_LEFT_OF_35X_GZD","BOTTOM_LEFT_OF_35X_GZD","TOP_RIGHT_OF_34W_GZD","TOP_LEFT_OF_35_SERIES_GZD","TOP_LEFT_OF_37X_GZD","BOTTOM_LEFT_OF_37X_GZD","TOP_RIGHT_OF_36W_GZD","drawGzdLabels","longitude","labelLatitude","labelLongitude","gzdLabel","error","LABEL_XY","Layer","utm","require","HundredKGraticule","updateVariables","bind","eastingArray","northingArray","maxZoom","HUNDRED_K_GRID_INTERVAL","MAP_TOP_LEFT","ZOOM","visibleGrids","getVizGrids","generateGrids","NW_BOUND_MGRS","getBounds","getNorthWest","NE_BOUND_MGRS","getNorthEast","SE_BOUND_MGRS","getSouthEast","SW_BOUND_MGRS","getSouthWest","currentZoom","adjustedLl","coordinateLl","elemUtm","ZONE_BOUNDARIES","WEST_GZD_LONGITUDE","EAST_GZD_LONGITUDE","TEMP_POINT_LL","convertUtmToLatLng","easting","northing","zoneNumber","zoneLetter","SLOPE","ADJUSTED_EAST_LATITUDE","EAST_GZD_BOUNDARY_POINT","ADJUSTED_WEST_LATITUDE","WEST_GZD_BOUNDARY_POINT","handle31VLabels","startingNorthingUtm","startingEastingUtm","finalNorthingUtm","finalEastingUtm","northingIterator","Northing","eastingIterator","Easting","Math","ceil","ZoneNumber","ZoneLetter","mapBounds","eastingElem","northingElem","GRID_INTERSECTION","contains","firstIntersection","secondIntersection","labelCoordinateLl","floor","visibleGzds","forEach","gzd","zoneBoundaries","SW_CORNER_LL","NW_CORNER_LL","NE_CORNER_LL","SE_CORNER_LL","BUFFER","SW_CORNER_UTM","convertLatLngToUtm","NW_CORNER_UTM","NE_CORNER_UTM","SE_CORNER_UTM","getCenter","processEastingsAndNorthings","MAP_BOUNDS","pad","getPaddingOnZoomLevel","northingGridsArray","intersection","processGridIntersection","elem","index","array","COORDINATE_LL","COORDINATE_XY","handle31V","NEXT_COORDINATE_LL","additionalPoint","cachedCoordinateXy","labelWidth","abs","handleEquatorLabels","PREV_COORDINATE_LL","eastingGridsArray","shouldSkip","SW_GZD_POINT","adjustedPoint","NE_GZD_POINT","getAdjustedXy","boundaryPoint","OneKGraticule","hkColor","hkDashArray","tenKMinZoom","oneKMinZoom","eastingBottom","NorthingRight","currZoom","mgrsGridInterval","drawGrid","element","label","hkLine","VISIBLE_GZDS","gzdIndex","visibleGridArr","GZD_OBJECT","GZD_WEST_BOUNDARY","GZD_EAST_BOUNDARY","GZD_NORTH_BOUNDARY","GZD_SOUTH_BOUNDARY","effectiveWestGzdBoundary","getWest","effectiveEastGzdBoundary","getEast","effectiveWNorthGzdBoundary","getNorth","effectiveSouthGzdBoundary","getSouth","startingEasting","finalEasting","startingNorthing","finalNorthing","eastingIndex","eastArr","northingIndex","northArr","gridIntersectionLl","gridIntersectionXy","IS_HK_LINE","_drawLine","gridLabelLl","gridLabelXy","_getLabelText","e","nextIntersectionLl","gzdIntersectionLl","App","MapContainer","center","zoom","maxNativeZoom","maxBounds","TileLayer","url","attribution","ReactDOM","render","StrictMode","getElementById"],"mappings":"0UAWMA,EAAmB,oCAOzB,SAASC,EAAaC,EAAUC,GAC9B,OAAID,IAAaC,EACR,EACED,EAASE,MAAQD,EAASC,IAC5BC,KAECF,EAASG,IAAMJ,EAASI,MAAQH,EAASC,IAAMF,EAASE,KAUpE,SAASG,EAAoBC,EAAOC,EAAmBC,GAUrD,OARKC,MAAMH,GAKAE,EAAkBJ,IAHzBI,EAAkBJ,IAClBE,GAASC,EAAoBC,EAAkBN,KAcrD,SAASQ,EAAqBJ,EAAOK,EAAkBH,GAErD,GAAc,IAAVF,EAEF,MADU,IAAIM,MAAM,6CAYtB,OAVYH,MAAMH,GAOPE,EAAkBN,KALxBS,EACCH,EAAkBJ,IAClBE,EAAQE,EAAkBN,KAC5BI,EAWN,SAASO,EAAwBC,GAG/B,IAAMC,EAASC,OAAOC,aAAaH,EAAKI,WAAW,GAAK,GACxD,MAAe,MAAXH,GAA6B,MAAXA,EACbF,EAAwBE,GAExBA,EASX,SAASI,EAAoBC,EAAKC,GAChC,IAAMC,EAAiBF,EAAIG,QAAQF,GAGnC,OAFAC,EAAeE,UAAUJ,EAAIK,kBAC7BH,EAAeI,KAAKN,EAAIO,kBACjBL,EAUT,SAASM,EAAqB5B,EAAUC,EAAU4B,GAChD,IAGItB,EACAI,EAJEL,EAAQP,EAAaC,EAAUC,GAE/B6B,EAAOC,YAAQ,CAAC/B,EAASE,IAAKF,EAASI,KAAM,GAInD,OAAQyB,GACN,IAAK,OACH,IAAMG,EAAmBC,iBAAOH,EAAKI,MAAMpC,GArG/B,IAsGTqC,SAASC,YAAY,GA5Gb,GAEO,GA+GlB,MAAO,CAAEhC,IAHTO,EAAmBN,EAAoBC,EAAO0B,EAAkB/B,GAGhCC,IAFhCK,EAAoByB,GAItB,IAAK,OACH,IAAMK,EAAmBJ,iBAAOH,EAAKI,MAAMpC,GA9G/B,IA+GTqC,SAASC,YAAY,GAtHb,GAGO,GAwHlB,MAAO,CAAEhC,IAHTO,EAAmBN,EAAoBC,EAAO+B,EAAkBpC,GAGhCC,IADhCK,EAAoB8B,GAEtB,IAAK,QACH,IAAMC,EAAmBL,iBAAOH,EAAKI,MAAMpC,GAtH/B,IAuHTqC,SAASC,YAAY,GA9Hb,GAIM,GA4HjB7B,EAAoBG,EAClBJ,EACAgC,EACArC,GAqBF,MAd8C,QAA5C6B,EAAKI,MAAMpC,GAnID,IAoIVS,EAH4B,GAI5BN,EAASC,IAJmB,GAM5BS,EAAmBN,EACjBC,EAP0B,EAS1BL,GAEFM,EAX4B,GAa5BI,EAAmB2B,EAGd,CAAElC,IAAKO,EAAkBT,IAAKK,GAEvC,IAAK,QACH,IAAMgC,EAAmBN,iBAAOH,EAAKI,MAAMpC,GApJ/B,IAqJTqC,SAASC,YAAY,GA7Jb,GAKM,GAiKjB,MAAO,CAAEhC,IADTO,EAAmB4B,EACarC,IAPhCK,EAAoBG,EAClBJ,EACAiC,EACAtC,IAMJ,QAEE,MAAO,CAAEG,IAAKO,EAAkBT,IAAKK,IAK3C,SAASiC,EAAkBC,EAAOC,EAAOC,EAAOC,GAC9C,IAAMC,EAAY,kBAKlB,GAAIJ,IAAUE,EACZ,MAAO,CAACF,GAEV,IAAMK,EAAoBC,SACxBN,EAAMP,MAAMW,GARe,IAUvBG,EAAmBP,EAAMP,MAAMW,GATT,GAWtBI,EAAoBF,SACxBL,EAAMR,MAAMW,GAbe,IAgBvBK,EAAmBN,EAAMV,MAAMW,GAfT,GAiBxB9B,EAAS,GAEPoC,EAAiB,GASvB,GALc,QAAVV,GACFU,EAAeC,KAAK,MAIlBN,IAAsBG,EAAmB,CAC3C,IAAK,IAAII,EAAIP,EAAmBO,GAAKJ,EAAmBI,IACtDF,EAAeC,KAAKC,EAAEC,YAExB,GAAIN,IAAqBE,EAAkB,CAIzC,IAHA,IAAMK,EAAyB,GAAH,OAAOJ,GAE/BK,EAAsBN,EACnBM,GAAuBR,GAAkB,CAG9C,IAFA,IAAMS,EAAMF,EAAuBG,OAE1BL,EAAI,EAAGA,EAAII,EAAKJ,IACvBtC,EAAOqC,KAAKG,EAAuBF,GAAKG,GAG1CA,EAAsB3C,EAAwB2C,GAGhDzC,EAASA,EAAO4C,WACX,CAGL,IADA,IAAMF,EAAMN,EAAeO,OAClBL,EAAI,EAAGA,EAAII,EAAKJ,IACvBF,EAAeE,GAAKF,EAAeE,GAAGC,WAAaN,EAErDjC,EAASoC,OAEN,CAKL,IAHA,IAAIK,EAAsBN,EACpBU,EAAgB,GAEfJ,GAAuBR,GAC5BY,EAAcR,KAAKN,EAAkBQ,WAAaE,GAElDA,EAAsB3C,EAAwB2C,GAEhDzC,EAAS6C,EAmBX,OAhBA7C,EAASA,EAAO8C,QAAO,SAAUC,GAC/B,MAAa,QAANA,GAAqB,QAANA,GAAqB,QAANA,MAK5BC,SAAS,SAAWhD,EAAOgD,SAAS,QAC7ChD,EAAOqC,KAAK,OAKA,QAAVV,GAA6B,QAAVC,GAAoB5B,EAAOgD,SAAS,QACzDhD,EAAOqC,KAAK,OAGPrC,EAGT,SAASiD,EAAUC,EAAKC,EAAWC,EAAWC,EAAiBC,GAC7D,IAAMC,EAAaL,EAAIM,YAAYL,GAAWM,MACxCC,EAAcR,EAAIM,YAAYL,GAAWQ,sBAGzCC,EAAUN,EAAcO,EACxBC,EAAUR,EAAcS,EAE9Bb,EAAIc,UAAYX,EAEhBH,EAAIe,SACFL,EAAUL,EAAa,EAAI,EAC3BO,EAAUJ,EAAc,EACxBH,EAAa,EACbG,EAAc,GAEhBR,EAAIc,UAAYZ,EAChBF,EAAIgB,SAASf,EAAWS,EAAUL,EAAa,EAAGO,GCzRpD,IAAMK,EAAa,+BAGbC,EAAe,SAACC,GACpB,IAAIhE,EAAMiE,cAEJC,EAASC,SAASC,cAAc,UACtCF,EAAOG,UAAUC,IAAI,yBAErB,IAAIC,EAAI,IAAIC,EAAU,CAAExE,IAAKA,EAAKkE,OAAQA,IAG1C,OAFAlE,EAAIyE,SAASF,GAEN,MAGHC,E,kDACJ,WAAYR,GAAO,kCACjB,cAAMA,IACDU,gBAAkB,EACvB,EAAKC,gBAAkB,EAEvB,EAAKC,eAAiB,CACpBC,UAAU,EACVC,WAAW,EACXC,QAAS,GACTC,OAAQ,EACRC,MAAO,UACPC,KAAM,mBACNC,UAAW,OACXC,UAAW,CAAC,EAAG,GACfC,QAAS,GAGX,EAAKrF,IAAMgE,EAAMhE,IACjB,EAAKkE,OAASF,EAAME,OAEpB,EAAKoB,QAAWtB,GAASA,EAAMsB,SAAY,EAAKV,eApB/B,E,yCAuBnB,SAAM5E,GACJA,EAAIuF,OAAOC,YAAYC,YAAYC,KAAKxB,QACxClE,EAAI2F,GAAG,YAAaD,KAAKE,MAAOF,MAChC1F,EAAI2F,GAAG,OAAQD,KAAKE,MAAOF,MAE3BA,KAAKE,U,sBAGP,SAAS5F,GACPA,EAAIuF,OAAOC,YAAYK,YAAYH,KAAKxB,QACxClE,EAAI8F,IAAI,YAAaJ,KAAKE,MAAOF,MACjC1F,EAAI8F,IAAI,OAAQJ,KAAKE,MAAOF,MAE5BA,KAAKxB,OAAS,KACdwB,KAAK1F,IAAM,O,mBAGb,WACE,IAAM+F,EAAWL,KAAK1F,IAAIgG,UACpBC,EAAeP,KAAK1F,IAAIkG,2BAA2B,CAAC,EAAG,IAE7DR,KAAKxB,OAAOiC,aAAeF,EAE3BP,KAAKxB,OAAOkC,MAAZ,gCAEmBH,EAAazC,EAFhC,cAEuCyC,EAAavC,EAFpD,SAIAgC,KAAKxB,OAAOd,MAAQ2C,EAASvC,EAC7BkC,KAAKxB,OAAOmC,OAASN,EAASrC,EAE9BgC,KAAKY,Y,qBAGP,WACE,GAAKZ,KAAKxB,QAAWwB,KAAK1F,OAItB0F,KAAK1F,IAAIuG,UAAYb,KAAKJ,QAAQD,SAAtC,CAIA,IAAIxC,EAAM6C,KAAKxB,OAAOsC,WAAW,MACjC3D,EAAI4D,UAAU,EAAG,EAAGf,KAAKxB,OAAOd,MAAOsC,KAAKxB,OAAOmC,QACnDxD,EAAI6D,UAAYhB,KAAKJ,QAAQN,OAC7BnC,EAAI8D,YAAcjB,KAAKJ,QAAQL,MAC/BpC,EAAIc,UAAY+B,KAAKJ,QAAQL,MAC7BpC,EAAI+D,YAAYlB,KAAKJ,QAAQF,WACzBM,KAAKJ,QAAQJ,OACfrC,EAAIqC,KAAOQ,KAAKJ,QAAQJ,MAG1B,IAAI2B,EAAUnB,KAAK1F,IAAI8G,uBAAuB,CAAEtD,EAAG,EAAGE,EAAG,IACrDqD,EAAcrB,KAAK1F,IAAI8G,uBAAuB,CAChDtD,EAAGkC,KAAKxB,OAAOd,MACfM,EAAGgC,KAAKxB,OAAOmC,SAGbW,GACDH,EAAQ7H,IAAM+H,EAAY/H,MAA6B,GAArB0G,KAAKxB,OAAOmC,QAC7CY,GACDF,EAAYjI,IAAM+H,EAAQ/H,MAA4B,GAApB4G,KAAKxB,OAAOd,OAEjD,IAAI/D,MAAM2H,KAAgB3H,MAAM4H,GAAhC,CAIID,EAAc,IAChBA,EAAc,GAEZC,EAAc,IAChBA,EAAc,GAGZF,EAAY/H,KAAO,GACrB+H,EAAY/H,KAAO,GAEnB+H,EAAY/H,IAAM2C,SAASoF,EAAY/H,IAAMgI,EAAa,IAGxDH,EAAQ7H,IAAM,GAChB6H,EAAQ7H,IAAM,GAEd6H,EAAQ7H,IAAM2C,SAASkF,EAAQ7H,IAAMgI,EAAa,IAGhDH,EAAQ/H,IAAM,GAAKiI,EAAYjI,IAAM,IACvCiI,EAAYjI,KAAO,KAErBiI,EAAYjI,IAAM6C,SAASoF,EAAYjI,IAAMmI,EAAa,IAC1DJ,EAAQ/H,IAAM6C,SAASkF,EAAQ/H,IAAMmI,EAAa,IAGlD,IACE,IAAIhF,EAAIyD,KAAKhB,gBACbzC,GAAK4E,EAAQ7H,IACbiD,GAAKyD,KAAKhB,gBAENzC,GAAK8E,EAAY/H,MAET,KAANiD,IACFA,EAAI,IAENyD,KAAKwB,iBAAiBrE,EAAKZ,EAAG4E,EAAQ/H,IAAKiI,EAAYjI,MAK3D,IAAK,IAAImD,EAAI,EAAGA,GAAK8E,EAAY/H,IAAKiD,GAAKyD,KAAKhB,gBAC1CzC,GAAK4E,EAAQ7H,KACf0G,KAAKwB,iBAAiBrE,EAAKZ,EAAG4E,EAAQ/H,IAAKiI,EAAYjI,KAM3D,IACE,IAAImD,EAAIyD,KAAKf,gBACb1C,GAAK8E,EAAYjI,IAAM,EACvBmD,GAAKyD,KAAKf,gBAEN1C,GAAK4E,EAAQ/H,KACf4G,KAAKyB,kBAAkBtE,EAAKZ,EAAG4E,EAAQ7H,IAAK+H,EAAY/H,KAK5D,IAAK,IAAIiD,EAAI,EAAGA,GAAK4E,EAAQ/H,IAAKmD,GAAKyD,KAAKf,gBACtC1C,GAAK8E,EAAYjI,KACnB4G,KAAKyB,kBAAkBtE,EAAKZ,EAAG4E,EAAQ7H,IAAK+H,EAAY/H,S,8BAK9D,SAAiB6D,EAAKuE,EAAMC,EAASC,GACnC,IAAMC,EAAWxH,EAAoB2F,KAAK1F,IAAK,CAAEhB,IAAKoI,EAAMtI,IAAKuI,IAE3DG,EAAYzH,EAAoB2F,KAAK1F,IAAK,CAC9ChB,IAAKoI,EACLtI,IAAKwI,IAGPzE,EAAI4E,YACJ5E,EAAI6E,OAAOH,EAAS/D,EAAG+D,EAAS7D,GAChCb,EAAI8E,OAAOH,EAAUhE,EAAGgE,EAAU9D,GAClCb,EAAI+E,W,+BAGN,SAAkB/E,EAAKuE,EAAMS,EAAQC,GAC/BD,GAAU,KACZA,EAAS,IAGPC,IAAc,KAChBA,GAAa,IAGf,IAAMC,EAAahI,EAAoB2F,KAAK1F,IAAK,CAC/ChB,IAAK6I,EACL/I,IAAKsI,IAGDY,EAAgBjI,EAAoB2F,KAAK1F,IAAK,CAClDhB,IAAK8I,EACLhJ,IAAKsI,IAGDa,EAAsB,GAI5B,GAFApF,EAAI4E,YAES,IAATL,EAAY,CACd,IAAMc,EAAsB,GACtBC,EAAyB,GAGzBC,EAAmBrI,EAAoB2F,KAAK1F,IAAK,CACrDhB,IAAKkJ,EACLpJ,IAAKsI,IAGDiB,EAAkBtI,EAAoB2F,KAAK1F,IAAK,CACpDhB,IAAKkJ,EACLpJ,IAT6B,IAYzBwJ,EAAqBvI,EAAoB2F,KAAK1F,IAAK,CACvDhB,IAAKmJ,EACLrJ,IAd6B,IAiBzByJ,EAAsBxI,EAAoB2F,KAAK1F,IAAK,CACxDhB,IAAKmJ,EACLrJ,IAAKsI,IAEP,GAAIS,EAASK,GAAuBJ,EAAYK,EAAwB,CAGtE,GAAIN,EAASI,EAAqB,CAChC,IAAMO,EAA4BzI,EAAoB2F,KAAK1F,IAAK,CAC9DhB,IAAKiJ,EACLnJ,IAAKsI,IAEPvE,EAAI6E,OAAOc,EAA0BhF,EAAGgF,EAA0B9E,QAElEb,EAAI6E,OAAOK,EAAWvE,EAAGuE,EAAWrE,GAGtCb,EAAI8E,OAAOS,EAAiB5E,EAAG4E,EAAiB1E,GAEhDb,EAAI6E,OAAOW,EAAgB7E,EAAG6E,EAAgB3E,GAE9Cb,EAAI8E,OAAOU,EAAgB7E,EAAGwE,EAActE,QACvC,GAELmE,EAASK,GACTJ,EAAYK,EAEZtF,EAAI6E,OAAOW,EAAgB7E,EAAGuE,EAAWrE,GAEzCb,EAAI8E,OAAOW,EAAmB9E,EAAG8E,EAAmB5E,GAEpDb,EAAI6E,OAAOa,EAAoB/E,EAAG+E,EAAoB7E,GAEtDb,EAAI8E,OAAOY,EAAoB/E,EAAGwE,EAActE,QAC3C,GAELmE,GAAUK,GACVJ,GAAaK,EACb,CAEA,GAAIN,EAASI,EAAqB,CAChC,IAAMO,EAA4BzI,EAAoB2F,KAAK1F,IAAK,CAC9DhB,IAAKiJ,EACLnJ,IAAKsI,IAEPvE,EAAI6E,OAAOc,EAA0BhF,EAAGgF,EAA0B9E,QAElEb,EAAI6E,OAAOK,EAAWvE,EAAGuE,EAAWrE,GAGtCb,EAAI8E,OAAOS,EAAiB5E,EAAG4E,EAAiB1E,GAEhDb,EAAI6E,OAAOW,EAAgB7E,EAAG6E,EAAgB3E,GAE9Cb,EAAI8E,OAAOW,EAAmB9E,EAAG8E,EAAmB5E,GAEpDb,EAAI6E,OAAOU,EAAiB5E,EAAG8E,EAAmB5E,GAElDb,EAAI8E,OAAOS,EAAiB5E,EAAGwE,EAActE,QAG7CmE,GAAUK,GACVJ,GAAaK,IAEbtF,EAAI6E,OAAOW,EAAgB7E,EAAGuE,EAAWrE,GAEzCb,EAAI8E,OAAOW,EAAmB9E,EAAGwE,EAActE,SAE5C,GAAa,KAAT0D,EACT,GAAIS,EAASI,GAAuBJ,GAAU,GAAI,CAEhD,IAAMY,EAAsB1I,EAAoB2F,KAAK1F,IAAK,CACxDhB,IAAK6I,EACL/I,IAAK,IAEP+D,EAAI6E,OAAOe,EAAoBjF,EAAGiF,EAAoB/E,GAEtD,IAAMgF,EAAyB3I,EAAoB2F,KAAK1F,IAAK,CAC3DhB,IAAKiJ,EACLnJ,IAAK,IAGP+D,EAAI8E,OAAOe,EAAuBlF,EAAGkF,EAAuBhF,GAE5D,IAAMiF,EAAuB5I,EAAoB2F,KAAK1F,IAAK,CACzDhB,IAAKiJ,EACLnJ,IAAKsI,IAGPvE,EAAI6E,OAAOiB,EAAqBnF,EAAGmF,EAAqBjF,GAExDb,EAAI8E,OAAOK,EAAcxE,EAAGwE,EAActE,QAG1Cb,EAAI6E,OAAOK,EAAWvE,EAAGuE,EAAWrE,GACpCb,EAAI8E,OAAOK,EAAcxE,EAAGwE,EAActE,QAEvC,GAAa,KAAT0D,EAAa,CAEtB,GAAIS,EAASI,EAAqB,CAChC,IAAMW,EAA4B7I,EAAoB2F,KAAK1F,IAAK,CAC9DhB,IAAKiJ,EACLnJ,IAAKsI,IAEPvE,EAAI6E,OAAOkB,EAA0BpF,EAAGoF,EAA0BlF,QAElEb,EAAI6E,OAAOK,EAAWvE,EAAGuE,EAAWrE,GAEtCb,EAAI8E,OAAOK,EAAcxE,EAAGwE,EAActE,QACrC,GAAa,KAAT0D,EACT,GAAIS,EAASI,GAAuBJ,GAAU,GAAI,CAEhD,IAAMgB,EAAsB9I,EAAoB2F,KAAK1F,IAAK,CACxDhB,IAAK6I,EACL/I,IAAK,KAEP+D,EAAI6E,OAAOmB,EAAoBrF,EAAGqF,EAAoBnF,GAEtD,IAAMoF,EAAyB/I,EAAoB2F,KAAK1F,IAAK,CAC3DhB,IAAKiJ,EACLnJ,IAAK,KAGP+D,EAAI8E,OAAOmB,EAAuBtF,EAAGsF,EAAuBpF,GAE5D,IAAMqF,EAAuBhJ,EAAoB2F,KAAK1F,IAAK,CACzDhB,IAAKiJ,EACLnJ,IAAKsI,IAGPvE,EAAI6E,OAAOqB,EAAqBvF,EAAGuF,EAAqBrF,GAExDb,EAAI8E,OAAOK,EAAcxE,EAAGwE,EAActE,QAG1Cb,EAAI6E,OAAOK,EAAWvE,EAAGuE,EAAWrE,GACpCb,EAAI8E,OAAOK,EAAcxE,EAAGwE,EAActE,QAEvC,GAAa,KAAT0D,EAAa,CAEtB,GAAIS,EAASI,EAAqB,CAChC,IAAMe,EAA4BjJ,EAAoB2F,KAAK1F,IAAK,CAC9DhB,IAAKiJ,EACLnJ,IAAKsI,IAEPvE,EAAI6E,OAAOsB,EAA0BxF,EAAGwF,EAA0BtF,QAElEb,EAAI6E,OAAOK,EAAWvE,EAAGuE,EAAWrE,GAEtCb,EAAI8E,OAAOK,EAAcxE,EAAGwE,EAActE,QACrC,GAAa,KAAT0D,EACT,GAAIS,EAASI,GAAuBJ,GAAU,GAAI,CAEhD,IAAMoB,EAAsBlJ,EAAoB2F,KAAK1F,IAAK,CACxDhB,IAAK6I,EACL/I,IAAK,KAEP+D,EAAI6E,OAAOuB,EAAoBzF,EAAGyF,EAAoBvF,GAEtD,IAAMwF,EAAyBnJ,EAAoB2F,KAAK1F,IAAK,CAC3DhB,IAAKiJ,EACLnJ,IAAK,KAGP+D,EAAI8E,OAAOuB,EAAuB1F,EAAG0F,EAAuBxF,GAE5D,IAAMyF,EAAuBpJ,EAAoB2F,KAAK1F,IAAK,CACzDhB,IAAKiJ,EACLnJ,IAAKsI,IAGPvE,EAAI6E,OAAOyB,EAAqB3F,EAAG2F,EAAqBzF,GAExDb,EAAI8E,OAAOK,EAAcxE,EAAGwE,EAActE,QAG1Cb,EAAI6E,OAAOK,EAAWvE,EAAGuE,EAAWrE,GACpCb,EAAI8E,OAAOK,EAAcxE,EAAGwE,EAActE,QAK5Cb,EAAI6E,OAAOK,EAAWvE,EAAGuE,EAAWrE,GACpCb,EAAI8E,OAAOK,EAAcxE,EAAGwE,EAActE,GAE5Cb,EAAI+E,SAEJlC,KAAK0D,cAAcvG,EAAKuE,K,2BAQ1B,SAAcvE,EAAKwG,GAEjB,IAAK,IAAIC,GAAiB,GAAIA,EAAgB,GAAIA,GAAiB,EAAG,CACpE,IAAIC,OAAc,EAIdA,EAHkB,KAAlBD,EACgB,IAAdD,EAEe,IACM,IAAdA,EAEQ,IAEAA,EAAY,EAEJ,KAAlBC,EACS,IAAdD,EAEe,IACM,KAAdA,EAEQ,GACM,KAAdA,EAEQ,GACM,KAAdA,EAEQ,KAEAA,EAAY,EAIdA,EAAY,EAG/B,IAAIG,OAAQ,EACZ,IACEA,EAAW7I,YAAQ,CAAC4I,EAAgBD,GAAgB,GAAGxI,MACrDgD,GA9cQ,GAgdV,MAAO2F,GACP,OAIF,IACiB,QAAbD,GAAoC,IAAdH,KACT,QAAbG,GAAoC,KAAdH,KACT,QAAbG,GAAoC,KAAdH,GACxB,CACA,IAAMK,EAAW3J,EAAoB2F,KAAK1F,IAAK,CAC7ChB,IAAKsK,EACLxK,IAAKyK,IAGP3G,EACEC,EACA2G,EACA9D,KAAKJ,QAAQH,UACbO,KAAKJ,QAAQL,MACbyE,S,GAtdcC,S,OCIlB7F,EAAa,+BAKf8F,EAAM,IADGC,EAAQ,KAGfC,EAAoB,SAAC9F,GACzB,IAAIhE,EAAMiE,cAEJC,EAASC,SAASC,cAAc,UACtCF,EAAOG,UAAUC,IAAI,yBAErB,IAAIC,EAAI,IAAIC,EAAU,CAAExE,IAAKA,EAAKkE,OAAQA,IAG1C,OAFAlE,EAAIyE,SAASF,GAEN,MAGHC,E,kDACJ,WAAYR,GAAO,kCACjB,cAAMA,IAED+F,gBAAkB,EAAKA,gBAAgBC,KAArB,gBAEvB,EAAKpF,eAAiB,CACpBC,UAAU,EACVC,WAAW,EACXC,QAAS,GACTC,OAAQ,EACRC,MAAO,UACPC,KAAM,mBACNC,UAAW,UACXC,UAAW,CAAC,EAAG,GACf6E,aAAc,GACdC,cAAe,GACf7E,QAAS,EACT8E,QAAS,IAGX,EAAK7E,QAAWtB,GAASA,EAAMsB,SAAY,EAAKV,eAEhD,EAAK5E,IAAMgE,EAAMhE,IACjB,EAAKkE,OAASF,EAAME,OACpB,EAAKgG,cAAgB,GACrB,EAAKD,aAAe,GAEpB,EAAKG,wBAA0B,IA3Bd,E,mDA8BnB,SAAgBpG,GACd0B,KAAKJ,QAAWtB,GAASA,EAAMsB,SAAYI,KAAKd,iB,mBAGlD,SAAM5E,GACJA,EAAIuF,OAAOC,YAAYC,YAAYC,KAAKxB,QACxClE,EAAI2F,GAAG,YAAaD,KAAKE,MAAOF,MAChC1F,EAAI2F,GAAG,OAAQD,KAAKE,MAAOF,MAE3BA,KAAKE,U,sBAGP,SAAS5F,GACPA,EAAIuF,OAAOC,YAAYK,YAAYH,KAAKxB,QACxClE,EAAI8F,IAAI,YAAaJ,KAAKE,MAAOF,MACjC1F,EAAI8F,IAAI,OAAQJ,KAAKE,MAAOF,MAE5BA,KAAKxB,OAAS,KACdwB,KAAK1F,IAAM,O,mBAMb,WACE,IAAM+F,EAAWL,KAAK1F,IAAIgG,UACpBqE,EAAe3E,KAAK1F,IAAIkG,2BAA2B,CAAC,EAAG,IAE7DR,KAAKxB,OAAOiC,aAAekE,EAE3B3E,KAAKxB,OAAOkC,MAAZ,gCAEmBiE,EAAa7G,EAFhC,cAEuC6G,EAAa3G,EAFpD,SAIAgC,KAAKxB,OAAOd,MAAQ2C,EAASvC,EAC7BkC,KAAKxB,OAAOmC,OAASN,EAASrC,EAC9B,IAAM4G,EAAO5E,KAAK1F,IAAIuG,UAEtB,GAAI+D,EAAO5E,KAAKJ,QAAQD,SAAWiF,EAAO5E,KAAKJ,QAAQ6E,QAAS,CAC9D,IAAII,EAAe7E,KAAK8E,cAExB9E,KAAKuE,aAAe,GACpBvE,KAAKwE,cAAgB,GACrBxE,KAAK+E,cAAcF,M,yBAIvB,WACE,IAAMG,EAAgB/J,YACpB,CACE+E,KAAK1F,IAAI2K,YAAYC,eAArB,IACAlF,KAAK1F,IAAI2K,YAAYC,eAArB,KAEF,GAEIC,EAAgBlK,YACpB,CACE+E,KAAK1F,IAAI2K,YAAYG,eAArB,IACApF,KAAK1F,IAAI2K,YAAYG,eAArB,KAEF,GAEIC,EAAgBpK,YACpB,CACE+E,KAAK1F,IAAI2K,YAAYK,eAArB,IACAtF,KAAK1F,IAAI2K,YAAYK,eAArB,KAEF,GAEIC,EAAgBtK,YACpB,CACE+E,KAAK1F,IAAI2K,YAAYO,eAArB,IACAxF,KAAK1F,IAAI2K,YAAYO,eAArB,KAEF,GAUF,OAPmB9J,EACjBsJ,EAAc5J,MAAMgD,GA/HR,GAgIZ+G,EAAc/J,MAAMgD,GAhIR,GAiIZiH,EAAcjK,MAAMgD,GAjIR,GAkIZmH,EAAcnK,MAAMgD,GAlIR,M,mCAwIhB,SAAsBqH,GACpB,OAAQA,GACN,KAAK,GAEL,KAAK,GAEL,KAAK,GACH,OAAO,GACT,KAAK,GACH,OAAO,GACT,KAAK,GACH,OAAO,GACT,KAAK,GACH,OAAO,EACT,KAAK,GACH,OAAO,EACT,KAAK,GAEL,KAAK,EAEL,KAAK,EAEL,KAAK,EACH,OAAO,EACT,KAAK,EAEL,QACE,OAAO,K,6BAIb,SAAgBtI,EAAKuI,EAAYC,GAC/B,IACM3B,EAAW3J,EAAoB2F,KAAK1F,IAAK,CAC7ChB,KAAMoM,EAAWpM,IAAMqM,EAAarM,KAAO,EAFzB,GAGlBF,KAAMsM,EAAWtM,IAAMuM,EAAavM,KAAO,IAS7C8D,EACEC,EANiBlC,YAAQ,EACxByK,EAAWtM,IAAMuM,EAAavM,KAAO,GACrCsM,EAAWpM,IAAMqM,EAAarM,KAAO,EATpB,KAUjB8B,MAAMgD,GAjLI,GAsLX4B,KAAKJ,QAAQH,UACbO,KAAKJ,QAAQL,MACbyE,K,uBAIJ,SAAU7G,EAAKyI,EAASD,GACtB,IAAME,EAAkB1K,iBAAO,OACzB2K,EACJD,EAAe,SAAf,YAA2C,GAxMhC,GAKO,GAoMdE,EACJF,EAAe,SAAf,YAA2C,GAzMhC,GAIO,GAwMdG,EAAgB9B,EAAI+B,mBACxBL,EAAQM,QAAU,IAClBN,EAAQO,SACRP,EAAQQ,WACRR,EAAQS,YAGJC,EAAQrN,EAAa0M,EAAcK,GAGnCO,EAAyBhN,EAC7B+M,EACAP,EACAC,GAGIQ,EAA0BnM,EAAoB2F,KAAK1F,IAAK,CAC5DhB,IAAKiN,EACLnN,IAAK2M,IAIDU,EAAyBlN,EAC7B+M,EACAR,EACAE,GAGIU,EAA0BrM,EAAoB2F,KAAK1F,IAAK,CAC5DhB,IAAKmN,EACLrN,IAAK0M,IAEP3I,EAAI6E,OAAO0E,EAAwB5I,EAAG4I,EAAwB1I,GAC9Db,EAAI8E,OAAOuE,EAAwB1I,EAAG0I,EAAwBxI,GAG9DgC,KAAK2G,gBACHxJ,EACA,CAAE7D,IAAKiN,EAAwBnN,IAAK2M,GACpCJ,GAIF3F,KAAK2G,gBACHxJ,EACA,CAAE7D,IAAKmN,EAAwBrN,IAAK0M,GACpCH,K,yCAIJ,SACEiB,EACAC,EACAC,EACAC,GAEA,IAAIC,EAAmBJ,EAAoBK,SACvCC,EAAkBL,EAAmBM,QAmBzC,GAhBAH,EACEI,KAAKC,KAAKL,EAAmBhH,KAAK0E,yBAClC1E,KAAK0E,wBACPwC,EACEE,KAAKC,KAAKH,EAAkBlH,KAAK0E,yBACjC1E,KAAK0E,wBAGLkC,EAAoBU,WAClBV,EAAoBW,WAAW/K,aACjC,QAEAwK,EAAmB,MAIjBJ,EAAoBW,aAAeT,EAAiBS,WACtD,KAAOP,GAAoBF,EAAiBG,UAEtCD,EAAmBhH,KAAK0E,0BAA4B,GACtD1E,KAAKwE,cAAclI,KAAK,CACtB6J,SAAUa,EACVZ,WAAYQ,EAAoBU,WAChCjB,WAAYO,EAAoBW,aAGpCP,GAAoBhH,KAAK0E,wBAI7B,GAAImC,EAAmBU,aAAeR,EAAgBQ,WACpD,KAAOL,GAAmBH,EAAgBI,SACpCD,EAAkBlH,KAAK0E,0BAA4B,GACrD1E,KAAKuE,aAAajI,KAAK,CACrB4J,QAASgB,EACTd,WAAYS,EAAmBS,WAC/BjB,WAAYQ,EAAmBU,aAGnCL,GAAmBlH,KAAK0E,0B,qCAK9B,SAAwB8C,EAAWC,EAAaC,GAC9C,GACED,EAAYrB,aAAesB,EAAatB,YACxCqB,EAAYpB,aAAeqB,EAAarB,WACxC,CACA,IAAMsB,EAAoB,CACxBxB,SAAUuB,EAAavB,SACvBD,QAASuB,EAAYvB,QACrBE,WAAYsB,EAAatB,WACzBC,WAAYqB,EAAarB,YAG3B,GACEmB,EAAUI,SACR1D,EAAI+B,mBACF0B,EAAkBzB,QAClByB,EAAkBxB,SAClBwB,EAAkBvB,WAClBuB,EAAkBtB,aAItB,OAAOsB,K,iCAKb,SAAoBxK,EAAK0K,EAAmBC,GAC1C,IAAIC,EAAoB7D,EAAI+B,mBAC1BmB,KAAKY,OAAOH,EAAkB3B,QAAU4B,EAAmB5B,SAAW,GACtEkB,KAAKY,MAAMH,EAAkB1B,SAAW,KACxC0B,EAAkBzB,WAClByB,EAAkBxB,YAQpBnJ,EACEC,EANclC,YAAQ,CACtB8M,EAAkB3O,IAClB2O,EAAkBzO,MACjB8B,MAAMgD,GAlVI,GAuVX4B,KAAKJ,QAAQH,UACbO,KAAKJ,QAAQL,MACblF,EAAoB2F,KAAK1F,IAAK,CAC5BhB,IAAKyO,EAAkBzO,IACvBF,IAAK2O,EAAkB3O,S,2BAK7B,SAAc6O,GAAa,WACrB9K,EAAM6C,KAAKxB,OAAOsC,WAAW,MACjC3D,EAAI4D,UAAU,EAAG,EAAGf,KAAKxB,OAAOd,MAAOsC,KAAKxB,OAAOmC,QACnDxD,EAAI6D,UAAYhB,KAAKJ,QAAQN,OAC7BnC,EAAI8D,YAAcjB,KAAKJ,QAAQL,MAC/BpC,EAAIc,UAAY+B,KAAKJ,QAAQL,MAC7BpC,EAAI+D,YAAYlB,KAAKJ,QAAQF,WAC7BvC,EAAIqC,KAAOQ,KAAKJ,QAAQJ,KAExByI,EAAYC,SAAQ,SAACC,GAEnB,IAAIC,EACJ,IACEA,EAAiBjN,iBAAOgN,GACxB,MAAOpE,GACP,OAGF,IAAMsE,EACJD,EAAc,SAAd,YAA0C,GA7XjC,GA8XLE,EACJF,EAAc,SAAd,YAA0C,GA9XjC,GA+XLG,EACJH,EAAc,SAAd,YAA0C,GA/XjC,GAgYLI,EACJJ,EAAc,SAAd,YAA0C,GAhYjC,GAoYLK,EAAS,KAEXC,EAAgBxE,EAAIyE,mBACtBN,EArYe,GAqYgBI,EAC/BJ,EArYgB,GAqYgBI,EANX,GASjBG,EAAgB1E,EAAIyE,mBACxBL,EA1Ye,GA0YgBG,EAC/BH,EA1YgB,GA0YgBG,EAXX,GAcjBI,EAAgB3E,EAAIyE,mBACxBJ,EA/Ye,GA+YgBE,EAC/BF,EA/YgB,GA+YgBE,EAhBX,GAmBjBK,EAAgB5E,EAAIyE,mBACxBH,EApZe,GAoZgBC,EAC/BD,EApZgB,GAoZgBC,EArBX,GAuCvB,OAXY,QAARN,IACFO,EAAgB,CACdnB,WAAY,IACZD,WAAY,GACZH,QAAS,OACTF,SAAU,UAIK,EAAK3M,IAAIyO,YAAYzP,KAAO,EAAI,QAAU,SAG3D,IAAK,QACH,EAAK0P,4BACHN,EACAA,EACAG,EACAC,GAEF,MACF,IAAK,QACH,EAAKE,4BACHN,EACAE,EACAC,EACAA,OAQR,IAAMI,EAAajJ,KAAK1F,IACrB2K,YACAiE,IAAIlJ,KAAKmJ,sBAAsBnJ,KAAK1F,IAAIuG,YAC3Cb,KAAKwE,cAAc0D,SAAQ,SAACR,GAC1B,IAAI0B,EAAqB,GAEzB,EAAK7E,aAAa2D,SAAQ,SAACT,GACzB,IAAI4B,EAAe,EAAKC,wBACtBL,EACAxB,EACAC,GAEE2B,GACFD,EAAmB9M,KAAK+M,MAI5BD,EAAmBlB,SAAQ,SAACqB,EAAMC,EAAOC,GACvC,IAAIC,EAAgBxF,EAAI+B,mBACtBsD,EAAKrD,QACLqD,EAAKpD,SACLoD,EAAKnD,WACLmD,EAAKlD,YAGHsD,EAAgBtP,EAAoB,EAAKC,IAAK,CAChDhB,IAAKoQ,EAAcpQ,IACnBF,IAAKsQ,EAActQ,MAGjB+O,EAAMoB,EAAKnD,WAAW5J,WAAa+M,EAAKlD,WAK5C,GAAY,QAAR8B,EACF,EAAKyB,UAAUzM,EAAKoM,EAAMG,QAE1B,GAAc,IAAVF,EAAa,CACf,GAAIJ,EAAmBI,EAAQ,GAAI,CACjC,IAAMK,EAAqB3F,EAAI+B,mBAC7BmD,EAAmBI,EAAQ,GAAGtD,QAC9BkD,EAAmBI,EAAQ,GAAGrD,SAC9BiD,EAAmBI,EAAQ,GAAGpD,WAC9BgD,EAAmBI,EAAQ,GAAGnD,YAI1BP,EAAqB3K,iBAAOgN,GAAP,qBAEzB,GAnfC,GAKO,GAifV,GAAIuB,EAActQ,IAAM0M,EAAoB,CAC1C,IAEIjM,EAAmBN,EAFXN,EAAayQ,EAAeG,GAItC/D,EACA+D,GAGFF,EAAgBtP,EAAoB,EAAKC,IAAK,CAC5ChB,IAAKO,EACLT,IAAK0M,SAGF,GAAI4D,EAActQ,IAAM0M,EAAoB,CACjD,IAAIgE,EAAkBhP,EACpB4O,EACAG,EACA,QAGEE,EAAqBJ,EAEzBA,EAAgBtP,EAAoB,EAAKC,IAAK,CAC5ChB,IAAKwQ,EAAgBxQ,IACrBF,IAAK0Q,EAAgB1Q,MAIvB,IAAIgE,EAAYnC,YAAQ,CACtB6O,EAAgB1Q,IAChB0Q,EAAgBxQ,MACf8B,MAAMgD,GA7gBR,GA+gBG4L,EAAa7M,EAAIM,YAAYL,GAAWM,MAI1C0J,KAAK6C,IAAIF,EAAmBjM,EAAI6L,EAAc7L,GAAK,IACnDkM,GAEA9M,EACEC,EACAC,EACA,EAAKwC,QAAQH,UACb,EAAKG,QAAQL,MACblF,EAAoB,EAAKC,IAAK,CAC5BhB,IACE8N,KAAK6C,IAAIH,EAAgB1Q,IAAMsQ,EAActQ,KAAO,EACpD0Q,EAAgBxQ,IAClBF,KAAM0Q,EAAgB1Q,IAAMsQ,EAActQ,KAAO,KAMrC,OAAdgE,GAA8B,QAAR+K,IACxB/K,EAAYnC,YAAQ,EACjB6O,EAAgB1Q,IAAMsQ,EAActQ,KAAO,EAC5CgO,KAAK6C,IAAIH,EAAgB1Q,IAAMsQ,EAActQ,KAAO,EAClD0Q,EAAgBxQ,MACjB8B,MAAMgD,GA1iBV,GA4iBC4L,EAAa7M,EAAIM,YAAYL,GAAWM,MAItC0J,KAAK6C,IAAIF,EAAmBjM,EAAI6L,EAAc7L,GAAK,IACnDkM,GAEA9M,EACEC,EACAC,EACA,EAAKwC,QAAQH,UACb,EAAKG,QAAQL,MACblF,EAAoB,EAAKC,IAAK,CAC5BhB,IACEwQ,EAAgBxQ,IAChB8N,KAAK6C,IAAIH,EAAgB1Q,IAAMsQ,EAActQ,KAAO,EACtDA,KAAM0Q,EAAgB1Q,IAAMsQ,EAActQ,KAAO,MAO3D,IAAI2O,EAAoB7D,EAAI+B,mBAC1BmB,KAAKY,OACFoB,EAAmBI,GAAOtD,QACzBkD,EAAmBI,EAAQ,GAAGtD,SAC9B,GAEJkB,KAAKY,MAAMoB,EAAmBI,GAAOrD,SAAW,KAChDiD,EAAmBI,GAAOpD,WAC1BgD,EAAmBI,GAAOnD,YAGxBjJ,EAAYnC,YAAQ,CACtB8M,EAAkB3O,IAClB2O,EAAkBzO,MACjB8B,MAAMgD,GAjlBN,GAmlBiB,OAAdhB,GAA8B,QAAR+K,GAC1BjL,EACEC,EACAC,EACA,EAAKwC,QAAQH,UACb,EAAKG,QAAQL,MACblF,EAAoB,EAAKC,IAAK,CAC5BhB,IAAKyO,EAAkBzO,IACvBF,IAAK2O,EAAkB3O,OAKL,MAApBmQ,EAAKlD,YACP,EAAK6D,oBACH/M,EACAiM,EAAmBI,GACnBJ,EAAmBI,EAAQ,IAIjCrM,EAAI4E,YAEJ5E,EAAI6E,OAAO2H,EAAc7L,EAAG6L,EAAc3L,OACrC,CAEL,GAAIwL,IAAUC,EAAM7M,OAAS,EAAG,CAC9B,IAAMmJ,EAAqB5K,iBAAOgN,GAAP,qBAEzB,GAxnBC,GAIO,GAqnBJgC,EAAqBjG,EAAI+B,mBAC7BmD,EAAmBI,EAAQ,GAAGtD,QAC9BkD,EAAmBI,EAAQ,GAAGrD,SAC9BiD,EAAmBI,EAAQ,GAAGpD,WAC9BgD,EAAmBI,EAAQ,GAAGnD,YAIhC,GAAIqD,EAActQ,IAAM2M,EAAoB,CAC1C,IAEIlM,EAAmBN,EAFXN,EAAayQ,EAAeS,GAItCpE,EACAoE,GAGFR,EAAgBtP,EAAoB,EAAKC,IAAK,CAC5ChB,IAAKO,EACLT,IAAK2M,SAIF,GAAI2D,EAActQ,KAAO2M,EAAoB,CAClD,IAAI+D,EAAkBhP,EACpB4O,EACAS,EACA,QAGEJ,EAAqBJ,EAEzBA,EAAgBtP,EAAoB,EAAKC,IAAK,CAC5ChB,IAAKwQ,EAAgBxQ,IACrBF,IAAK0Q,EAAgB1Q,MAIvB,IAAIgE,EAAYnC,YAAQ,CACtByO,EAActQ,IACdsQ,EAAcpQ,MACb8B,MAAMgD,GA1pBR,GA4pBG4L,EAAa7M,EAAIM,YAAYL,GAAWM,MAI1C0J,KAAK6C,IAAIF,EAAmBjM,EAAI6L,EAAc7L,GAAK,IACnDkM,GAEA9M,EACEC,EACAC,EACA,EAAKwC,QAAQH,UACb,EAAKG,QAAQL,MACblF,EAAoB,EAAKC,IAAK,CAC5BhB,IACE8N,KAAK6C,IAAIH,EAAgB1Q,IAAMsQ,EAActQ,KAAO,EACpD0Q,EAAgBxQ,IAClBF,KAAM0Q,EAAgB1Q,IAAMsQ,EAActQ,KAAO,KAMzD,IAAI2O,EAAoB7D,EAAI+B,mBAC1BmB,KAAKY,OACFoB,EAAmBI,GAAOtD,QACzBkD,EAAmBI,EAAQ,GAAGtD,SAC9B,GAEJkB,KAAKY,MAAMoB,EAAmBI,GAAOrD,SAAW,KAChDiD,EAAmBI,GAAOpD,WAC1BgD,EAAmBI,GAAOnD,YAGxBjJ,EAAYnC,YAAQ,CACtB8M,EAAkB3O,IAClB2O,EAAkBzO,MACjB8B,MAAMgD,GAhsBN,GAksBHlB,EACEC,EACAC,EACA,EAAKwC,QAAQH,UACb,EAAKG,QAAQL,MACblF,EAAoB,EAAKC,IAAK,CAC5BhB,IAAKyO,EAAkBzO,IACvBF,IAAK2O,EAAkB3O,WAGtB,CACL,IAAI2O,EAAoB7D,EAAI+B,mBAC1BmB,KAAKY,OACFoB,EAAmBI,GAAOtD,QACzBkD,EAAmBI,EAAQ,GAAGtD,SAC9B,GAEJkB,KAAKY,MAAMoB,EAAmBI,GAAOrD,SAAW,KAChDiD,EAAmBI,GAAOpD,WAC1BgD,EAAmBI,GAAOnD,YAGxBjJ,EAAYnC,YAAQ,CACtB8M,EAAkB3O,IAClB2O,EAAkBzO,MACjB8B,MAAMgD,GA3tBN,GA4tBiB,OAAdhB,GAA8B,QAAR+K,GAC1BjL,EACEC,EACAC,EACA,EAAKwC,QAAQH,UACb,EAAKG,QAAQL,MACblF,EAAoB,EAAKC,IAAK,CAC5BhB,IAAKyO,EAAkBzO,IACvBF,IAAK2O,EAAkB3O,OAKL,MAApBmQ,EAAKlD,YACP,EAAK6D,oBACH/M,EACAiM,EAAmBI,GACnBJ,EAAmBI,EAAQ,IAIjCrM,EAAI8E,OAAO0H,EAAc7L,EAAG6L,EAAc3L,OAIhDb,EAAI+E,YAGNlC,KAAKuE,aAAa2D,SAAQ,SAACT,GACzB,IAAI2C,EAAoB,GAExB,EAAK5F,cAAc0D,SAAQ,SAACR,GAC1B,IAAI2B,EAAe,EAAKC,wBACtBL,EACAxB,EACAC,GAEE2B,GACFe,EAAkB9N,KAAK+M,MAG3B,IAAIgB,GAAa,EACjBD,EAAkBlC,SAAQ,SAACqB,EAAMC,EAAOC,GACtC,IAAIY,EAAJ,CAIA,IAAIX,EAAgBxF,EAAI+B,mBACtBsD,EAAKrD,QACLqD,EAAKpD,SACLoD,EAAKnD,WACLmD,EAAKlD,YAGHsD,EAAgBtP,EAAoB,EAAKC,IAAK,CAChDhB,IAAKoQ,EAAcpQ,IACnBF,IAAKsQ,EAActQ,MAGjB+O,EAAMoB,EAAKnD,WAAW5J,WAAa+M,EAAKlD,WAEtCiE,EAAenP,iBAAOgN,GAAP,qBAAuC,GAnyBnD,GAwyBT,GAAc,IAAVqB,EAAa,CAKf,GAJArM,EAAI4E,YAKF2H,EAAcpQ,IAAMgR,EAzyBT,IA0yBXF,EAAkBZ,EAAQ,GAC1B,CACA,IAOIe,EAAgBzP,EAClB4O,EARyBxF,EAAI+B,mBAC7BmE,EAAkBZ,EAAQ,GAAGtD,QAC7BkE,EAAkBZ,EAAQ,GAAGrD,SAC7BiE,EAAkBZ,EAAQ,GAAGpD,WAC7BgE,EAAkBZ,EAAQ,GAAGnD,YAM7B,SAGFsD,EAAgBtP,EAAoB,EAAKC,IAAK,CAC5ChB,IAAKiR,EAAcjR,IACnBF,IAAKmR,EAAcnR,MAGvB+D,EAAI6E,OAAO2H,EAAc7L,EAAG6L,EAAc3L,OACrC,CAEL,IAAMwM,EAAerP,iBAAOgN,GAAP,qBAAuC,GAp0BrD,GAw0BDgC,EAAqBjG,EAAI+B,mBAC7BmE,EAAkBZ,EAAQ,GAAGtD,QAC7BkE,EAAkBZ,EAAQ,GAAGrD,SAC7BiE,EAAkBZ,EAAQ,GAAGpD,WAC7BgE,EAAkBZ,EAAQ,GAAGnD,YAG3B7M,EAAQP,EAAayQ,EAAeS,GA0BxC,GAtBIT,EAActQ,KAAOkR,EA/0BX,IAg1BZX,EAAgB,EAAKc,cACnBjR,EACA8Q,EAl1BU,GAm1BVH,GAKFE,GAAa,GACJX,EAActQ,IAAMoR,EAz1BjB,KA01BZb,EAAgB,EAAKc,cACnBjR,EACAgR,EA51BU,GA61BVL,GAGFE,GAAa,GAGflN,EAAI8E,OAAO0H,EAAc7L,EAAG6L,EAAc3L,GAGxCyL,EAAM7M,OAAS,IAAM4M,GACrBE,EAAcpQ,IAAMkR,EAx2BT,GAy2BX,CACA,IAAID,EAAgBzP,EAClB4O,EACAS,EACA,SAEFR,EAAgBtP,EAAoB,EAAKC,IAAK,CAC5ChB,IAAKiR,EAAcjR,IACnBF,IAAKmR,EAAcnR,MAGrB+D,EAAI8E,OAAO0H,EAAc7L,EAAG6L,EAAc3L,SAIhDb,EAAI+E,c,2BAMR,SAAc1I,EAAOkR,EAAe/E,GAClC,IAAI9L,EAAmBN,EACrBC,EACAkR,EACA/E,GAOF,OAJoBtL,EAAoB2F,KAAK1F,IAAK,CAChDhB,IAAKO,EACLT,IAAKsR,Q,GAj3BazG,SCxBlB7F,EAAa,+BAIf8F,EAAM,IADGC,EAAQ,KAGfwG,EAAgB,SAACrM,GACrB,IAAIhE,EAAMiE,cAEJC,EAASC,SAASC,cAAc,UACtCF,EAAOG,UAAUC,IAAI,yBAErB,IAAIC,EAAI,IAAIC,EAAU,CAAExE,IAAKA,EAAKkE,OAAQA,IAG1C,OAFAlE,EAAIyE,SAASF,GAEN,MAEHC,E,kDACJ,WAAYR,GAAO,kCACjB,cAAMA,IAED+F,gBAAkB,EAAKA,gBAAgBC,KAArB,gBAEvB,EAAKpF,eAAiB,CACpBC,UAAU,EACVC,WAAW,EACXC,QAAS,GACTC,OAAQ,IACRC,MAAO,OACPqL,QAAS,UACTC,YAAa,CAAC,EAAG,GACjBrL,KAAM,mBACNC,UAAW,OACXC,UAAW,GACXoL,YAAa,EACbC,YAAa,GACbC,eAAe,EACfC,eAAe,GAGjB,EAAKrL,QAAWtB,GAASA,EAAMsB,SAAY,EAAKV,eAEhD,EAAK5E,IAAMgE,EAAMhE,IACjB,EAAKkE,OAASF,EAAME,OACpB,EAAK0M,SAAW,KAChB,EAAKC,iBAAmB,KA3BP,E,mDA8BnB,SAAgB7M,GACd0B,KAAKJ,QAAWtB,GAASA,EAAMsB,SAAYI,KAAKd,iB,mBAGlD,SAAM5E,GACJA,EAAIuF,OAAOC,YAAYC,YAAYC,KAAKxB,QACxClE,EAAI2F,GAAG,YAAaD,KAAKE,MAAOF,MAChC1F,EAAI2F,GAAG,OAAQD,KAAKE,MAAOF,MAE3BA,KAAKE,U,sBAGP,SAAS5F,GACPA,EAAIuF,OAAOC,YAAYK,YAAYH,KAAKxB,QACxClE,EAAI8F,IAAI,YAAaJ,KAAKE,MAAOF,MACjC1F,EAAI8F,IAAI,OAAQJ,KAAKE,MAAOF,MAE5BA,KAAKxB,OAAS,KACdwB,KAAK1F,IAAM,O,mBAGb,WACE,IAAM+F,EAAWL,KAAK1F,IAAIgG,UACpBC,EAAeP,KAAK1F,IAAIkG,2BAA2B,CAAC,EAAG,IAE7DR,KAAKxB,OAAOiC,aAAeF,EAE3BP,KAAKxB,OAAOkC,MAAZ,gCAEmBH,EAAazC,EAFhC,cAEuCyC,EAAavC,EAFpD,SAIAgC,KAAKxB,OAAOd,MAAQ2C,EAASvC,EAC7BkC,KAAKxB,OAAOmC,OAASN,EAASrC,EAE1BgC,KAAK1F,IAAIuG,UAAYb,KAAKJ,QAAQmL,YACpC/K,KAAKmL,iBAAmB,IACfnL,KAAK1F,IAAIuG,UAAYb,KAAKJ,QAAQkL,YAC3C9K,KAAKmL,iBAAmB,IAExBnL,KAAKmL,iBAAmB,KAG1BnL,KAAKoL,a,2BAOP,SAAcC,GAEZ,IAAIC,GAAUD,EAAU,IAAU,KAAM7O,WAMxC,OAJ8B,MAA1BwD,KAAKmL,kBAAwC,MAAVG,IACrCA,EAAQ,MAGHA,I,uBAGT,SAAUnO,EAAKoO,GACTA,GACFpO,EAAI+D,YAAYlB,KAAKJ,QAAQF,WAC7BvC,EAAI6D,UAAYhB,KAAKJ,QAAQN,OAAS,EACtCnC,EAAI8D,YAAcjB,KAAKJ,QAAQH,UAC/BtC,EAAI+E,SACJ/E,EAAI6D,UAAYhB,KAAKJ,QAAQN,OAC7BnC,EAAI8D,YAAcjB,KAAKJ,QAAQL,MAC/BpC,EAAI+E,WAEJ/E,EAAI6D,UAAYhB,KAAKJ,QAAQN,OAC7BnC,EAAI8D,YAAcjB,KAAKJ,QAAQgL,QAC/BzN,EAAI+D,YAAYlB,KAAKJ,QAAQiL,aAC7B1N,EAAI+E,Y,yBAIR,WACE,IAAM8C,EAAgB/J,YACpB,CACE+E,KAAK1F,IAAI2K,YAAYC,eAArB,IACAlF,KAAK1F,IAAI2K,YAAYC,eAArB,KAEF,GAEIC,EAAgBlK,YACpB,CACE+E,KAAK1F,IAAI2K,YAAYG,eAArB,IACApF,KAAK1F,IAAI2K,YAAYG,eAArB,KAEF,GAEIC,EAAgBpK,YACpB,CACE+E,KAAK1F,IAAI2K,YAAYK,eAArB,IACAtF,KAAK1F,IAAI2K,YAAYK,eAArB,KAEF,GAEIC,EAAgBtK,YACpB,CACE+E,KAAK1F,IAAI2K,YAAYO,eAArB,IACAxF,KAAK1F,IAAI2K,YAAYO,eAArB,KAEF,GAUF,OAPmB9J,EACjBsJ,EAAc5J,MAAMgD,GA3JR,GA4JZ+G,EAAc/J,MAAMgD,GA5JR,GA6JZiH,EAAcjK,MAAMgD,GA7JR,GA8JZmH,EAAcnK,MAAMgD,GA9JR,M,sBAoKhB,WAAW,WACT,GAAK4B,KAAKxB,QAAWwB,KAAK1F,OAItB0F,KAAK1F,IAAIuG,UAAYb,KAAKJ,QAAQkL,aAAtC,CAIA,IAAI3N,EAAM6C,KAAKxB,OAAOsC,WAAW,MACjC3D,EAAI4D,UAAU,EAAG,EAAGf,KAAKxB,OAAOd,MAAOsC,KAAKxB,OAAOmC,QACnDxD,EAAI6D,UAAYhB,KAAKJ,QAAQN,OAAS,IACtCnC,EAAI8D,YAAc,OAClB9D,EAAIc,UAAY+B,KAAKJ,QAAQL,MAC7BpC,EAAI+D,YAAYlB,KAAKJ,QAAQF,WAC7BvC,EAAIqC,KAAOQ,KAAKJ,QAAQJ,KACxB,IAAMgM,EAAexL,KAAK8E,cAEpBmE,EAAajJ,KAAK1F,IAAI2K,YAE5BuG,EAAatD,SAAQ,SAACC,EAAKsD,EAAUC,GACnC,IAAMC,EAAaxQ,iBAAOgN,GACpByD,EACJD,EAAU,SAAV,YAAsC,GAlM7B,GAIO,GA+LZE,EACJF,EAAU,SAAV,YAAsC,GAnM7B,GAGO,GAiMZG,EACJH,EAAU,SAAV,YAAsC,GAtM7B,GAGM,GAoMXI,EACJJ,EAAU,SAAV,YAAsC,GAzM7B,GAIM,GAuMbK,EACFJ,EAAoB3C,EAAWgD,UAC3BhD,EAAWgD,UACXL,EACFM,EACFL,EAAoB5C,EAAWkD,UAC3BlD,EAAWkD,UACXN,EACFO,EACFN,EAAqB7C,EAAWoD,WAC5BpD,EAAWoD,WACXP,EACFQ,EACFP,EAAqB9C,EAAWsD,WAC5BtD,EAAWsD,WACXR,EAEAtD,EAAS,KACTC,EAAgBxE,EAAIyE,mBACxB2D,EAA4B7D,EAC5BuD,EAA2BvD,EAC3B,GAEIK,EAAgB5E,EAAIyE,mBACxB2D,EAA4B7D,EAC5ByD,EAA2BzD,EAC3B,GAEIG,EAAgB1E,EAAIyE,mBACxByD,EAA6B3D,EAC7BuD,EAA2BvD,EAC3B,GAEII,EAAgB3E,EAAIyE,mBACxByD,EAA6B3D,EAC7ByD,EAA2BzD,EAC3B,GAIE+D,EAAkB9D,EAAcvB,QAChCsF,EAAe3D,EAAc3B,QAE7BuF,EAAmBhE,EAAczB,SACjC0F,EAAgB9D,EAAc5B,SAElCuF,EACEpF,KAAKY,MAAMwE,EAAkB,EAAKrB,kBAClC,EAAKA,iBACPsB,EACErF,KAAKY,MAAMyE,EAAe,EAAKtB,kBAC/B,EAAKA,iBACPuB,EACEtF,KAAKY,MAAM0E,EAAmB,EAAKvB,kBACnC,EAAKA,iBACPwB,EACEvF,KAAKC,KAAKsF,EAAgB,EAAKxB,kBAC/B,EAAKA,iBAGP,IADA,IAAI5G,EAAe,GAEbhI,EAAIiQ,EACRjQ,GAAKkQ,EACLlQ,GAAK,EAAK4O,iBAEV5G,EAAajI,KAAKC,GAIpB,IADA,IAAIiI,EAAgB,GAEdjI,EAAImQ,EACRnQ,GAAKoQ,EACLpQ,GAAK,EAAK4O,iBAEV3G,EAAclI,KAAKC,GAErB,IAAI8J,EAAauC,EAAcrB,WAC3BnB,EAAawC,EAActB,WAE/B/C,EAAa2D,SAAQ,SAACT,EAAamF,EAAcC,GAC/C,IAAIxC,GAAa,EAEjB7F,EAAc0D,SAAQ,SAACR,EAAcoF,EAAeC,GAClD,IAAI1C,EAAJ,CAGA,IAAI2C,EAAqB9I,EAAI+B,mBAC3BwB,EACAC,EACAtB,EACAC,GAEF,KACE2G,EAAmB5T,IAAMwS,GACzBoB,EAAmB5T,IAAMyS,GAF3B,CAQE,IAaEoB,EAdJ,GAAID,EAAmB1T,IAAMyS,EAO3BiB,EAAqBlS,EACnBkS,EAPuB9I,EAAI+B,mBAC3BwB,EACAsF,EAASD,EAAgB,GACzB1G,EACAC,GAKA,SAKJ,GAAI2G,EASJ,GAREC,EAAqB5S,EACnB,EAAKC,IACL0S,GAMkB,IAAlBF,EACF3P,EAAI4E,YACJ5E,EAAI6E,OAAOiL,EAAmBnP,EAAGmP,EAAmBjP,OAC/C,CAKL,GAJIgP,EAAmB5T,IAAMyS,IAC3BxB,GAAa,GAGX2C,EAAmB1T,IAAMwS,EAQ3BkB,EAAqBlS,EACnBkS,EAR2B9I,EAAI+B,mBAC/BwB,EACAsF,EAASD,EAAgB,GACzB1G,EACAC,GAMA,SAGF4G,EAAqB5S,EACnB,EAAKC,IACL0S,GAGJ7P,EAAI8E,OAAOgL,EAAmBnP,EAAGmP,EAAmBjP,SAIxD,IAAMkP,EAAazF,EAAc,MAAW,EAC5C,EAAK0F,UAAUhQ,EAAK+P,GAEpB,IAAIE,EAAclJ,EAAI+B,mBACpBwB,EACAjD,EAAc,GACd4B,EACAC,GAGF,GAAI+G,EAAYhU,IAAMwS,EACpB,IACE,IAAIyB,EAAchT,EAAoB,EAAKC,IAAK,CAC9ChB,IAAKgT,EACLlT,IAAKgU,EAAYhU,MAGfkS,EAAQ,EAAKgC,cAAc7F,GAC/BvK,EAAUC,EAAKmO,EAAO,EAAK1L,QAAQH,UAAW,EAAKG,QAAQL,MAAO,CAChEzB,EAAGuP,EAAYvP,EACfE,EAAGqP,EAAYrP,EAAI,KAErB,MAAOuP,QAKb/I,EAAc0D,SAAQ,SAACR,EAAcoF,EAAeC,GAClDxI,EAAa2D,SAAQ,SAACT,EAAamF,EAAcC,GAC/C,IAAIG,EAAqB9I,EAAI+B,mBAC3BwB,EACAC,EACAtB,EACAC,GAGE4G,EAAqB5S,EACvB,EAAKC,IACL0S,GAEF,GAAqB,IAAjBJ,EAAoB,CAGtB,GAFAzP,EAAI4E,YAEAiL,EAAmB5T,IAAMwS,EAAmB,CAC9C,IAAI4B,EAAqBtJ,EAAI+B,mBAC3B4G,EAAQD,EAAe,GACvBlF,EACAtB,EACAC,GAEF,IACE2G,EAAqBlS,EACnBkS,EACAQ,EACA,QAEFP,EAAqB5S,EACnB,EAAKC,IACL0S,GAEF,MAAOO,GACP,QAGJpQ,EAAI6E,OAAOiL,EAAmBnP,EAAGmP,EAAmBjP,QAC/C,GAAI4O,IAAiBC,EAAQjQ,OAAS,GAC3C,GAAIoQ,EAAmB5T,IAAMyS,EAAmB,CAC9C,IAOI4B,EAAoB3S,EACtBkS,EAR2B9I,EAAI+B,mBAC/B4G,EAAQD,EAAe,GACvBlF,EACAtB,EACAC,GAMA,QAGF4G,EAAqB5S,EACnB,EAAKC,IACLmT,GAGFtQ,EAAI8E,OAAOgL,EAAmBnP,EAAGmP,EAAmBjP,QAG/C,GAAIgP,EAAmB5T,IAAMyS,EAAmB,CACrD,IAOI4B,EAAoB3S,EAPKoJ,EAAI+B,mBAC/B4G,EAAQD,EAAe,GACvBG,EAASD,GACT1G,EACAC,GAKA2G,EACA,QAGFC,EAAqB5S,EACnB,EAAKC,IACLmT,GAGFtQ,EAAI8E,OAAOgL,EAAmBnP,EAAGmP,EAAmBjP,SAGtDb,EAAI8E,OAAOgL,EAAmBnP,EAAGmP,EAAmBjP,MAGxD,IAAMkP,EAAaxF,EAAe,MAAW,EAC7C,EAAKyF,UAAUhQ,EAAK+P,GAEpB,IACE,IAAIE,EAAclJ,EAAI+B,mBACpB1B,EAAaA,EAAa3H,OAAS,GACnC8K,EACAtB,EACAC,GAEEgH,EAAchT,EAAoB,EAAKC,IAAK,CAC9ChB,IAAK8T,EAAY9T,IACjBF,IAAK8S,IAGHZ,EAAQ,EAAKgC,cAAc5F,GAE/BxK,EAAUC,EAAKmO,EAAO,EAAK1L,QAAQH,UAAW,EAAKG,QAAQL,MAAO,CAChEzB,EAAGuP,EAAYvP,EAAI,GACnBE,EAAGqP,EAAYrP,IAEjB,MAAOuP,GACP,mB,GApdctJ,S,MCETyJ,MA7Bf,WACE,OACE,kBAACC,EAAA,EAAD,CACEC,OAAQ,CAAC,MAAO,MAChBC,KAAM,EACNlO,QAAS,EACT8E,QAAS,GACTqJ,cAAe,GACfC,UAAW,CACT,EAAE,IAAK,KACP,CAAC,GAAI,OAGP,kBAACC,EAAA,EAAD,CAMEC,IAAI,kGACJC,YAAY,8EAEd,kBAAC,EAAD,MACA,kBAAC,EAAD,MACA,kBAAC,EAAD,QC5BNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEF5P,SAAS6P,eAAe,W","file":"static/js/main.0931e6c9.chunk.js","sourcesContent":["import { getGZD } from \"gzd-utils\";\r\nimport { forward } from \"mgrs\";\r\n\r\n// The following indicies are used to indentify coordinates returned from gzd-utils\r\nconst SW_INDEX = 0;\r\nconst NW_INDEX = 1;\r\nconst NE_INDEX = 2;\r\n\r\nconst LONGITUDE_INDEX = 0;\r\nconst LATITUDE_INDEX = 1;\r\n\r\nconst TEN_K_MGRS_REGEX = /([0-9]+[A-Z])([A-Z]{2})([0-9]{2})/;\r\nconst GZD_INDEX = 1;\r\n/**\r\n *\r\n * @param {*} pointOne\r\n * @param {*} pointTwo\r\n */\r\nfunction getLineSlope(pointOne, pointTwo) {\r\n  if (pointOne === pointTwo) {\r\n    return 0;\r\n  } else if (pointOne.lng === pointTwo.lng) {\r\n    return NaN;\r\n  } else {\r\n    return (pointTwo.lat - pointOne.lat) / (pointTwo.lng - pointOne.lng);\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * @param {*} slope\r\n * @param {*} adjustedLongitude\r\n * @param {*} unadjustedLatLong\r\n */\r\nfunction getAdjustedLatitude(slope, adjustedLongitude, unadjustedLatLong) {\r\n  let result;\r\n  if (!isNaN(slope)) {\r\n    result =\r\n      unadjustedLatLong.lat +\r\n      slope * (adjustedLongitude - unadjustedLatLong.lng);\r\n  } else {\r\n    result = unadjustedLatLong.lat;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n *\r\n * @param {*} slope\r\n * @param {*} adjustedLongitude\r\n * @param {*} unadjustedLatLong\r\n */\r\nfunction getAdjustedLongitude(slope, adjustedLatitude, unadjustedLatLong) {\r\n  let result;\r\n  if (slope === 0) {\r\n    const e = new Error(\"getAdjustedLongitude: Zero slope received\");\r\n    throw e;\r\n  } else if (!isNaN(slope)) {\r\n    result =\r\n      (adjustedLatitude -\r\n        unadjustedLatLong.lat +\r\n        slope * unadjustedLatLong.lng) /\r\n      slope;\r\n  } else {\r\n    result = unadjustedLatLong.lng;\r\n  }\r\n\r\n  return result;\r\n}\r\n/**\r\n *\r\n * @param {string} char\r\n */\r\nfunction getNextMgrsGzdCharacter(char) {\r\n  // I and O are not valid characters for MGRS, so get the next\r\n  // character recursively\r\n  const result = String.fromCharCode(char.charCodeAt(0) + 1);\r\n  if (result === \"I\" || result === \"O\") {\r\n    return getNextMgrsGzdCharacter(result);\r\n  } else {\r\n    return result;\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * @param {Object} map\r\n * @param {Dict} latLng\r\n */\r\nfunction latLngToCanvasPoint(map, latLng) {\r\n  const projectedPoint = map.project(latLng);\r\n  projectedPoint._subtract(map.getPixelOrigin());\r\n  projectedPoint._add(map._getMapPanePos());\r\n  return projectedPoint;\r\n}\r\n\r\n/**\r\n * Given two points and a direction, will return a new point along the\r\n * line generated by pointOne and pointTwo which rests on the GZD boundary\r\n * @param {Dict} pointOne\r\n * @param {Dict} pointTwo\r\n * @param {String} direction\r\n */\r\nfunction connectToGzdBoundary(pointOne, pointTwo, direction) {\r\n  const slope = getLineSlope(pointOne, pointTwo);\r\n  // 10k mgrs resolution grid - e.g. 18TVR90\r\n  const grid = forward([pointOne.lng, pointOne.lat], 1);\r\n  let adjustedLongitude;\r\n  let adjustedLatitude;\r\n\r\n  switch (direction) {\r\n    case \"East\":\r\n      const gzdEastLongitude = getGZD(grid.match(TEN_K_MGRS_REGEX)[GZD_INDEX])\r\n        .geometry.coordinates[0][NE_INDEX][LONGITUDE_INDEX];\r\n\r\n      adjustedLatitude = getAdjustedLatitude(slope, gzdEastLongitude, pointTwo);\r\n      adjustedLongitude = gzdEastLongitude;\r\n\r\n      return { lat: adjustedLatitude, lng: adjustedLongitude };\r\n\r\n    case \"West\":\r\n      const gzdWestLongitude = getGZD(grid.match(TEN_K_MGRS_REGEX)[GZD_INDEX])\r\n        .geometry.coordinates[0][NW_INDEX][LONGITUDE_INDEX];\r\n\r\n      adjustedLatitude = getAdjustedLatitude(slope, gzdWestLongitude, pointTwo);\r\n\r\n      adjustedLongitude = gzdWestLongitude;\r\n      return { lat: adjustedLatitude, lng: adjustedLongitude };\r\n    case \"North\":\r\n      const gzdNorthLatitude = getGZD(grid.match(TEN_K_MGRS_REGEX)[GZD_INDEX])\r\n        .geometry.coordinates[0][NW_INDEX][LATITUDE_INDEX];\r\n\r\n      adjustedLongitude = getAdjustedLongitude(\r\n        slope,\r\n        gzdNorthLatitude,\r\n        pointTwo\r\n      );\r\n\r\n      // Handle a special case where the west most 100k easting line in the 32V GZD extends\r\n      // west of the boundary\r\n      const WEST_LNG_32V_BOUNDARY = 3;\r\n      if (\r\n        grid.match(TEN_K_MGRS_REGEX)[GZD_INDEX] === \"31V\" &&\r\n        adjustedLongitude < WEST_LNG_32V_BOUNDARY &&\r\n        pointTwo.lng > WEST_LNG_32V_BOUNDARY\r\n      ) {\r\n        adjustedLatitude = getAdjustedLatitude(\r\n          slope,\r\n          WEST_LNG_32V_BOUNDARY,\r\n          pointTwo\r\n        );\r\n        adjustedLongitude = WEST_LNG_32V_BOUNDARY;\r\n      } else {\r\n        adjustedLatitude = gzdNorthLatitude;\r\n      }\r\n\r\n      return { lat: adjustedLatitude, lng: adjustedLongitude };\r\n\r\n    case \"South\":\r\n      const gzdSouthLatitude = getGZD(grid.match(TEN_K_MGRS_REGEX)[GZD_INDEX])\r\n        .geometry.coordinates[0][SW_INDEX][LATITUDE_INDEX];\r\n\r\n      adjustedLongitude = getAdjustedLongitude(\r\n        slope,\r\n        gzdSouthLatitude,\r\n        pointTwo\r\n      );\r\n\r\n      adjustedLatitude = gzdSouthLatitude;\r\n      return { lat: adjustedLatitude, lng: adjustedLongitude };\r\n\r\n    default:\r\n      // TODO - lat/lng are undefined if we use this return statement\r\n      return { lat: adjustedLatitude, lng: adjustedLongitude };\r\n  }\r\n}\r\n\r\n// TODO - REFACTOR HACK\r\nfunction getAllVisibleGzds(nwGzd, neGzd, seGzd, swGzd) {\r\n  const GZD_REGEX = /([0-9]+)([A-Z])/;\r\n  const LONGITUDE_BAND_INDEX = 1;\r\n  const LATITUDE_BAND_INDEX = 2;\r\n\r\n  // Short circuit\r\n  if (nwGzd === seGzd) {\r\n    return [nwGzd];\r\n  }\r\n  const NW_LONGITUDE_BAND = parseInt(\r\n    nwGzd.match(GZD_REGEX)[LONGITUDE_BAND_INDEX]\r\n  );\r\n  const NW_LATITUDE_BAND = nwGzd.match(GZD_REGEX)[LATITUDE_BAND_INDEX];\r\n\r\n  const NE_LONGITUDE_BAND = parseInt(\r\n    neGzd.match(GZD_REGEX)[LONGITUDE_BAND_INDEX]\r\n  );\r\n\r\n  const SW_LATITUDE_BAND = swGzd.match(GZD_REGEX)[LATITUDE_BAND_INDEX];\r\n\r\n  let result = [];\r\n\r\n  const longitudeBands = []; // container for the formatted GZDs\r\n\r\n  // If the NW GZD is 32V then also include the relevant 31 series GZDs below it\r\n  // This ensures that grids are displayed (since 32V is larger at the expense of 31V)\r\n  if (nwGzd === \"32V\") {\r\n    longitudeBands.push(\"31\");\r\n  }\r\n\r\n  // We span at least two vertical bands\r\n  if (NW_LONGITUDE_BAND !== NE_LONGITUDE_BAND) {\r\n    for (let i = NW_LONGITUDE_BAND; i <= NE_LONGITUDE_BAND; i++) {\r\n      longitudeBands.push(i.toString());\r\n    }\r\n    if (NW_LATITUDE_BAND !== SW_LATITUDE_BAND) {\r\n      const INITIAL_LONGITUDE_BAND = [...longitudeBands];\r\n\r\n      let currentLatitudeBand = SW_LATITUDE_BAND;\r\n      while (currentLatitudeBand <= NW_LATITUDE_BAND) {\r\n        const len = INITIAL_LONGITUDE_BAND.length;\r\n\r\n        for (let i = 0; i < len; i++) {\r\n          result.push(INITIAL_LONGITUDE_BAND[i] + currentLatitudeBand);\r\n        }\r\n\r\n        currentLatitudeBand = getNextMgrsGzdCharacter(currentLatitudeBand);\r\n      }\r\n\r\n      result = result.flat();\r\n    } else {\r\n      // Append the alpha character to the array of GZDs\r\n      const len = longitudeBands.length;\r\n      for (let i = 0; i < len; i++) {\r\n        longitudeBands[i] = longitudeBands[i].toString() + NW_LATITUDE_BAND;\r\n      }\r\n      result = longitudeBands;\r\n    }\r\n  } else {\r\n    // We span a single vertical band\r\n    let currentLatitudeBand = SW_LATITUDE_BAND;\r\n    const longitudeBand = []; // Container for the formatted GZDs\r\n\r\n    while (currentLatitudeBand <= NW_LATITUDE_BAND) {\r\n      longitudeBand.push(NW_LONGITUDE_BAND.toString() + currentLatitudeBand);\r\n\r\n      currentLatitudeBand = getNextMgrsGzdCharacter(currentLatitudeBand);\r\n    }\r\n    result = longitudeBand;\r\n  }\r\n  // Remove non-existant X series GZDs around Svalbard\r\n  result = result.filter(function (a) {\r\n    return a !== \"32X\" && a !== \"34X\" && a !== \"36X\";\r\n  });\r\n\r\n  // Add 32V if 31W is visible\r\n  // This ensures that grids are displayed (since 32V is larger at the expense of 31V)\r\n  if (result.includes(\"31W\") && !result.includes(\"32V\")) {\r\n    result.push(\"32V\");\r\n  }\r\n\r\n  // Handles a special case where 32V can be the NW and NE GZD, but the algorithm\r\n  // doesn't show the 31U GZD\r\n  if (neGzd === \"32V\" && seGzd === \"32U\" && !result.includes(\"31U\")) {\r\n    result.push(\"31U\");\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction drawLabel(ctx, labelText, textColor, backgroundColor, labelPosition) {\r\n  const TEXT_WIDTH = ctx.measureText(labelText).width;\r\n  const TEXT_HEIGHT = ctx.measureText(labelText).fontBoundingBoxAscent;\r\n\r\n  // Calculate label xy position\r\n  const LABEL_X = labelPosition.x;\r\n  const LABEL_Y = labelPosition.y;\r\n\r\n  ctx.fillStyle = backgroundColor;\r\n  // Magic numbers will centre the rectangle over the text\r\n  ctx.fillRect(\r\n    LABEL_X - TEXT_WIDTH / 2 - 1,\r\n    LABEL_Y - TEXT_HEIGHT + 1,\r\n    TEXT_WIDTH + 3,\r\n    TEXT_HEIGHT + 2\r\n  );\r\n  ctx.fillStyle = textColor;\r\n  ctx.fillText(labelText, LABEL_X - TEXT_WIDTH / 2, LABEL_Y);\r\n}\r\n\r\nexport {\r\n  connectToGzdBoundary,\r\n  drawLabel,\r\n  getAdjustedLatitude,\r\n  getAdjustedLongitude,\r\n  getAllVisibleGzds,\r\n  getLineSlope,\r\n  getNextMgrsGzdCharacter,\r\n  latLngToCanvasPoint,\r\n};\r\n","import { Layer } from \"leaflet\";\r\nimport { useMap } from \"react-leaflet\";\r\nimport { forward } from \"mgrs\";\r\nimport { drawLabel, latLngToCanvasPoint } from \"./CommonUtils\";\r\n\r\nconst MGRS_REGEX = /([0-9]+[A-Z])([A-Z]{2})(\\d+)/;\r\nconst GZD_INDEX = 1;\r\n\r\nconst GzdGraticule = (props) => {\r\n  let map = useMap();\r\n\r\n  const canvas = document.createElement(\"canvas\");\r\n  canvas.classList.add(\"leaflet-zoom-animated\");\r\n\r\n  let g = new Graticule({ map: map, canvas: canvas });\r\n  map.addLayer(g);\r\n\r\n  return null;\r\n};\r\n\r\nclass Graticule extends Layer {\r\n  constructor(props) {\r\n    super(props);\r\n    this.currLatInterval = 8;\r\n    this.currLngInterval = 6;\r\n\r\n    this.defaultOptions = {\r\n      showGrid: true,\r\n      showLabel: true,\r\n      opacity: 10,\r\n      weight: 3,\r\n      color: \"#888888\",\r\n      font: \"14px Courier New\",\r\n      fontColor: \"#FFF\",\r\n      dashArray: [6, 6],\r\n      minZoom: 3,\r\n    };\r\n\r\n    this.map = props.map;\r\n    this.canvas = props.canvas;\r\n\r\n    this.options = (props && props.options) || this.defaultOptions;\r\n  }\r\n\r\n  onAdd(map) {\r\n    map._panes.overlayPane.appendChild(this.canvas);\r\n    map.on(\"viewreset\", this.reset, this);\r\n    map.on(\"move\", this.reset, this);\r\n\r\n    this.reset();\r\n  }\r\n\r\n  onRemove(map) {\r\n    map._panes.overlayPane.removeChild(this.canvas);\r\n    map.off(\"viewreset\", this.reset, this);\r\n    map.off(\"move\", this.reset, this);\r\n\r\n    this.canvas = null;\r\n    this.map = null;\r\n  }\r\n\r\n  reset() {\r\n    const MAP_SIZE = this.map.getSize();\r\n    const MAP_LEFT_TOP = this.map.containerPointToLayerPoint([0, 0]);\r\n\r\n    this.canvas._leaflet_pos = MAP_LEFT_TOP;\r\n\r\n    this.canvas.style[\r\n      \"transform\"\r\n    ] = `translate3d(${MAP_LEFT_TOP.x}px,${MAP_LEFT_TOP.y}px,0)`;\r\n\r\n    this.canvas.width = MAP_SIZE.x;\r\n    this.canvas.height = MAP_SIZE.y;\r\n\r\n    this.drawGzd();\r\n  }\r\n\r\n  drawGzd() {\r\n    if (!this.canvas || !this.map) {\r\n      return;\r\n    }\r\n\r\n    if (this.map.getZoom() < this.options.minZoom) {\r\n      return;\r\n    }\r\n\r\n    let ctx = this.canvas.getContext(\"2d\");\r\n    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n    ctx.lineWidth = this.options.weight;\r\n    ctx.strokeStyle = this.options.color;\r\n    ctx.fillStyle = this.options.color;\r\n    ctx.setLineDash(this.options.dashArray);\r\n    if (this.options.font) {\r\n      ctx.font = this.options.font;\r\n    }\r\n\r\n    let leftTop = this.map.containerPointToLatLng({ x: 0, y: 0 });\r\n    let rightBottom = this.map.containerPointToLatLng({\r\n      x: this.canvas.width,\r\n      y: this.canvas.height,\r\n    });\r\n\r\n    let pointPerLat =\r\n      (leftTop.lat - rightBottom.lat) / (this.canvas.height * 0.2);\r\n    let pointPerLon =\r\n      (rightBottom.lng - leftTop.lng) / (this.canvas.width * 0.2);\r\n\r\n    if (isNaN(pointPerLat) || isNaN(pointPerLon)) {\r\n      return;\r\n    }\r\n\r\n    if (pointPerLat < 1) {\r\n      pointPerLat = 1;\r\n    }\r\n    if (pointPerLon < 1) {\r\n      pointPerLon = 1;\r\n    }\r\n\r\n    if (rightBottom.lat < -90) {\r\n      rightBottom.lat = -90;\r\n    } else {\r\n      rightBottom.lat = parseInt(rightBottom.lat - pointPerLat, 10);\r\n    }\r\n\r\n    if (leftTop.lat > 90) {\r\n      leftTop.lat = 90;\r\n    } else {\r\n      leftTop.lat = parseInt(leftTop.lat + pointPerLat, 10);\r\n    }\r\n\r\n    if (leftTop.lng > 0 && rightBottom.lng < 0) {\r\n      rightBottom.lng += 360;\r\n    }\r\n    rightBottom.lng = parseInt(rightBottom.lng + pointPerLon, 10);\r\n    leftTop.lng = parseInt(leftTop.lng - pointPerLon, 10);\r\n\r\n    // Northern hemisphere\r\n    for (\r\n      let i = this.currLatInterval;\r\n      i <= leftTop.lat;\r\n      i += this.currLatInterval\r\n    ) {\r\n      if (i >= rightBottom.lat) {\r\n        // Handle 'X' MGRS Zone - Do not need it for the southern equivalent 'C'\r\n        if (i === 80) {\r\n          i = 84;\r\n        }\r\n        this.drawLatitudeLine(ctx, i, leftTop.lng, rightBottom.lng);\r\n      }\r\n    }\r\n\r\n    // Southern hemisphere\r\n    for (let i = 0; i >= rightBottom.lat; i -= this.currLatInterval) {\r\n      if (i <= leftTop.lat) {\r\n        this.drawLatitudeLine(ctx, i, leftTop.lng, rightBottom.lng);\r\n      }\r\n    }\r\n\r\n    // Northern hemisphere\r\n    // HACK - Add six to the right bottom lng to make sure the East 31V boundary is displayed at all times\r\n    for (\r\n      let i = this.currLngInterval;\r\n      i <= rightBottom.lng + 6;\r\n      i += this.currLngInterval\r\n    ) {\r\n      if (i >= leftTop.lng) {\r\n        this.drawLongitudeLine(ctx, i, leftTop.lat, rightBottom.lat);\r\n      }\r\n    }\r\n\r\n    // Southern hemisphere\r\n    for (let i = 0; i >= leftTop.lng; i -= this.currLngInterval) {\r\n      if (i <= rightBottom.lng) {\r\n        this.drawLongitudeLine(ctx, i, leftTop.lat, rightBottom.lat);\r\n      }\r\n    }\r\n  }\r\n\r\n  drawLatitudeLine(ctx, tick, lngLeft, lngRight) {\r\n    const LEFT_END = latLngToCanvasPoint(this.map, { lat: tick, lng: lngLeft });\r\n\r\n    const RIGHT_END = latLngToCanvasPoint(this.map, {\r\n      lat: tick,\r\n      lng: lngRight,\r\n    });\r\n\r\n    ctx.beginPath();\r\n    ctx.moveTo(LEFT_END.x, LEFT_END.y);\r\n    ctx.lineTo(RIGHT_END.x, RIGHT_END.y);\r\n    ctx.stroke();\r\n  }\r\n\r\n  drawLongitudeLine(ctx, tick, latTop, latBottom) {\r\n    if (latTop >= 84) {\r\n      latTop = 84; // Ensure GZD vertical lines do not extend into the arctic\r\n    }\r\n\r\n    if (latBottom <= -80) {\r\n      latBottom = -80; // Ensure GZD vertical lines do not extend into the antarctic\r\n    }\r\n\r\n    const CANVAS_TOP = latLngToCanvasPoint(this.map, {\r\n      lat: latTop,\r\n      lng: tick,\r\n    });\r\n\r\n    const CANVAS_BOTTOM = latLngToCanvasPoint(this.map, {\r\n      lat: latBottom,\r\n      lng: tick,\r\n    });\r\n\r\n    const TOP_OF_W_SERIES_GZD = 72;\r\n\r\n    ctx.beginPath();\r\n    // Handle Norway\r\n    if (tick === 6) {\r\n      const TOP_OF_V_SERIES_GZD = 64;\r\n      const BOTTOM_OF_V_SERIES_GZD = 56;\r\n      const RIGHT_OF_31_SERIES_GZD = 3;\r\n\r\n      const RIGHT_TOP_OF_GZD = latLngToCanvasPoint(this.map, {\r\n        lat: TOP_OF_V_SERIES_GZD,\r\n        lng: tick,\r\n      });\r\n\r\n      const LEFT_TOP_OF_GZD = latLngToCanvasPoint(this.map, {\r\n        lat: TOP_OF_V_SERIES_GZD,\r\n        lng: RIGHT_OF_31_SERIES_GZD,\r\n      });\r\n\r\n      const LEFT_BOTTOM_OF_GZD = latLngToCanvasPoint(this.map, {\r\n        lat: BOTTOM_OF_V_SERIES_GZD,\r\n        lng: RIGHT_OF_31_SERIES_GZD,\r\n      });\r\n\r\n      const RIGHT_BOTTOM_OF_GZD = latLngToCanvasPoint(this.map, {\r\n        lat: BOTTOM_OF_V_SERIES_GZD,\r\n        lng: tick,\r\n      });\r\n      if (latTop > TOP_OF_V_SERIES_GZD && latBottom > BOTTOM_OF_V_SERIES_GZD) {\r\n        // Top segment only\r\n        // Do not draw through Svalbard\r\n        if (latTop > TOP_OF_W_SERIES_GZD) {\r\n          const TOP_LEFT_OF_32_SERIES_GZD = latLngToCanvasPoint(this.map, {\r\n            lat: TOP_OF_W_SERIES_GZD,\r\n            lng: tick,\r\n          });\r\n          ctx.moveTo(TOP_LEFT_OF_32_SERIES_GZD.x, TOP_LEFT_OF_32_SERIES_GZD.y);\r\n        } else {\r\n          ctx.moveTo(CANVAS_TOP.x, CANVAS_TOP.y);\r\n        }\r\n\r\n        ctx.lineTo(RIGHT_TOP_OF_GZD.x, RIGHT_TOP_OF_GZD.y);\r\n\r\n        ctx.moveTo(LEFT_TOP_OF_GZD.x, LEFT_TOP_OF_GZD.y);\r\n\r\n        ctx.lineTo(LEFT_TOP_OF_GZD.x, CANVAS_BOTTOM.y);\r\n      } else if (\r\n        //Bottom segment only\r\n        latTop < TOP_OF_V_SERIES_GZD &&\r\n        latBottom < BOTTOM_OF_V_SERIES_GZD\r\n      ) {\r\n        ctx.moveTo(LEFT_TOP_OF_GZD.x, CANVAS_TOP.y);\r\n\r\n        ctx.lineTo(LEFT_BOTTOM_OF_GZD.x, LEFT_BOTTOM_OF_GZD.y);\r\n\r\n        ctx.moveTo(RIGHT_BOTTOM_OF_GZD.x, RIGHT_BOTTOM_OF_GZD.y);\r\n\r\n        ctx.lineTo(RIGHT_BOTTOM_OF_GZD.x, CANVAS_BOTTOM.y);\r\n      } else if (\r\n        // Entire thing\r\n        latTop >= TOP_OF_V_SERIES_GZD &&\r\n        latBottom <= BOTTOM_OF_V_SERIES_GZD\r\n      ) {\r\n        // Do not draw through Svalbard\r\n        if (latTop > TOP_OF_W_SERIES_GZD) {\r\n          const TOP_LEFT_OF_32_SERIES_GZD = latLngToCanvasPoint(this.map, {\r\n            lat: TOP_OF_W_SERIES_GZD,\r\n            lng: tick,\r\n          });\r\n          ctx.moveTo(TOP_LEFT_OF_32_SERIES_GZD.x, TOP_LEFT_OF_32_SERIES_GZD.y);\r\n        } else {\r\n          ctx.moveTo(CANVAS_TOP.x, CANVAS_TOP.y);\r\n        }\r\n\r\n        ctx.lineTo(RIGHT_TOP_OF_GZD.x, RIGHT_TOP_OF_GZD.y);\r\n\r\n        ctx.moveTo(LEFT_TOP_OF_GZD.x, LEFT_TOP_OF_GZD.y);\r\n\r\n        ctx.lineTo(LEFT_BOTTOM_OF_GZD.x, LEFT_BOTTOM_OF_GZD.y);\r\n\r\n        ctx.moveTo(RIGHT_TOP_OF_GZD.x, LEFT_BOTTOM_OF_GZD.y);\r\n\r\n        ctx.lineTo(RIGHT_TOP_OF_GZD.x, CANVAS_BOTTOM.y);\r\n      } else if (\r\n        // Modified vertical only\r\n        latTop <= TOP_OF_V_SERIES_GZD &&\r\n        latBottom >= BOTTOM_OF_V_SERIES_GZD\r\n      ) {\r\n        ctx.moveTo(LEFT_TOP_OF_GZD.x, CANVAS_TOP.y);\r\n\r\n        ctx.lineTo(LEFT_BOTTOM_OF_GZD.x, CANVAS_BOTTOM.y);\r\n      }\r\n    } else if (tick === 12) {\r\n      if (latTop > TOP_OF_W_SERIES_GZD && latTop <= 84) {\r\n        // Handle Svalbard\r\n        const TOP_LEFT_OF_33X_GZD = latLngToCanvasPoint(this.map, {\r\n          lat: latTop,\r\n          lng: 9,\r\n        });\r\n        ctx.moveTo(TOP_LEFT_OF_33X_GZD.x, TOP_LEFT_OF_33X_GZD.y);\r\n\r\n        const BOTTOM_LEFT_OF_33X_GZD = latLngToCanvasPoint(this.map, {\r\n          lat: TOP_OF_W_SERIES_GZD,\r\n          lng: 9,\r\n        });\r\n\r\n        ctx.lineTo(BOTTOM_LEFT_OF_33X_GZD.x, BOTTOM_LEFT_OF_33X_GZD.y);\r\n\r\n        const TOP_RIGHT_OF_32W_GZD = latLngToCanvasPoint(this.map, {\r\n          lat: TOP_OF_W_SERIES_GZD,\r\n          lng: tick,\r\n        });\r\n\r\n        ctx.moveTo(TOP_RIGHT_OF_32W_GZD.x, TOP_RIGHT_OF_32W_GZD.y);\r\n\r\n        ctx.lineTo(CANVAS_BOTTOM.x, CANVAS_BOTTOM.y);\r\n      } else {\r\n        // Normal use case\r\n        ctx.moveTo(CANVAS_TOP.x, CANVAS_TOP.y);\r\n        ctx.lineTo(CANVAS_BOTTOM.x, CANVAS_BOTTOM.y);\r\n      }\r\n    } else if (tick === 18) {\r\n      // Do not draw through Svalbard\r\n      if (latTop > TOP_OF_W_SERIES_GZD) {\r\n        const TOP_LEFT_OF_34_SERIES_GZD = latLngToCanvasPoint(this.map, {\r\n          lat: TOP_OF_W_SERIES_GZD,\r\n          lng: tick,\r\n        });\r\n        ctx.moveTo(TOP_LEFT_OF_34_SERIES_GZD.x, TOP_LEFT_OF_34_SERIES_GZD.y);\r\n      } else {\r\n        ctx.moveTo(CANVAS_TOP.x, CANVAS_TOP.y);\r\n      }\r\n      ctx.lineTo(CANVAS_BOTTOM.x, CANVAS_BOTTOM.y);\r\n    } else if (tick === 24) {\r\n      if (latTop > TOP_OF_W_SERIES_GZD && latTop <= 84) {\r\n        // Handle Svalbard\r\n        const TOP_LEFT_OF_35X_GZD = latLngToCanvasPoint(this.map, {\r\n          lat: latTop,\r\n          lng: 21,\r\n        });\r\n        ctx.moveTo(TOP_LEFT_OF_35X_GZD.x, TOP_LEFT_OF_35X_GZD.y);\r\n\r\n        const BOTTOM_LEFT_OF_35X_GZD = latLngToCanvasPoint(this.map, {\r\n          lat: TOP_OF_W_SERIES_GZD,\r\n          lng: 21,\r\n        });\r\n\r\n        ctx.lineTo(BOTTOM_LEFT_OF_35X_GZD.x, BOTTOM_LEFT_OF_35X_GZD.y);\r\n\r\n        const TOP_RIGHT_OF_34W_GZD = latLngToCanvasPoint(this.map, {\r\n          lat: TOP_OF_W_SERIES_GZD,\r\n          lng: tick,\r\n        });\r\n\r\n        ctx.moveTo(TOP_RIGHT_OF_34W_GZD.x, TOP_RIGHT_OF_34W_GZD.y);\r\n\r\n        ctx.lineTo(CANVAS_BOTTOM.x, CANVAS_BOTTOM.y);\r\n      } else {\r\n        // Normal use case\r\n        ctx.moveTo(CANVAS_TOP.x, CANVAS_TOP.y);\r\n        ctx.lineTo(CANVAS_BOTTOM.x, CANVAS_BOTTOM.y);\r\n      }\r\n    } else if (tick === 30) {\r\n      // Do not draw through Svalbard\r\n      if (latTop > TOP_OF_W_SERIES_GZD) {\r\n        const TOP_LEFT_OF_35_SERIES_GZD = latLngToCanvasPoint(this.map, {\r\n          lat: TOP_OF_W_SERIES_GZD,\r\n          lng: tick,\r\n        });\r\n        ctx.moveTo(TOP_LEFT_OF_35_SERIES_GZD.x, TOP_LEFT_OF_35_SERIES_GZD.y);\r\n      } else {\r\n        ctx.moveTo(CANVAS_TOP.x, CANVAS_TOP.y);\r\n      }\r\n      ctx.lineTo(CANVAS_BOTTOM.x, CANVAS_BOTTOM.y);\r\n    } else if (tick === 36) {\r\n      if (latTop > TOP_OF_W_SERIES_GZD && latTop <= 84) {\r\n        // Handle Svalbard\r\n        const TOP_LEFT_OF_37X_GZD = latLngToCanvasPoint(this.map, {\r\n          lat: latTop,\r\n          lng: 33,\r\n        });\r\n        ctx.moveTo(TOP_LEFT_OF_37X_GZD.x, TOP_LEFT_OF_37X_GZD.y);\r\n\r\n        const BOTTOM_LEFT_OF_37X_GZD = latLngToCanvasPoint(this.map, {\r\n          lat: TOP_OF_W_SERIES_GZD,\r\n          lng: 33,\r\n        });\r\n\r\n        ctx.lineTo(BOTTOM_LEFT_OF_37X_GZD.x, BOTTOM_LEFT_OF_37X_GZD.y);\r\n\r\n        const TOP_RIGHT_OF_36W_GZD = latLngToCanvasPoint(this.map, {\r\n          lat: TOP_OF_W_SERIES_GZD,\r\n          lng: tick,\r\n        });\r\n\r\n        ctx.moveTo(TOP_RIGHT_OF_36W_GZD.x, TOP_RIGHT_OF_36W_GZD.y);\r\n\r\n        ctx.lineTo(CANVAS_BOTTOM.x, CANVAS_BOTTOM.y);\r\n      } else {\r\n        // Normal use case\r\n        ctx.moveTo(CANVAS_TOP.x, CANVAS_TOP.y);\r\n        ctx.lineTo(CANVAS_BOTTOM.x, CANVAS_BOTTOM.y);\r\n      }\r\n    }\r\n    // The rest of the world...\r\n    else {\r\n      ctx.moveTo(CANVAS_TOP.x, CANVAS_TOP.y);\r\n      ctx.lineTo(CANVAS_BOTTOM.x, CANVAS_BOTTOM.y);\r\n    }\r\n    ctx.stroke();\r\n\r\n    this.drawGzdLabels(ctx, tick);\r\n  }\r\n\r\n  /** This function encapsulates drawing labels for GZDs\r\n   *\r\n   * @param {Obj} ctx - The HTML5 canvas' context\r\n   * @param {Int} longitude - The longitude (representing a boundary of a GZD) for which needs labels drawn for\r\n   */\r\n  drawGzdLabels(ctx, longitude) {\r\n    // -76 = middle latitude of the 'C' band - place the label in the middle\r\n    for (let labelLatitude = -76; labelLatitude < 84; labelLatitude += 8) {\r\n      let labelLongitude;\r\n      if (labelLatitude === 60) {\r\n        if (longitude === 0) {\r\n          //31V\r\n          labelLongitude = 1.5;\r\n        } else if (longitude === 6) {\r\n          //32V\r\n          labelLongitude = 7.5;\r\n        } else {\r\n          labelLongitude = longitude + 3;\r\n        }\r\n      } else if (labelLatitude === 76) {\r\n        if (longitude === 0) {\r\n          //31X\r\n          labelLongitude = 4.5;\r\n        } else if (longitude === 12) {\r\n          //33X\r\n          labelLongitude = 15;\r\n        } else if (longitude === 24) {\r\n          //35X\r\n          labelLongitude = 27;\r\n        } else if (longitude === 36) {\r\n          //37X\r\n          labelLongitude = 37.5;\r\n        } else {\r\n          labelLongitude = longitude + 3;\r\n        }\r\n      } else {\r\n        // Rest of the world...\r\n        labelLongitude = longitude + 3;\r\n      }\r\n\r\n      let gzdLabel;\r\n      try {\r\n        gzdLabel = forward([labelLongitude, labelLatitude], 1).match(\r\n          MGRS_REGEX\r\n        )[GZD_INDEX];\r\n      } catch (error) {\r\n        return; //Invalid MGRS value returned, so no need to try to display a label\r\n      }\r\n\r\n      // TODO - MORE MAGIC NUMBERS!!! - Don't want to display duplicates of the following zones\r\n      if (\r\n        !(gzdLabel === \"33X\" && longitude === 6) &&\r\n        !(gzdLabel === \"35X\" && longitude === 18) &&\r\n        !(gzdLabel === \"37X\" && longitude === 30)\r\n      ) {\r\n        const LABEL_XY = latLngToCanvasPoint(this.map, {\r\n          lat: labelLatitude,\r\n          lng: labelLongitude,\r\n        });\r\n\r\n        drawLabel(\r\n          ctx,\r\n          gzdLabel,\r\n          this.options.fontColor,\r\n          this.options.color,\r\n          LABEL_XY\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport { GzdGraticule };\r\n","import { Layer } from \"leaflet\";\r\nimport { useMap } from \"react-leaflet\";\r\nimport { forward } from \"mgrs\";\r\n\r\nimport {\r\n  connectToGzdBoundary,\r\n  drawLabel,\r\n  getAdjustedLatitude,\r\n  getAllVisibleGzds,\r\n  getLineSlope,\r\n  latLngToCanvasPoint,\r\n} from \"./CommonUtils\";\r\n\r\nimport { getGZD } from \"gzd-utils\";\r\n\r\n// The following indicies are used to indentify coordinates returned from gzd-utils\r\nconst SW_INDEX = 0;\r\nconst NW_INDEX = 1;\r\nconst NE_INDEX = 2;\r\nconst SE_INDEX = 3;\r\n\r\nconst LATITUDE_INDEX = 1;\r\nconst LONGITUDE_INDEX = 0;\r\n\r\nconst MGRS_REGEX = /([0-9]+[A-Z])([A-Z]{2})(\\d+)/;\r\nconst GZD_INDEX = 1; //The group index for the 100k identifier in the regex above\r\nconst HK_INDEX = 2;\r\n\r\nvar utmObj = require(\"utm-latlng\");\r\nvar utm = new utmObj(); // Defaults to WGS-84\r\n\r\nconst HundredKGraticule = (props) => {\r\n  let map = useMap();\r\n\r\n  const canvas = document.createElement(\"canvas\");\r\n  canvas.classList.add(\"leaflet-zoom-animated\");\r\n\r\n  let g = new Graticule({ map: map, canvas: canvas });\r\n  map.addLayer(g);\r\n\r\n  return null;\r\n};\r\n\r\nclass Graticule extends Layer {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    this.updateVariables = this.updateVariables.bind(this);\r\n\r\n    this.defaultOptions = {\r\n      showGrid: true,\r\n      showLabel: true,\r\n      opacity: 10,\r\n      weight: 2,\r\n      color: \"#990000\", //Font background colour and dash colour\r\n      font: \"15px Courier New\",\r\n      fontColor: \"#FFFFFF\",\r\n      dashArray: [4, 4],\r\n      eastingArray: [],\r\n      northingArray: [],\r\n      minZoom: 6, //Must be at least at this zoom to see the graticules\r\n      maxZoom: 10,\r\n    };\r\n\r\n    this.options = (props && props.options) || this.defaultOptions;\r\n\r\n    this.map = props.map;\r\n    this.canvas = props.canvas;\r\n    this.northingArray = [];\r\n    this.eastingArray = [];\r\n\r\n    this.HUNDRED_K_GRID_INTERVAL = 100000;\r\n  }\r\n\r\n  updateVariables(props) {\r\n    this.options = (props && props.options) || this.defaultOptions;\r\n  }\r\n\r\n  onAdd(map) {\r\n    map._panes.overlayPane.appendChild(this.canvas);\r\n    map.on(\"viewreset\", this.reset, this);\r\n    map.on(\"move\", this.reset, this);\r\n\r\n    this.reset();\r\n  }\r\n\r\n  onRemove(map) {\r\n    map._panes.overlayPane.removeChild(this.canvas);\r\n    map.off(\"viewreset\", this.reset, this);\r\n    map.off(\"move\", this.reset, this);\r\n\r\n    this.canvas = null;\r\n    this.map = null;\r\n  }\r\n\r\n  /**\r\n   * Called whenever the map is moved.  Redraws the grids.\r\n   */\r\n  reset() {\r\n    const MAP_SIZE = this.map.getSize();\r\n    const MAP_TOP_LEFT = this.map.containerPointToLayerPoint([0, 0]);\r\n\r\n    this.canvas._leaflet_pos = MAP_TOP_LEFT;\r\n\r\n    this.canvas.style[\r\n      \"transform\"\r\n    ] = `translate3d(${MAP_TOP_LEFT.x}px,${MAP_TOP_LEFT.y}px,0)`;\r\n\r\n    this.canvas.width = MAP_SIZE.x;\r\n    this.canvas.height = MAP_SIZE.y;\r\n    const ZOOM = this.map.getZoom();\r\n\r\n    if (ZOOM > this.options.minZoom && ZOOM < this.options.maxZoom) {\r\n      let visibleGrids = this.getVizGrids();\r\n\r\n      this.eastingArray = [];\r\n      this.northingArray = [];\r\n      this.generateGrids(visibleGrids);\r\n    }\r\n  }\r\n\r\n  getVizGrids() {\r\n    const NW_BOUND_MGRS = forward(\r\n      [\r\n        this.map.getBounds().getNorthWest()[\"lng\"],\r\n        this.map.getBounds().getNorthWest()[\"lat\"],\r\n      ],\r\n      1\r\n    );\r\n    const NE_BOUND_MGRS = forward(\r\n      [\r\n        this.map.getBounds().getNorthEast()[\"lng\"],\r\n        this.map.getBounds().getNorthEast()[\"lat\"],\r\n      ],\r\n      1\r\n    );\r\n    const SE_BOUND_MGRS = forward(\r\n      [\r\n        this.map.getBounds().getSouthEast()[\"lng\"],\r\n        this.map.getBounds().getSouthEast()[\"lat\"],\r\n      ],\r\n      1\r\n    );\r\n    const SW_BOUND_MGRS = forward(\r\n      [\r\n        this.map.getBounds().getSouthWest()[\"lng\"],\r\n        this.map.getBounds().getSouthWest()[\"lat\"],\r\n      ],\r\n      1\r\n    );\r\n\r\n    let visibleGrids = getAllVisibleGzds(\r\n      NW_BOUND_MGRS.match(MGRS_REGEX)[GZD_INDEX],\r\n      NE_BOUND_MGRS.match(MGRS_REGEX)[GZD_INDEX],\r\n      SE_BOUND_MGRS.match(MGRS_REGEX)[GZD_INDEX],\r\n      SW_BOUND_MGRS.match(MGRS_REGEX)[GZD_INDEX]\r\n    );\r\n\r\n    return visibleGrids;\r\n  }\r\n\r\n  getPaddingOnZoomLevel(currentZoom) {\r\n    switch (currentZoom) {\r\n      case 17:\r\n        return 60;\r\n      case 16:\r\n        return 60;\r\n      case 15:\r\n        return 60;\r\n      case 14:\r\n        return 30;\r\n      case 13:\r\n        return 15;\r\n      case 12:\r\n        return 7;\r\n      case 11:\r\n        return 4;\r\n      case 10:\r\n        return 3;\r\n      case 9:\r\n        return 3;\r\n      case 8:\r\n        return 3;\r\n      case 7:\r\n        return 3;\r\n      case 6:\r\n        return 1;\r\n      default:\r\n        return 1; //TODO - Modify according to what I set the maxZoom for 100k to be\r\n    }\r\n  }\r\n\r\n  handle31VLabels(ctx, adjustedLl, coordinateLl) {\r\n    const HALF_DEGREE = 0.5; // Approximate distance used to centre the label in the middle of the HK zone\r\n    const LABEL_XY = latLngToCanvasPoint(this.map, {\r\n      lat: (adjustedLl.lat + coordinateLl.lat) / 2 + HALF_DEGREE,\r\n      lng: (adjustedLl.lng + coordinateLl.lng) / 2,\r\n    });\r\n\r\n    // This is extra label text\r\n    const LABEL_TEXT = forward([\r\n      (adjustedLl.lng + coordinateLl.lng) / 2,\r\n      (adjustedLl.lat + coordinateLl.lat) / 2 + HALF_DEGREE,\r\n    ]).match(MGRS_REGEX)[HK_INDEX];\r\n\r\n    drawLabel(\r\n      ctx,\r\n      LABEL_TEXT,\r\n      this.options.fontColor,\r\n      this.options.color,\r\n      LABEL_XY\r\n    );\r\n  }\r\n\r\n  handle31V(ctx, elemUtm, coordinateLl) {\r\n    const ZONE_BOUNDARIES = getGZD(\"31V\");\r\n    const WEST_GZD_LONGITUDE =\r\n      ZONE_BOUNDARIES[\"geometry\"][\"coordinates\"][0][NW_INDEX][LONGITUDE_INDEX];\r\n    const EAST_GZD_LONGITUDE =\r\n      ZONE_BOUNDARIES[\"geometry\"][\"coordinates\"][0][NE_INDEX][LONGITUDE_INDEX];\r\n\r\n    // 60km east of elem at the same northing - The shortest segment was measured to be around 65k\r\n    const TEMP_POINT_LL = utm.convertUtmToLatLng(\r\n      elemUtm.easting + 60000,\r\n      elemUtm.northing,\r\n      elemUtm.zoneNumber,\r\n      elemUtm.zoneLetter\r\n    );\r\n\r\n    const SLOPE = getLineSlope(coordinateLl, TEMP_POINT_LL);\r\n\r\n    // From the line slope derive the intersecting point with the GZD boundary\r\n    const ADJUSTED_EAST_LATITUDE = getAdjustedLatitude(\r\n      SLOPE,\r\n      EAST_GZD_LONGITUDE,\r\n      TEMP_POINT_LL\r\n    );\r\n\r\n    const EAST_GZD_BOUNDARY_POINT = latLngToCanvasPoint(this.map, {\r\n      lat: ADJUSTED_EAST_LATITUDE,\r\n      lng: EAST_GZD_LONGITUDE,\r\n    });\r\n\r\n    // Derive the west intersecting point using the same slope.\r\n    const ADJUSTED_WEST_LATITUDE = getAdjustedLatitude(\r\n      SLOPE,\r\n      WEST_GZD_LONGITUDE,\r\n      TEMP_POINT_LL\r\n    );\r\n\r\n    const WEST_GZD_BOUNDARY_POINT = latLngToCanvasPoint(this.map, {\r\n      lat: ADJUSTED_WEST_LATITUDE,\r\n      lng: WEST_GZD_LONGITUDE,\r\n    });\r\n    ctx.moveTo(WEST_GZD_BOUNDARY_POINT.x, WEST_GZD_BOUNDARY_POINT.y);\r\n    ctx.lineTo(EAST_GZD_BOUNDARY_POINT.x, EAST_GZD_BOUNDARY_POINT.y);\r\n\r\n    // Eastern 31V Labels\r\n    this.handle31VLabels(\r\n      ctx,\r\n      { lat: ADJUSTED_EAST_LATITUDE, lng: EAST_GZD_LONGITUDE },\r\n      coordinateLl\r\n    );\r\n\r\n    // Western 31V Labels\r\n    this.handle31VLabels(\r\n      ctx,\r\n      { lat: ADJUSTED_WEST_LATITUDE, lng: WEST_GZD_LONGITUDE },\r\n      coordinateLl\r\n    );\r\n  }\r\n\r\n  processEastingsAndNorthings(\r\n    startingNorthingUtm,\r\n    startingEastingUtm,\r\n    finalNorthingUtm,\r\n    finalEastingUtm\r\n  ) {\r\n    let northingIterator = startingNorthingUtm.Northing;\r\n    let eastingIterator = startingEastingUtm.Easting;\r\n\r\n    //Round to nearest 100k metres -- the loop will need to iterate to there anyways\r\n    northingIterator =\r\n      Math.ceil(northingIterator / this.HUNDRED_K_GRID_INTERVAL) *\r\n      this.HUNDRED_K_GRID_INTERVAL;\r\n    eastingIterator =\r\n      Math.ceil(eastingIterator / this.HUNDRED_K_GRID_INTERVAL) *\r\n      this.HUNDRED_K_GRID_INTERVAL;\r\n\r\n    if (\r\n      startingNorthingUtm.ZoneNumber +\r\n        startingNorthingUtm.ZoneLetter.toString() ===\r\n      \"31W\"\r\n    ) {\r\n      northingIterator = 7100000; // Round down for special case\r\n    }\r\n\r\n    // Find all northing grids that are divisible by 100,000\r\n    if (startingNorthingUtm.ZoneLetter === finalNorthingUtm.ZoneLetter) {\r\n      while (northingIterator <= finalNorthingUtm.Northing) {\r\n        // This loop basically checks to make sure the easting grid is divisible by 100K\r\n        if (northingIterator % this.HUNDRED_K_GRID_INTERVAL === 0) {\r\n          this.northingArray.push({\r\n            northing: northingIterator,\r\n            zoneNumber: startingNorthingUtm.ZoneNumber,\r\n            zoneLetter: startingNorthingUtm.ZoneLetter,\r\n          });\r\n        }\r\n        northingIterator += this.HUNDRED_K_GRID_INTERVAL;\r\n      }\r\n    }\r\n    // Find all easting grids that are divisible by 100,000\r\n    if (startingEastingUtm.ZoneLetter === finalEastingUtm.ZoneLetter) {\r\n      while (eastingIterator <= finalEastingUtm.Easting) {\r\n        if (eastingIterator % this.HUNDRED_K_GRID_INTERVAL === 0) {\r\n          this.eastingArray.push({\r\n            easting: eastingIterator,\r\n            zoneNumber: startingEastingUtm.ZoneNumber,\r\n            zoneLetter: startingEastingUtm.ZoneLetter,\r\n          });\r\n        }\r\n        eastingIterator += this.HUNDRED_K_GRID_INTERVAL;\r\n      }\r\n    }\r\n  }\r\n\r\n  processGridIntersection(mapBounds, eastingElem, northingElem) {\r\n    if (\r\n      eastingElem.zoneNumber === northingElem.zoneNumber &&\r\n      eastingElem.zoneLetter === northingElem.zoneLetter\r\n    ) {\r\n      const GRID_INTERSECTION = {\r\n        northing: northingElem.northing,\r\n        easting: eastingElem.easting,\r\n        zoneNumber: northingElem.zoneNumber,\r\n        zoneLetter: northingElem.zoneLetter,\r\n      };\r\n\r\n      if (\r\n        mapBounds.contains(\r\n          utm.convertUtmToLatLng(\r\n            GRID_INTERSECTION.easting,\r\n            GRID_INTERSECTION.northing,\r\n            GRID_INTERSECTION.zoneNumber,\r\n            GRID_INTERSECTION.zoneLetter\r\n          )\r\n        )\r\n      ) {\r\n        return GRID_INTERSECTION;\r\n      }\r\n    }\r\n  }\r\n\r\n  handleEquatorLabels(ctx, firstIntersection, secondIntersection) {\r\n    let labelCoordinateLl = utm.convertUtmToLatLng(\r\n      Math.floor((firstIntersection.easting + secondIntersection.easting) / 2),\r\n      Math.floor(firstIntersection.northing - 50000),\r\n      firstIntersection.zoneNumber,\r\n      firstIntersection.zoneLetter\r\n    );\r\n\r\n    let labelText = forward([\r\n      labelCoordinateLl.lng,\r\n      labelCoordinateLl.lat,\r\n    ]).match(MGRS_REGEX)[HK_INDEX];\r\n\r\n    drawLabel(\r\n      ctx,\r\n      labelText,\r\n      this.options.fontColor,\r\n      this.options.color,\r\n      latLngToCanvasPoint(this.map, {\r\n        lat: labelCoordinateLl.lat,\r\n        lng: labelCoordinateLl.lng,\r\n      })\r\n    );\r\n  }\r\n\r\n  generateGrids(visibleGzds) {\r\n    let ctx = this.canvas.getContext(\"2d\");\r\n    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n    ctx.lineWidth = this.options.weight;\r\n    ctx.strokeStyle = this.options.color;\r\n    ctx.fillStyle = this.options.color;\r\n    ctx.setLineDash(this.options.dashArray);\r\n    ctx.font = this.options.font;\r\n\r\n    visibleGzds.forEach((gzd) => {\r\n      // Get Lat/Long bounds for each GZD\r\n      let zoneBoundaries;\r\n      try {\r\n        zoneBoundaries = getGZD(gzd);\r\n      } catch (error) {\r\n        return; //Invalid MGRS value returned, so no need to try to display the grid\r\n      }\r\n\r\n      const SW_CORNER_LL =\r\n        zoneBoundaries[\"geometry\"][\"coordinates\"][0][SW_INDEX];\r\n      const NW_CORNER_LL =\r\n        zoneBoundaries[\"geometry\"][\"coordinates\"][0][NW_INDEX];\r\n      const NE_CORNER_LL =\r\n        zoneBoundaries[\"geometry\"][\"coordinates\"][0][NE_INDEX];\r\n      const SE_CORNER_LL =\r\n        zoneBoundaries[\"geometry\"][\"coordinates\"][0][SE_INDEX];\r\n\r\n      const UTM_RESOLUTION = 0; //No decimal places when returning the UTM location\r\n\r\n      const BUFFER = 0.00001; // HACK - This buffer shrinks the UTM.  Very magical.\r\n\r\n      let SW_CORNER_UTM = utm.convertLatLngToUtm(\r\n        SW_CORNER_LL[LATITUDE_INDEX] + BUFFER,\r\n        SW_CORNER_LL[LONGITUDE_INDEX] + BUFFER,\r\n        UTM_RESOLUTION\r\n      );\r\n      const NW_CORNER_UTM = utm.convertLatLngToUtm(\r\n        NW_CORNER_LL[LATITUDE_INDEX] - BUFFER,\r\n        NW_CORNER_LL[LONGITUDE_INDEX] + BUFFER,\r\n        UTM_RESOLUTION\r\n      );\r\n      const NE_CORNER_UTM = utm.convertLatLngToUtm(\r\n        NE_CORNER_LL[LATITUDE_INDEX] - BUFFER,\r\n        NE_CORNER_LL[LONGITUDE_INDEX] - BUFFER,\r\n        UTM_RESOLUTION\r\n      );\r\n      const SE_CORNER_UTM = utm.convertLatLngToUtm(\r\n        SE_CORNER_LL[LATITUDE_INDEX] + BUFFER,\r\n        SE_CORNER_LL[LONGITUDE_INDEX] - BUFFER,\r\n        UTM_RESOLUTION\r\n      );\r\n\r\n      //BUG - Incorrect conversion from LL to UTM in the SW corner of the 33V GZD will make\r\n      // it think that it is in the 32V GZD.  Without manually setting it the algorithm will\r\n      // create a second set of lines over Norway and leave Sweden blank.\r\n      if (gzd === \"33V\") {\r\n        SW_CORNER_UTM = {\r\n          ZoneLetter: \"V\",\r\n          ZoneNumber: 33,\r\n          Easting: 312900,\r\n          Northing: 6210142,\r\n        };\r\n      }\r\n\r\n      const HEMISPHERE = this.map.getCenter().lat <= 0 ? \"South\" : \"North\";\r\n\r\n      switch (HEMISPHERE) {\r\n        case \"North\":\r\n          this.processEastingsAndNorthings(\r\n            SW_CORNER_UTM,\r\n            SW_CORNER_UTM,\r\n            NE_CORNER_UTM,\r\n            SE_CORNER_UTM\r\n          );\r\n          break;\r\n        case \"South\":\r\n          this.processEastingsAndNorthings(\r\n            SW_CORNER_UTM,\r\n            NW_CORNER_UTM,\r\n            NE_CORNER_UTM,\r\n            NE_CORNER_UTM\r\n          );\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n    });\r\n\r\n    const MAP_BOUNDS = this.map\r\n      .getBounds()\r\n      .pad(this.getPaddingOnZoomLevel(this.map.getZoom()));\r\n    this.northingArray.forEach((northingElem) => {\r\n      let northingGridsArray = [];\r\n\r\n      this.eastingArray.forEach((eastingElem) => {\r\n        let intersection = this.processGridIntersection(\r\n          MAP_BOUNDS,\r\n          eastingElem,\r\n          northingElem\r\n        );\r\n        if (intersection) {\r\n          northingGridsArray.push(intersection);\r\n        }\r\n      });\r\n\r\n      northingGridsArray.forEach((elem, index, array) => {\r\n        let COORDINATE_LL = utm.convertUtmToLatLng(\r\n          elem.easting,\r\n          elem.northing,\r\n          elem.zoneNumber,\r\n          elem.zoneLetter\r\n        );\r\n\r\n        let COORDINATE_XY = latLngToCanvasPoint(this.map, {\r\n          lat: COORDINATE_LL.lat,\r\n          lng: COORDINATE_LL.lng,\r\n        });\r\n\r\n        let gzd = elem.zoneNumber.toString() + elem.zoneLetter;\r\n        // Since there is only one northing array in zone 31V, we need to treat this zone\r\n        // specially.  For each point in 31V, we will traverse the grid horizontally in\r\n        // order to get a second point to derive a line from. From there it will be expanded\r\n        // to cover the entire GZD.\r\n        if (gzd === \"31V\") {\r\n          this.handle31V(ctx, elem, COORDINATE_LL);\r\n        } else {\r\n          if (index === 0) {\r\n            if (northingGridsArray[index + 1]) {\r\n              const NEXT_COORDINATE_LL = utm.convertUtmToLatLng(\r\n                northingGridsArray[index + 1].easting,\r\n                northingGridsArray[index + 1].northing,\r\n                northingGridsArray[index + 1].zoneNumber,\r\n                northingGridsArray[index + 1].zoneLetter\r\n              );\r\n\r\n              // Get Lat/Long bounds for each GZD\r\n              const WEST_GZD_LONGITUDE = getGZD(gzd)[\"geometry\"][\r\n                \"coordinates\"\r\n              ][0][NW_INDEX][LONGITUDE_INDEX];\r\n\r\n              // If the first point is west of the GZD western boundary\r\n              if (COORDINATE_LL.lng < WEST_GZD_LONGITUDE) {\r\n                let slope = getLineSlope(COORDINATE_LL, NEXT_COORDINATE_LL);\r\n\r\n                let adjustedLatitude = getAdjustedLatitude(\r\n                  slope,\r\n                  WEST_GZD_LONGITUDE,\r\n                  NEXT_COORDINATE_LL\r\n                );\r\n\r\n                COORDINATE_XY = latLngToCanvasPoint(this.map, {\r\n                  lat: adjustedLatitude,\r\n                  lng: WEST_GZD_LONGITUDE,\r\n                });\r\n                // If the first point is east of the GZD western boundary\r\n              } else if (COORDINATE_LL.lng > WEST_GZD_LONGITUDE) {\r\n                let additionalPoint = connectToGzdBoundary(\r\n                  COORDINATE_LL,\r\n                  NEXT_COORDINATE_LL,\r\n                  \"West\"\r\n                );\r\n\r\n                let cachedCoordinateXy = COORDINATE_XY; // Used to determine whether we actually display the label\r\n\r\n                COORDINATE_XY = latLngToCanvasPoint(this.map, {\r\n                  lat: additionalPoint.lat,\r\n                  lng: additionalPoint.lng,\r\n                });\r\n\r\n                // This is extra label text\r\n                let labelText = forward([\r\n                  additionalPoint.lng,\r\n                  additionalPoint.lat,\r\n                ]).match(MGRS_REGEX)[HK_INDEX];\r\n\r\n                let labelWidth = ctx.measureText(labelText).width;\r\n\r\n                // If the label is wider than the zone it represents (with a scale factor), don't display\r\n                if (\r\n                  Math.abs(cachedCoordinateXy.x - COORDINATE_XY.x) / 1.5 >\r\n                  labelWidth\r\n                ) {\r\n                  drawLabel(\r\n                    ctx,\r\n                    labelText,\r\n                    this.options.fontColor,\r\n                    this.options.color,\r\n                    latLngToCanvasPoint(this.map, {\r\n                      lat:\r\n                        Math.abs(additionalPoint.lng - COORDINATE_LL.lng) / 2 +\r\n                        additionalPoint.lat,\r\n                      lng: (additionalPoint.lng + COORDINATE_LL.lng) / 2,\r\n                    })\r\n                  );\r\n                }\r\n\r\n                // Handle a special case in a GZD adjacent to the Norway special zones\r\n                if (labelText === \"LT\" && gzd === \"32W\") {\r\n                  labelText = forward([\r\n                    (additionalPoint.lng + COORDINATE_LL.lng) / 2,\r\n                    Math.abs(additionalPoint.lng - COORDINATE_LL.lng) / 2 -\r\n                      additionalPoint.lat,\r\n                  ]).match(MGRS_REGEX)[HK_INDEX];\r\n\r\n                  labelWidth = ctx.measureText(labelText).width;\r\n\r\n                  // If the label is wider than the zone it represents (with a scale factor), don't display\r\n                  if (\r\n                    Math.abs(cachedCoordinateXy.x - COORDINATE_XY.x) / 1.5 >\r\n                    labelWidth\r\n                  ) {\r\n                    drawLabel(\r\n                      ctx,\r\n                      labelText,\r\n                      this.options.fontColor,\r\n                      this.options.color,\r\n                      latLngToCanvasPoint(this.map, {\r\n                        lat:\r\n                          additionalPoint.lat -\r\n                          Math.abs(additionalPoint.lng - COORDINATE_LL.lng) / 2,\r\n                        lng: (additionalPoint.lng + COORDINATE_LL.lng) / 2,\r\n                      })\r\n                    );\r\n                  }\r\n                }\r\n              }\r\n\r\n              let labelCoordinateLl = utm.convertUtmToLatLng(\r\n                Math.floor(\r\n                  (northingGridsArray[index].easting +\r\n                    northingGridsArray[index + 1].easting) /\r\n                    2\r\n                ),\r\n                Math.floor(northingGridsArray[index].northing + 50000),\r\n                northingGridsArray[index].zoneNumber,\r\n                northingGridsArray[index].zoneLetter\r\n              );\r\n\r\n              let labelText = forward([\r\n                labelCoordinateLl.lng,\r\n                labelCoordinateLl.lat,\r\n              ]).match(MGRS_REGEX)[HK_INDEX];\r\n\r\n              if (!(labelText === \"EM\" && gzd === \"32V\")) {\r\n                drawLabel(\r\n                  ctx,\r\n                  labelText,\r\n                  this.options.fontColor,\r\n                  this.options.color,\r\n                  latLngToCanvasPoint(this.map, {\r\n                    lat: labelCoordinateLl.lat,\r\n                    lng: labelCoordinateLl.lng,\r\n                  })\r\n                );\r\n              }\r\n\r\n              if (elem.zoneLetter === \"N\") {\r\n                this.handleEquatorLabels(\r\n                  ctx,\r\n                  northingGridsArray[index],\r\n                  northingGridsArray[index + 1]\r\n                );\r\n              }\r\n            }\r\n            ctx.beginPath();\r\n\r\n            ctx.moveTo(COORDINATE_XY.x, COORDINATE_XY.y);\r\n          } else {\r\n            // Last element in the northing grids array\r\n            if (index === array.length - 1) {\r\n              const EAST_GZD_LONGITUDE = getGZD(gzd)[\"geometry\"][\r\n                \"coordinates\"\r\n              ][0][NE_INDEX][LONGITUDE_INDEX];\r\n              const PREV_COORDINATE_LL = utm.convertUtmToLatLng(\r\n                northingGridsArray[index - 1].easting,\r\n                northingGridsArray[index - 1].northing,\r\n                northingGridsArray[index - 1].zoneNumber,\r\n                northingGridsArray[index - 1].zoneLetter\r\n              );\r\n              // The final point is to the east of the eastern GZD boundary, so it needs\r\n              // to be moved back to the boundary\r\n              if (COORDINATE_LL.lng > EAST_GZD_LONGITUDE) {\r\n                let slope = getLineSlope(COORDINATE_LL, PREV_COORDINATE_LL);\r\n\r\n                let adjustedLatitude = getAdjustedLatitude(\r\n                  slope,\r\n                  EAST_GZD_LONGITUDE,\r\n                  PREV_COORDINATE_LL\r\n                );\r\n\r\n                COORDINATE_XY = latLngToCanvasPoint(this.map, {\r\n                  lat: adjustedLatitude,\r\n                  lng: EAST_GZD_LONGITUDE,\r\n                });\r\n                // The final point is to the west of the eastern GZD boundary, so another\r\n                // point needs to be made to account for the additional 100k zone\r\n              } else if (COORDINATE_LL.lng <= EAST_GZD_LONGITUDE) {\r\n                let additionalPoint = connectToGzdBoundary(\r\n                  COORDINATE_LL,\r\n                  PREV_COORDINATE_LL,\r\n                  \"East\"\r\n                );\r\n\r\n                let cachedCoordinateXy = COORDINATE_XY; // Used to determine whether we actually display the label\r\n\r\n                COORDINATE_XY = latLngToCanvasPoint(this.map, {\r\n                  lat: additionalPoint.lat,\r\n                  lng: additionalPoint.lng,\r\n                });\r\n\r\n                // This is extra label text\r\n                let labelText = forward([\r\n                  COORDINATE_LL.lng,\r\n                  COORDINATE_LL.lat,\r\n                ]).match(MGRS_REGEX)[HK_INDEX];\r\n\r\n                let labelWidth = ctx.measureText(labelText).width;\r\n\r\n                // If the label is wider than the zone it represents (with a scale factor), don't display\r\n                if (\r\n                  Math.abs(cachedCoordinateXy.x - COORDINATE_XY.x) / 1.5 >\r\n                  labelWidth\r\n                ) {\r\n                  drawLabel(\r\n                    ctx,\r\n                    labelText,\r\n                    this.options.fontColor,\r\n                    this.options.color,\r\n                    latLngToCanvasPoint(this.map, {\r\n                      lat:\r\n                        Math.abs(additionalPoint.lng - COORDINATE_LL.lng) / 2 +\r\n                        additionalPoint.lat,\r\n                      lng: (additionalPoint.lng + COORDINATE_LL.lng) / 2,\r\n                    })\r\n                  );\r\n                }\r\n              }\r\n\r\n              let labelCoordinateLl = utm.convertUtmToLatLng(\r\n                Math.floor(\r\n                  (northingGridsArray[index].easting +\r\n                    northingGridsArray[index - 1].easting) /\r\n                    2\r\n                ),\r\n                Math.floor(northingGridsArray[index].northing + 50000),\r\n                northingGridsArray[index].zoneNumber,\r\n                northingGridsArray[index].zoneLetter\r\n              );\r\n\r\n              let labelText = forward([\r\n                labelCoordinateLl.lng,\r\n                labelCoordinateLl.lat,\r\n              ]).match(MGRS_REGEX)[HK_INDEX];\r\n\r\n              drawLabel(\r\n                ctx,\r\n                labelText,\r\n                this.options.fontColor,\r\n                this.options.color,\r\n                latLngToCanvasPoint(this.map, {\r\n                  lat: labelCoordinateLl.lat,\r\n                  lng: labelCoordinateLl.lng,\r\n                })\r\n              );\r\n            } else {\r\n              let labelCoordinateLl = utm.convertUtmToLatLng(\r\n                Math.floor(\r\n                  (northingGridsArray[index].easting +\r\n                    northingGridsArray[index + 1].easting) /\r\n                    2\r\n                ),\r\n                Math.floor(northingGridsArray[index].northing + 50000),\r\n                northingGridsArray[index].zoneNumber,\r\n                northingGridsArray[index].zoneLetter\r\n              );\r\n\r\n              let labelText = forward([\r\n                labelCoordinateLl.lng,\r\n                labelCoordinateLl.lat,\r\n              ]).match(MGRS_REGEX)[HK_INDEX];\r\n              if (!(labelText === \"FM\" && gzd === \"32V\")) {\r\n                drawLabel(\r\n                  ctx,\r\n                  labelText,\r\n                  this.options.fontColor,\r\n                  this.options.color,\r\n                  latLngToCanvasPoint(this.map, {\r\n                    lat: labelCoordinateLl.lat,\r\n                    lng: labelCoordinateLl.lng,\r\n                  })\r\n                );\r\n              }\r\n\r\n              if (elem.zoneLetter === \"N\") {\r\n                this.handleEquatorLabels(\r\n                  ctx,\r\n                  northingGridsArray[index],\r\n                  northingGridsArray[index + 1]\r\n                );\r\n              }\r\n            }\r\n            ctx.lineTo(COORDINATE_XY.x, COORDINATE_XY.y);\r\n          }\r\n        }\r\n      });\r\n      ctx.stroke();\r\n    });\r\n\r\n    this.eastingArray.forEach((eastingElem) => {\r\n      let eastingGridsArray = [];\r\n\r\n      this.northingArray.forEach((northingElem) => {\r\n        let intersection = this.processGridIntersection(\r\n          MAP_BOUNDS,\r\n          eastingElem,\r\n          northingElem\r\n        );\r\n        if (intersection) {\r\n          eastingGridsArray.push(intersection);\r\n        }\r\n      });\r\n      let shouldSkip = false; // Can't break out of a forEach loop using 'break'\r\n      eastingGridsArray.forEach((elem, index, array) => {\r\n        if (shouldSkip) {\r\n          return;\r\n        }\r\n\r\n        let COORDINATE_LL = utm.convertUtmToLatLng(\r\n          elem.easting,\r\n          elem.northing,\r\n          elem.zoneNumber,\r\n          elem.zoneLetter\r\n        );\r\n\r\n        let COORDINATE_XY = latLngToCanvasPoint(this.map, {\r\n          lat: COORDINATE_LL.lat,\r\n          lng: COORDINATE_LL.lng,\r\n        });\r\n\r\n        let gzd = elem.zoneNumber.toString() + elem.zoneLetter;\r\n\r\n        const SW_GZD_POINT = getGZD(gzd)[\"geometry\"][\"coordinates\"][0][\r\n          SW_INDEX\r\n        ];\r\n\r\n        // The first index in the array of northings\r\n        if (index === 0) {\r\n          ctx.beginPath();\r\n\r\n          // If the first northing coordinate is north of the south boundary of the GZD,\r\n          // we need to extend a line to touch the bottom of the GZD\r\n          if (\r\n            COORDINATE_LL.lat > SW_GZD_POINT[LATITUDE_INDEX] &&\r\n            eastingGridsArray[index + 1]\r\n          ) {\r\n            const NEXT_COORDINATE_LL = utm.convertUtmToLatLng(\r\n              eastingGridsArray[index + 1].easting,\r\n              eastingGridsArray[index + 1].northing,\r\n              eastingGridsArray[index + 1].zoneNumber,\r\n              eastingGridsArray[index + 1].zoneLetter\r\n            );\r\n\r\n            let adjustedPoint = connectToGzdBoundary(\r\n              COORDINATE_LL,\r\n              NEXT_COORDINATE_LL,\r\n              \"South\"\r\n            );\r\n\r\n            COORDINATE_XY = latLngToCanvasPoint(this.map, {\r\n              lat: adjustedPoint.lat,\r\n              lng: adjustedPoint.lng,\r\n            });\r\n          }\r\n          ctx.moveTo(COORDINATE_XY.x, COORDINATE_XY.y);\r\n        } else {\r\n          // Get Lat/Long bounds for each GZD\r\n          const NE_GZD_POINT = getGZD(gzd)[\"geometry\"][\"coordinates\"][0][\r\n            NE_INDEX\r\n          ];\r\n\r\n          const PREV_COORDINATE_LL = utm.convertUtmToLatLng(\r\n            eastingGridsArray[index - 1].easting,\r\n            eastingGridsArray[index - 1].northing,\r\n            eastingGridsArray[index - 1].zoneNumber,\r\n            eastingGridsArray[index - 1].zoneLetter\r\n          );\r\n\r\n          let slope = getLineSlope(COORDINATE_LL, PREV_COORDINATE_LL);\r\n          // If the point in the easting array is outside of its GZD, calculate the slope\r\n          // of the line with the previous point in the array and adjust the end point latitude\r\n          // as if it were resting right on the GZD boundary.\r\n          if (COORDINATE_LL.lng <= SW_GZD_POINT[LONGITUDE_INDEX]) {\r\n            COORDINATE_XY = this.getAdjustedXy(\r\n              slope,\r\n              SW_GZD_POINT[LONGITUDE_INDEX],\r\n              PREV_COORDINATE_LL\r\n            );\r\n            // If the value is outside of the GZD, then all subsequent ones will be too\r\n            // This means they do not need to be displayed.  You can't break out of a\r\n            // forEach loop, so using a boolean instead.\r\n            shouldSkip = true;\r\n          } else if (COORDINATE_LL.lng > NE_GZD_POINT[LONGITUDE_INDEX]) {\r\n            COORDINATE_XY = this.getAdjustedXy(\r\n              slope,\r\n              NE_GZD_POINT[LONGITUDE_INDEX],\r\n              PREV_COORDINATE_LL\r\n            );\r\n\r\n            shouldSkip = true;\r\n          }\r\n\r\n          ctx.lineTo(COORDINATE_XY.x, COORDINATE_XY.y);\r\n          // Connect to the GZD northern boundary\r\n          if (\r\n            array.length - 1 === index &&\r\n            COORDINATE_LL.lat < NE_GZD_POINT[LATITUDE_INDEX]\r\n          ) {\r\n            let adjustedPoint = connectToGzdBoundary(\r\n              COORDINATE_LL,\r\n              PREV_COORDINATE_LL,\r\n              \"North\"\r\n            );\r\n            COORDINATE_XY = latLngToCanvasPoint(this.map, {\r\n              lat: adjustedPoint.lat,\r\n              lng: adjustedPoint.lng,\r\n            });\r\n\r\n            ctx.lineTo(COORDINATE_XY.x, COORDINATE_XY.y);\r\n          }\r\n        }\r\n      });\r\n      ctx.stroke();\r\n    });\r\n  }\r\n\r\n  // Small wrapper function to get the adjusted XY coordinates for when a HK point\r\n  // lies west/east of the GZD boundary\r\n  getAdjustedXy(slope, boundaryPoint, coordinateLl) {\r\n    let adjustedLatitude = getAdjustedLatitude(\r\n      slope,\r\n      boundaryPoint,\r\n      coordinateLl\r\n    );\r\n\r\n    let COORDINATE_XY = latLngToCanvasPoint(this.map, {\r\n      lat: adjustedLatitude,\r\n      lng: boundaryPoint,\r\n    });\r\n    return COORDINATE_XY;\r\n  }\r\n}\r\n\r\nexport { HundredKGraticule };\r\n","import { Layer } from \"leaflet\";\r\nimport { useMap } from \"react-leaflet\";\r\nimport {\r\n  connectToGzdBoundary,\r\n  drawLabel,\r\n  getAllVisibleGzds,\r\n  latLngToCanvasPoint,\r\n} from \"./CommonUtils\";\r\nimport { getGZD } from \"gzd-utils\";\r\nimport { forward } from \"mgrs\";\r\n\r\n// The following indicies are used to indentify coordinates returned from gzd-utils\r\nconst SW_INDEX = 0;\r\nconst NW_INDEX = 1;\r\nconst NE_INDEX = 2;\r\n\r\nconst LATITUDE_INDEX = 1;\r\nconst LONGITUDE_INDEX = 0;\r\n\r\nconst MGRS_REGEX = /([0-9]+[A-Z])([A-Z]{2})(\\d+)/;\r\nconst GZD_INDEX = 1;\r\n\r\nvar utmObj = require(\"utm-latlng\");\r\nvar utm = new utmObj(); // Defaults to WGS-84\r\n\r\nconst OneKGraticule = (props) => {\r\n  let map = useMap();\r\n\r\n  const canvas = document.createElement(\"canvas\");\r\n  canvas.classList.add(\"leaflet-zoom-animated\");\r\n\r\n  let g = new Graticule({ map: map, canvas: canvas });\r\n  map.addLayer(g);\r\n\r\n  return null;\r\n};\r\nclass Graticule extends Layer {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    this.updateVariables = this.updateVariables.bind(this);\r\n\r\n    this.defaultOptions = {\r\n      showGrid: true, // TODO - control grid visibility with this\r\n      showLabel: true,\r\n      opacity: 10,\r\n      weight: 1.5,\r\n      color: \"#000\",\r\n      hkColor: \"#990000\", //Font background colour and dash colour\r\n      hkDashArray: [4, 4],\r\n      font: \"14px Courier New\",\r\n      fontColor: \"#FFF\",\r\n      dashArray: [],\r\n      tenKMinZoom: 9,\r\n      oneKMinZoom: 12,\r\n      eastingBottom: true, // Display the eastings at the bottom the screen, else display at top\r\n      NorthingRight: true, // Display the northings at the right the screen, else display at left\r\n    };\r\n\r\n    this.options = (props && props.options) || this.defaultOptions;\r\n\r\n    this.map = props.map;\r\n    this.canvas = props.canvas;\r\n    this.currZoom = null;\r\n    this.mgrsGridInterval = null;\r\n  }\r\n\r\n  updateVariables(props) {\r\n    this.options = (props && props.options) || this.defaultOptions;\r\n  }\r\n\r\n  onAdd(map) {\r\n    map._panes.overlayPane.appendChild(this.canvas);\r\n    map.on(\"viewreset\", this.reset, this);\r\n    map.on(\"move\", this.reset, this);\r\n\r\n    this.reset();\r\n  }\r\n\r\n  onRemove(map) {\r\n    map._panes.overlayPane.removeChild(this.canvas);\r\n    map.off(\"viewreset\", this.reset, this);\r\n    map.off(\"move\", this.reset, this);\r\n\r\n    this.canvas = null;\r\n    this.map = null;\r\n  }\r\n\r\n  reset() {\r\n    const MAP_SIZE = this.map.getSize();\r\n    const MAP_LEFT_TOP = this.map.containerPointToLayerPoint([0, 0]);\r\n\r\n    this.canvas._leaflet_pos = MAP_LEFT_TOP;\r\n\r\n    this.canvas.style[\r\n      \"transform\"\r\n    ] = `translate3d(${MAP_LEFT_TOP.x}px,${MAP_LEFT_TOP.y}px,0)`;\r\n\r\n    this.canvas.width = MAP_SIZE.x;\r\n    this.canvas.height = MAP_SIZE.y;\r\n\r\n    if (this.map.getZoom() > this.options.oneKMinZoom) {\r\n      this.mgrsGridInterval = 1000; //1k resolution\r\n    } else if (this.map.getZoom() > this.options.tenKMinZoom) {\r\n      this.mgrsGridInterval = 10000; //10k resolution\r\n    } else {\r\n      this.mgrsGridInterval = null;\r\n    }\r\n\r\n    this.drawGrid();\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {String} element - A UTM easting or northing element\r\n   */\r\n  _getLabelText(element) {\r\n    // Divide by 1000 so that the labels will always be correct (10k vs 1k resolution)\r\n    let label = ((element % 100000) / 1000).toString();\r\n\r\n    if (this.mgrsGridInterval === 10000 && label === \"0\") {\r\n      label = \"00\";\r\n    }\r\n\r\n    return label;\r\n  }\r\n\r\n  _drawLine(ctx, hkLine) {\r\n    if (hkLine) {\r\n      ctx.setLineDash(this.options.dashArray);\r\n      ctx.lineWidth = this.options.weight + 1;\r\n      ctx.strokeStyle = this.options.fontColor;\r\n      ctx.stroke();\r\n      ctx.lineWidth = this.options.weight;\r\n      ctx.strokeStyle = this.options.color;\r\n      ctx.stroke();\r\n    } else {\r\n      ctx.lineWidth = this.options.weight;\r\n      ctx.strokeStyle = this.options.hkColor;\r\n      ctx.setLineDash(this.options.hkDashArray);\r\n      ctx.stroke();\r\n    }\r\n  }\r\n\r\n  getVizGrids() {\r\n    const NW_BOUND_MGRS = forward(\r\n      [\r\n        this.map.getBounds().getNorthWest()[\"lng\"],\r\n        this.map.getBounds().getNorthWest()[\"lat\"],\r\n      ],\r\n      1\r\n    );\r\n    const NE_BOUND_MGRS = forward(\r\n      [\r\n        this.map.getBounds().getNorthEast()[\"lng\"],\r\n        this.map.getBounds().getNorthEast()[\"lat\"],\r\n      ],\r\n      1\r\n    );\r\n    const SE_BOUND_MGRS = forward(\r\n      [\r\n        this.map.getBounds().getSouthEast()[\"lng\"],\r\n        this.map.getBounds().getSouthEast()[\"lat\"],\r\n      ],\r\n      1\r\n    );\r\n    const SW_BOUND_MGRS = forward(\r\n      [\r\n        this.map.getBounds().getSouthWest()[\"lng\"],\r\n        this.map.getBounds().getSouthWest()[\"lat\"],\r\n      ],\r\n      1\r\n    );\r\n\r\n    let visibleGrids = getAllVisibleGzds(\r\n      NW_BOUND_MGRS.match(MGRS_REGEX)[GZD_INDEX],\r\n      NE_BOUND_MGRS.match(MGRS_REGEX)[GZD_INDEX],\r\n      SE_BOUND_MGRS.match(MGRS_REGEX)[GZD_INDEX],\r\n      SW_BOUND_MGRS.match(MGRS_REGEX)[GZD_INDEX]\r\n    );\r\n\r\n    return visibleGrids;\r\n  }\r\n\r\n  drawGrid() {\r\n    if (!this.canvas || !this.map) {\r\n      return;\r\n    }\r\n\r\n    if (this.map.getZoom() < this.options.tenKMinZoom) {\r\n      return;\r\n    }\r\n\r\n    let ctx = this.canvas.getContext(\"2d\");\r\n    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n    ctx.lineWidth = this.options.weight + 0.75;\r\n    ctx.strokeStyle = \"#FFF\";\r\n    ctx.fillStyle = this.options.color;\r\n    ctx.setLineDash(this.options.dashArray);\r\n    ctx.font = this.options.font;\r\n    const VISIBLE_GZDS = this.getVizGrids();\r\n\r\n    const MAP_BOUNDS = this.map.getBounds();\r\n\r\n    VISIBLE_GZDS.forEach((gzd, gzdIndex, visibleGridArr) => {\r\n      const GZD_OBJECT = getGZD(gzd);\r\n      const GZD_WEST_BOUNDARY =\r\n        GZD_OBJECT[\"geometry\"][\"coordinates\"][0][NW_INDEX][LONGITUDE_INDEX];\r\n      const GZD_EAST_BOUNDARY =\r\n        GZD_OBJECT[\"geometry\"][\"coordinates\"][0][NE_INDEX][LONGITUDE_INDEX];\r\n      const GZD_NORTH_BOUNDARY =\r\n        GZD_OBJECT[\"geometry\"][\"coordinates\"][0][NW_INDEX][LATITUDE_INDEX];\r\n      const GZD_SOUTH_BOUNDARY =\r\n        GZD_OBJECT[\"geometry\"][\"coordinates\"][0][SW_INDEX][LATITUDE_INDEX];\r\n\r\n      let effectiveWestGzdBoundary =\r\n        GZD_WEST_BOUNDARY < MAP_BOUNDS.getWest()\r\n          ? MAP_BOUNDS.getWest()\r\n          : GZD_WEST_BOUNDARY;\r\n      let effectiveEastGzdBoundary =\r\n        GZD_EAST_BOUNDARY > MAP_BOUNDS.getEast()\r\n          ? MAP_BOUNDS.getEast()\r\n          : GZD_EAST_BOUNDARY;\r\n      let effectiveWNorthGzdBoundary =\r\n        GZD_NORTH_BOUNDARY > MAP_BOUNDS.getNorth()\r\n          ? MAP_BOUNDS.getNorth()\r\n          : GZD_NORTH_BOUNDARY;\r\n      let effectiveSouthGzdBoundary =\r\n        GZD_SOUTH_BOUNDARY < MAP_BOUNDS.getSouth()\r\n          ? MAP_BOUNDS.getSouth()\r\n          : GZD_SOUTH_BOUNDARY;\r\n\r\n      const BUFFER = 0.00001;\r\n      const SW_CORNER_UTM = utm.convertLatLngToUtm(\r\n        effectiveSouthGzdBoundary + BUFFER,\r\n        effectiveWestGzdBoundary + BUFFER,\r\n        0\r\n      );\r\n      const SE_CORNER_UTM = utm.convertLatLngToUtm(\r\n        effectiveSouthGzdBoundary + BUFFER,\r\n        effectiveEastGzdBoundary - BUFFER,\r\n        0\r\n      );\r\n      const NW_CORNER_UTM = utm.convertLatLngToUtm(\r\n        effectiveWNorthGzdBoundary - BUFFER,\r\n        effectiveWestGzdBoundary + BUFFER,\r\n        0\r\n      );\r\n      const NE_CORNER_UTM = utm.convertLatLngToUtm(\r\n        effectiveWNorthGzdBoundary - BUFFER,\r\n        effectiveEastGzdBoundary - BUFFER,\r\n        0\r\n      );\r\n\r\n      // Draw easting lines\r\n      let startingEasting = SW_CORNER_UTM.Easting;\r\n      let finalEasting = SE_CORNER_UTM.Easting;\r\n\r\n      let startingNorthing = SW_CORNER_UTM.Northing;\r\n      let finalNorthing = NE_CORNER_UTM.Northing;\r\n\r\n      startingEasting =\r\n        Math.floor(startingEasting / this.mgrsGridInterval) *\r\n        this.mgrsGridInterval;\r\n      finalEasting =\r\n        Math.floor(finalEasting / this.mgrsGridInterval) *\r\n        this.mgrsGridInterval;\r\n      startingNorthing =\r\n        Math.floor(startingNorthing / this.mgrsGridInterval) *\r\n        this.mgrsGridInterval;\r\n      finalNorthing =\r\n        Math.ceil(finalNorthing / this.mgrsGridInterval) *\r\n        this.mgrsGridInterval;\r\n\r\n      let eastingArray = [];\r\n      for (\r\n        let i = startingEasting;\r\n        i <= finalEasting;\r\n        i += this.mgrsGridInterval\r\n      ) {\r\n        eastingArray.push(i);\r\n      }\r\n\r\n      let northingArray = [];\r\n      for (\r\n        let i = startingNorthing;\r\n        i <= finalNorthing;\r\n        i += this.mgrsGridInterval\r\n      ) {\r\n        northingArray.push(i);\r\n      }\r\n      let zoneLetter = NW_CORNER_UTM.ZoneLetter;\r\n      let zoneNumber = NW_CORNER_UTM.ZoneNumber;\r\n      // Lines of constant Eastings\r\n      eastingArray.forEach((eastingElem, eastingIndex, eastArr) => {\r\n        let shouldSkip = false;\r\n\r\n        northingArray.forEach((northingElem, northingIndex, northArr) => {\r\n          if (shouldSkip) {\r\n            return;\r\n          }\r\n          let gridIntersectionLl = utm.convertUtmToLatLng(\r\n            eastingElem,\r\n            northingElem,\r\n            zoneNumber,\r\n            zoneLetter\r\n          );\r\n          if (\r\n            gridIntersectionLl.lng < GZD_WEST_BOUNDARY ||\r\n            gridIntersectionLl.lng > GZD_EAST_BOUNDARY\r\n          ) {\r\n            return; //No need to draw this because it's outside the GZD - floor calculation from above.\r\n          }\r\n\r\n          if (gridIntersectionLl.lat < GZD_SOUTH_BOUNDARY) {\r\n            let nextIntersectionLl = utm.convertUtmToLatLng(\r\n              eastingElem,\r\n              northArr[northingIndex + 1],\r\n              zoneNumber,\r\n              zoneLetter\r\n            );\r\n            gridIntersectionLl = connectToGzdBoundary(\r\n              gridIntersectionLl,\r\n              nextIntersectionLl,\r\n              \"North\"\r\n            );\r\n          }\r\n\r\n          let gridIntersectionXy;\r\n          if (gridIntersectionLl) {\r\n            gridIntersectionXy = latLngToCanvasPoint(\r\n              this.map,\r\n              gridIntersectionLl\r\n            );\r\n          } else {\r\n            return;\r\n          }\r\n\r\n          if (northingIndex === 0) {\r\n            ctx.beginPath();\r\n            ctx.moveTo(gridIntersectionXy.x, gridIntersectionXy.y);\r\n          } else {\r\n            if (gridIntersectionLl.lng > GZD_EAST_BOUNDARY) {\r\n              shouldSkip = true;\r\n            }\r\n\r\n            if (gridIntersectionLl.lat > GZD_NORTH_BOUNDARY) {\r\n              let previousIntersectionLl = utm.convertUtmToLatLng(\r\n                eastingElem,\r\n                northArr[northingIndex - 1],\r\n                zoneNumber,\r\n                zoneLetter\r\n              );\r\n\r\n              gridIntersectionLl = connectToGzdBoundary(\r\n                gridIntersectionLl,\r\n                previousIntersectionLl,\r\n                \"South\"\r\n              );\r\n\r\n              gridIntersectionXy = latLngToCanvasPoint(\r\n                this.map,\r\n                gridIntersectionLl\r\n              );\r\n            }\r\n            ctx.lineTo(gridIntersectionXy.x, gridIntersectionXy.y);\r\n          }\r\n        });\r\n\r\n        const IS_HK_LINE = eastingElem % 100000 !== 0;\r\n        this._drawLine(ctx, IS_HK_LINE);\r\n\r\n        let gridLabelLl = utm.convertUtmToLatLng(\r\n          eastingElem,\r\n          northingArray[1],\r\n          zoneNumber,\r\n          zoneLetter\r\n        );\r\n\r\n        if (gridLabelLl.lng > GZD_WEST_BOUNDARY) {\r\n          try {\r\n            let gridLabelXy = latLngToCanvasPoint(this.map, {\r\n              lat: effectiveSouthGzdBoundary,\r\n              lng: gridLabelLl.lng,\r\n            });\r\n\r\n            let label = this._getLabelText(eastingElem);\r\n            drawLabel(ctx, label, this.options.fontColor, this.options.color, {\r\n              x: gridLabelXy.x,\r\n              y: gridLabelXy.y - 15,\r\n            });\r\n          } catch (e) {}\r\n        }\r\n      });\r\n\r\n      // Lines of constant Northings\r\n      northingArray.forEach((northingElem, northingIndex, northArr) => {\r\n        eastingArray.forEach((eastingElem, eastingIndex, eastArr) => {\r\n          let gridIntersectionLl = utm.convertUtmToLatLng(\r\n            eastingElem,\r\n            northingElem,\r\n            zoneNumber,\r\n            zoneLetter\r\n          );\r\n\r\n          let gridIntersectionXy = latLngToCanvasPoint(\r\n            this.map,\r\n            gridIntersectionLl\r\n          );\r\n          if (eastingIndex === 0) {\r\n            ctx.beginPath();\r\n            // If the first point lies to the west of the GZD, truncate it\r\n            if (gridIntersectionLl.lng < GZD_WEST_BOUNDARY) {\r\n              let nextIntersectionLl = utm.convertUtmToLatLng(\r\n                eastArr[eastingIndex + 1],\r\n                northingElem,\r\n                zoneNumber,\r\n                zoneLetter\r\n              );\r\n              try {\r\n                gridIntersectionLl = connectToGzdBoundary(\r\n                  gridIntersectionLl,\r\n                  nextIntersectionLl,\r\n                  \"East\"\r\n                );\r\n                gridIntersectionXy = latLngToCanvasPoint(\r\n                  this.map,\r\n                  gridIntersectionLl\r\n                );\r\n              } catch (e) {\r\n                return;\r\n              }\r\n            }\r\n            ctx.moveTo(gridIntersectionXy.x, gridIntersectionXy.y);\r\n          } else if (eastingIndex === eastArr.length - 1) {\r\n            if (gridIntersectionLl.lng < GZD_EAST_BOUNDARY) {\r\n              let previousIntersectionLl = utm.convertUtmToLatLng(\r\n                eastArr[eastingIndex - 1],\r\n                northingElem,\r\n                zoneNumber,\r\n                zoneLetter\r\n              );\r\n\r\n              let gzdIntersectionLl = connectToGzdBoundary(\r\n                gridIntersectionLl,\r\n                previousIntersectionLl,\r\n                \"East\"\r\n              );\r\n\r\n              gridIntersectionXy = latLngToCanvasPoint(\r\n                this.map,\r\n                gzdIntersectionLl\r\n              );\r\n\r\n              ctx.lineTo(gridIntersectionXy.x, gridIntersectionXy.y);\r\n\r\n              // We need to truncate the line to stop at the GZD boundary\r\n            } else if (gridIntersectionLl.lng > GZD_EAST_BOUNDARY) {\r\n              let previousIntersectionLl = utm.convertUtmToLatLng(\r\n                eastArr[eastingIndex - 1],\r\n                northArr[northingIndex],\r\n                zoneNumber,\r\n                zoneLetter\r\n              );\r\n\r\n              let gzdIntersectionLl = connectToGzdBoundary(\r\n                previousIntersectionLl,\r\n                gridIntersectionLl,\r\n                \"East\"\r\n              );\r\n\r\n              gridIntersectionXy = latLngToCanvasPoint(\r\n                this.map,\r\n                gzdIntersectionLl\r\n              );\r\n\r\n              ctx.lineTo(gridIntersectionXy.x, gridIntersectionXy.y);\r\n            }\r\n          } else {\r\n            ctx.lineTo(gridIntersectionXy.x, gridIntersectionXy.y);\r\n          }\r\n        });\r\n        const IS_HK_LINE = northingElem % 100000 !== 0;\r\n        this._drawLine(ctx, IS_HK_LINE);\r\n\r\n        try {\r\n          let gridLabelLl = utm.convertUtmToLatLng(\r\n            eastingArray[eastingArray.length - 1],\r\n            northingElem,\r\n            zoneNumber,\r\n            zoneLetter\r\n          );\r\n          let gridLabelXy = latLngToCanvasPoint(this.map, {\r\n            lat: gridLabelLl.lat,\r\n            lng: effectiveEastGzdBoundary,\r\n          });\r\n\r\n          let label = this._getLabelText(northingElem);\r\n\r\n          drawLabel(ctx, label, this.options.fontColor, this.options.color, {\r\n            x: gridLabelXy.x - 15,\r\n            y: gridLabelXy.y,\r\n          });\r\n        } catch (e) {\r\n          return;\r\n        }\r\n      });\r\n    });\r\n  }\r\n}\r\n\r\nexport { OneKGraticule };\r\n","import React from \"react\";\nimport { MapContainer, TileLayer } from \"react-leaflet\";\nimport {\n  GzdGraticule,\n  HundredKGraticule,\n  OneKGraticule,\n} from \"react-leaflet-mgrs-graticule\";\nimport \"./App.css\";\n\nfunction App() {\n  return (\n    <MapContainer\n      center={[45.4, -75.7]}\n      zoom={7}\n      minZoom={3}\n      maxZoom={16}\n      maxNativeZoom={15}\n      maxBounds={[\n        [-90, -180],\n        [90, 180],\n      ]}\n    >\n      <TileLayer\n        // url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\n        // attribution='&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\n        // ESRI Clarity Sat\n        // url=\"https://clarity.maptiles.arcgis.com/arcgis/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\"\n        // ESRI Sat\n        url=\"https://services.arcgisonline.com/arcgis/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\"\n        attribution='&copy; <a href=\"https://wiki.openstreetmap.org/wiki/Esri\"></a> contributors'\n      />\n      <OneKGraticule />\n      <HundredKGraticule />\n      <GzdGraticule />\n    </MapContainer>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}