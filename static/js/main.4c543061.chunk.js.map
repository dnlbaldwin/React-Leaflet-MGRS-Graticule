{"version":3,"sources":["../../src/Coordinates.js","../../src/CommonUtils.js","../../src/MgrsGraticule.js","App.js","index.js"],"names":["a","eccSquared","utmToLl","easting","northing","zoneNumber","zoneLetter","UTMEasting","UTMNorthing","UTMZoneNumber","UTMZoneLetter","e1","Math","sqrt","x","y","ZoneNumber","ZoneLetter","undefined","indexOf","LongOrigin","eccPrimeSquared","mu","phi1Rad","sin","N1","toDegrees","T1","tan","C1","cos","R1","pow","D","Lat","Long","lat","lng","_utmToLl","llToUtm","_LLtoUTM","lon","llToMgrs","point","resolution","forward","ll","N","T","C","A","LongOriginRad","k0","LatRad","degToRad","LongRad","floor","round","getLetterDesignator","rad","PI","deg","LetterDesignator","TEN_K_MGRS_REGEX","getLineSlope","pointOne","pointTwo","NaN","getAdjustedLatitude","slope","adjustedLongitude","unadjustedLatLong","isNaN","getAdjustedLongitude","adjustedLatitude","Error","getNextMgrsGzdCharacter","char","result","String","fromCharCode","charCodeAt","connectToGzdBoundary","direction","grid","gzdEastLongitude","getGZD","match","geometry","coordinates","gzdWestLongitude","gzdNorthLatitude","gzdSouthLatitude","drawLabel","ctx","labelText","textColor","backgroundColor","labelPosition","textWidth","measureText","width","textHeight","fontBoundingBoxAscent","labelX","labelY","fillStyle","fillRect","fillText","MGRS_REGEX","MgrsGraticule","props","map","useMap","Graticule","name","checked","this","currLatInterval","currLngInterval","defaultOptions","showGrid","showLabel","color","font","fontColor","dashArray","weight","gridColor","hkColor","hkDashArray","gridFont","gridFontColor","gridDashArray","hundredKMinZoom","tenKMinZoom","oneKMinZoom","options","canvas","document","createElement","classList","add","on","reset","showGraticule","clearRect","replace","getPanes","overlayPane","contains","appendChild","e","getContext","height","mapSize","getSize","mapLeftTop","containerPointToLayerPoint","style","getZoom","mgrsGridInterval","drawGrid","drawGzd","minZoom","lineWidth","strokeStyle","setLineDash","leftTop","containerPointToLatLng","rightBottom","pointPerLat","pointPerLon","parseInt","i","drawLatitudeLine","drawLongitudeLine","tick","lngLeft","lngRight","leftEnd","latLngToContainerPoint","rightEnd","beginPath","moveTo","lineTo","stroke","latTop","latBottom","canvasTop","canvasBottom","TOP_OF_W_SERIES_GZD","TOP_OF_V_SERIES_GZD","BOTTOM_OF_V_SERIES_GZD","RIGHT_TOP_OF_GZD","LEFT_TOP_OF_GZD","LEFT_BOTTOM_OF_GZD","RIGHT_BOTTOM_OF_GZD","TOP_LEFT_OF_32_SERIES_GZD","TOP_LEFT_OF_33X_GZD","BOTTOM_LEFT_OF_33X_GZD","TOP_RIGHT_OF_32W_GZD","TOP_LEFT_OF_34_SERIES_GZD","TOP_LEFT_OF_35X_GZD","BOTTOM_LEFT_OF_35X_GZD","TOP_RIGHT_OF_34W_GZD","TOP_LEFT_OF_35_SERIES_GZD","TOP_LEFT_OF_37X_GZD","BOTTOM_LEFT_OF_37X_GZD","TOP_RIGHT_OF_36W_GZD","drawGzdLabels","longitude","labelLatitude","labelLongitude","gzdLabel","error","labelXy","element","label","toString","notHkLine","visibleGzds","nwBoundMgrs","getBounds","getNorthWest","neBoundMgrs","getNorthEast","seBoundMgrs","getSouthEast","swBoundMgrs","getSouthWest","nwGzd","neGzd","seGzd","swGzd","GZD_REGEX","nwLongitudeBand","nwLatitudeBand","neLongitudeBand","swLatitudeBand","longitudeBands","push","initialLongitudeBand","currentLatitudeBand","len","length","flat","longitudeBand","filter","includes","getAllVisibleGzds","getVizGzds","mapBounds","forEach","gzd","gzdIndex","visibleGridArr","gzdObject","gzdWestBoundary","gzdEastBoundary","gzdNorthBoundary","gzdSouthBoundary","effectiveWestBoundary","getWest","effectiveEastBoundary","getEast","effectiveNorthBoundary","getNorth","effectiveSouthBoundary","getSouth","buffer","swCornerUtm","seCornerUtm","nwCornerUtm","neCornerUtm","startingEasting","getCenter","finalEasting","startingNorthing","finalNorthing","ceil","eastingArray","northingArray","eastingElem","eastingIndex","eastArr","initialPlacementCompleted","northingElem","northingIndex","northArr","gridIntersectionLl","gridIntersectionXy","Number","isFinite","_drawLine","beginPathCalled","console","trace","nextGridIntersectionLl","ea","na","labelLl","adjacentLlNorthing","adjacentLlEasting","currentLl","effectiveBounds","L","latLngBounds","latLng","distanceTo","_getLabelText","mgrsGraticuleName","App","MapContainer","center","zoom","maxZoom","maxNativeZoom","maxBounds","LayersControl","position","BaseLayer","TileLayer","url","attribution","Overlay","LayerGroup","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.4c543061.chunk.js","sourcesContent":["import { forward } from 'mgrs';\r\n\r\n// MGRS-84\r\nconst a = 6378137.0; //ellip.radius;\r\nconst eccSquared = 0.00669438; //ellip.eccsq;\r\n\r\nfunction utmToLl(easting, northing, zoneNumber, zoneLetter) {\r\n  return _utmToLl(easting, northing, zoneNumber, zoneLetter);\r\n}\r\n\r\nfunction llToUtm(lat, lng, resolution = 0) {\r\n  return _LLtoUTM({ lat: lat, lon: lng });\r\n}\r\n\r\n/**\r\n * Wrapper around MGRS forward function\r\n * @param {arr} point [Lng,Lat]\r\n * @param {number} resolution\r\n */\r\nfunction llToMgrs(point, resolution = 1) {\r\n  return forward(point, resolution);\r\n}\r\n\r\nfunction _utmToLl(UTMEasting, UTMNorthing, UTMZoneNumber, UTMZoneLetter) {\r\n  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));\r\n  var x = UTMEasting - 500000.0; //remove 500,000 meter offset for longitude\r\n  var y = UTMNorthing;\r\n  var ZoneNumber = UTMZoneNumber;\r\n  var ZoneLetter = UTMZoneLetter;\r\n  var NorthernHemisphere;\r\n  if (UTMEasting === undefined) {\r\n    return 'Please pass the UTMEasting!';\r\n  }\r\n  if (UTMNorthing === undefined) {\r\n    return 'Please pass the UTMNorthing!';\r\n  }\r\n  if (UTMZoneNumber === undefined) {\r\n    return 'Please pass the UTMZoneNumber!';\r\n  }\r\n  if (UTMZoneLetter === undefined) {\r\n    return 'Please pass the UTMZoneLetter!';\r\n  }\r\n\r\n  if (['N', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'].indexOf(ZoneLetter) !== -1) {\r\n    NorthernHemisphere = 1;\r\n  } else {\r\n    NorthernHemisphere = 0;\r\n    y -= 10000000.0;\r\n  }\r\n\r\n  var LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3;\r\n\r\n  var eccPrimeSquared = eccSquared / (1 - eccSquared);\r\n\r\n  var M = y / 0.9996;\r\n  var mu =\r\n    M /\r\n    (a * (1 - eccSquared / 4 - (3 * eccSquared * eccSquared) / 64 - (5 * eccSquared * eccSquared * eccSquared) / 256));\r\n\r\n  var phi1Rad =\r\n    mu +\r\n    ((3 * e1) / 2 - (27 * e1 * e1 * e1) / 32) * Math.sin(2 * mu) +\r\n    ((21 * e1 * e1) / 16 - (55 * e1 * e1 * e1 * e1) / 32) * Math.sin(4 * mu) +\r\n    ((151 * e1 * e1 * e1) / 96) * Math.sin(6 * mu);\r\n  var phi1 = toDegrees(phi1Rad);\r\n\r\n  var N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));\r\n  var T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);\r\n  var C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);\r\n  var R1 = (a * (1 - eccSquared)) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);\r\n  var D = x / (N1 * 0.9996);\r\n\r\n  var Lat =\r\n    phi1Rad -\r\n    ((N1 * Math.tan(phi1Rad)) / R1) *\r\n      ((D * D) / 2 -\r\n        ((5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D) / 24 +\r\n        ((61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D) / 720);\r\n  Lat = toDegrees(Lat);\r\n\r\n  var Long =\r\n    (D -\r\n      ((1 + 2 * T1 + C1) * D * D * D) / 6 +\r\n      ((5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D) / 120) /\r\n    Math.cos(phi1Rad);\r\n  Long = LongOrigin + toDegrees(Long);\r\n  return { lat: Lat, lng: Long };\r\n}\r\n\r\nfunction _LLtoUTM(ll) {\r\n  var Lat = ll.lat;\r\n  var Long = ll.lon || ll.lng;\r\n\r\n  var k0 = 0.9996;\r\n  var LongOrigin;\r\n  var eccPrimeSquared;\r\n  var N, T, C, A, M;\r\n  var LatRad = degToRad(Lat);\r\n  var LongRad = degToRad(Long);\r\n  var LongOriginRad;\r\n  var ZoneNumber;\r\n  // (int)\r\n  ZoneNumber = Math.floor((Long + 180) / 6) + 1;\r\n\r\n  //Make sure the longitude 180.00 is in Zone 60\r\n  if (Long === 180) {\r\n    ZoneNumber = 60;\r\n  }\r\n\r\n  // Special zone for Norway\r\n  if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {\r\n    ZoneNumber = 32;\r\n  }\r\n\r\n  // Special zones for Svalbard\r\n  if (Lat >= 72.0 && Lat < 84.0) {\r\n    if (Long >= 0.0 && Long < 9.0) {\r\n      ZoneNumber = 31;\r\n    } else if (Long >= 9.0 && Long < 21.0) {\r\n      ZoneNumber = 33;\r\n    } else if (Long >= 21.0 && Long < 33.0) {\r\n      ZoneNumber = 35;\r\n    } else if (Long >= 33.0 && Long < 42.0) {\r\n      ZoneNumber = 37;\r\n    }\r\n  }\r\n\r\n  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin\r\n  // in middle of\r\n  // zone\r\n  LongOriginRad = degToRad(LongOrigin);\r\n\r\n  eccPrimeSquared = eccSquared / (1 - eccSquared);\r\n\r\n  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));\r\n  T = Math.tan(LatRad) * Math.tan(LatRad);\r\n  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);\r\n  A = Math.cos(LatRad) * (LongRad - LongOriginRad);\r\n\r\n  M =\r\n    a *\r\n    ((1 - eccSquared / 4 - (3 * eccSquared * eccSquared) / 64 - (5 * eccSquared * eccSquared * eccSquared) / 256) *\r\n      LatRad -\r\n      ((3 * eccSquared) / 8 + (3 * eccSquared * eccSquared) / 32 + (45 * eccSquared * eccSquared * eccSquared) / 1024) *\r\n        Math.sin(2 * LatRad) +\r\n      ((15 * eccSquared * eccSquared) / 256 + (45 * eccSquared * eccSquared * eccSquared) / 1024) *\r\n        Math.sin(4 * LatRad) -\r\n      ((35 * eccSquared * eccSquared * eccSquared) / 3072) * Math.sin(6 * LatRad));\r\n\r\n  var UTMEasting =\r\n    k0 *\r\n      N *\r\n      (A +\r\n        ((1 - T + C) * A * A * A) / 6.0 +\r\n        ((5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A) / 120.0) +\r\n    500000.0;\r\n\r\n  var UTMNorthing =\r\n    k0 *\r\n    (M +\r\n      N *\r\n        Math.tan(LatRad) *\r\n        ((A * A) / 2 +\r\n          ((5 - T + 9 * C + 4 * C * C) * A * A * A * A) / 24.0 +\r\n          ((61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A) / 720.0));\r\n  if (Lat < 0.0) {\r\n    UTMNorthing += 10000000.0; //10000000 meter offset for\r\n    // southern hemisphere\r\n  }\r\n\r\n  return {\r\n    northing: Math.round(UTMNorthing),\r\n    easting: Math.round(UTMEasting),\r\n    zoneNumber: ZoneNumber,\r\n    zoneLetter: getLetterDesignator(Lat),\r\n  };\r\n}\r\n\r\n/**\r\n * Conversion from radians to degrees.\r\n *\r\n * @private\r\n * @param {number} rad the angle in radians.\r\n * @return {number} the angle in degrees.\r\n */\r\nfunction toDegrees(rad) {\r\n  return (rad / Math.PI) * 180;\r\n}\r\n\r\n/**\r\n * Conversion from degrees to radians.\r\n *\r\n * @private\r\n * @param {number} deg the angle in degrees.\r\n * @return {number} the angle in radians.\r\n */\r\nfunction degToRad(deg) {\r\n  return deg * (Math.PI / 180.0);\r\n}\r\n\r\n/**\r\n * Calculates the MGRS letter designator for the given latitude.\r\n *\r\n * @private\r\n * @param {number} lat The latitude in WGS84 to get the letter designator\r\n *     for.\r\n * @return {char} The letter designator.\r\n */\r\nfunction getLetterDesignator(lat) {\r\n  //This is here as an error flag to show that the Latitude is\r\n  //outside MGRS limits\r\n  var LetterDesignator = 'Z';\r\n\r\n  if (84 >= lat && lat >= 72) {\r\n    LetterDesignator = 'X';\r\n  } else if (72 > lat && lat >= 64) {\r\n    LetterDesignator = 'W';\r\n  } else if (64 > lat && lat >= 56) {\r\n    LetterDesignator = 'V';\r\n  } else if (56 > lat && lat >= 48) {\r\n    LetterDesignator = 'U';\r\n  } else if (48 > lat && lat >= 40) {\r\n    LetterDesignator = 'T';\r\n  } else if (40 > lat && lat >= 32) {\r\n    LetterDesignator = 'S';\r\n  } else if (32 > lat && lat >= 24) {\r\n    LetterDesignator = 'R';\r\n  } else if (24 > lat && lat >= 16) {\r\n    LetterDesignator = 'Q';\r\n  } else if (16 > lat && lat >= 8) {\r\n    LetterDesignator = 'P';\r\n  } else if (8 > lat && lat >= 0) {\r\n    LetterDesignator = 'N';\r\n  } else if (0 > lat && lat >= -8) {\r\n    LetterDesignator = 'M';\r\n  } else if (-8 > lat && lat >= -16) {\r\n    LetterDesignator = 'L';\r\n  } else if (-16 > lat && lat >= -24) {\r\n    LetterDesignator = 'K';\r\n  } else if (-24 > lat && lat >= -32) {\r\n    LetterDesignator = 'J';\r\n  } else if (-32 > lat && lat >= -40) {\r\n    LetterDesignator = 'H';\r\n  } else if (-40 > lat && lat >= -48) {\r\n    LetterDesignator = 'G';\r\n  } else if (-48 > lat && lat >= -56) {\r\n    LetterDesignator = 'F';\r\n  } else if (-56 > lat && lat >= -64) {\r\n    LetterDesignator = 'E';\r\n  } else if (-64 > lat && lat >= -72) {\r\n    LetterDesignator = 'D';\r\n  } else if (-72 > lat && lat >= -80) {\r\n    LetterDesignator = 'C';\r\n  }\r\n  return LetterDesignator;\r\n}\r\n\r\nexport { utmToLl, llToUtm, llToMgrs };\r\n","import { getGZD } from 'gzd-utils';\r\nimport { forward } from 'mgrs';\r\n\r\n// The following indicies are used to indentify coordinates returned from gzd-utils\r\nconst SW_INDEX = 0;\r\nconst NW_INDEX = 1;\r\nconst NE_INDEX = 2;\r\n\r\nconst LONGITUDE_INDEX = 0;\r\nconst LATITUDE_INDEX = 1;\r\n\r\nconst TEN_K_MGRS_REGEX = /([0-9]+[A-Z])([A-Z]{2})([0-9]{2})/;\r\nconst GZD_INDEX = 1;\r\n/**\r\n *\r\n * @param {*} pointOne\r\n * @param {*} pointTwo\r\n */\r\nfunction getLineSlope(pointOne, pointTwo) {\r\n  if (pointOne === pointTwo) {\r\n    return 0;\r\n  } else if (pointOne.lng === pointTwo.lng) {\r\n    return NaN;\r\n  } else {\r\n    return (pointTwo.lat - pointOne.lat) / (pointTwo.lng - pointOne.lng);\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * @param {*} slope\r\n * @param {*} adjustedLongitude\r\n * @param {*} unadjustedLatLong\r\n */\r\nfunction getAdjustedLatitude(slope, adjustedLongitude, unadjustedLatLong) {\r\n  let result;\r\n  if (!isNaN(slope)) {\r\n    result = unadjustedLatLong.lat + slope * (adjustedLongitude - unadjustedLatLong.lng);\r\n  } else {\r\n    result = unadjustedLatLong.lat;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n *\r\n * @param {*} slope\r\n * @param {*} adjustedLongitude\r\n * @param {*} unadjustedLatLong\r\n */\r\nfunction getAdjustedLongitude(slope, adjustedLatitude, unadjustedLatLong) {\r\n  let result;\r\n  if (slope === 0) {\r\n    const e = new Error('getAdjustedLongitude: Zero slope received');\r\n    throw e;\r\n  } else if (!isNaN(slope)) {\r\n    result = (adjustedLatitude - unadjustedLatLong.lat + slope * unadjustedLatLong.lng) / slope;\r\n  } else {\r\n    result = unadjustedLatLong.lng;\r\n  }\r\n\r\n  return result;\r\n}\r\n/**\r\n *\r\n * @param {string} char\r\n */\r\nfunction getNextMgrsGzdCharacter(char) {\r\n  // I and O are not valid characters for MGRS, so get the next\r\n  // character recursively\r\n  const result = String.fromCharCode(char.charCodeAt(0) + 1);\r\n  if (result === 'I' || result === 'O') {\r\n    return getNextMgrsGzdCharacter(result);\r\n  } else {\r\n    return result;\r\n  }\r\n}\r\n\r\n/**\r\n * Given two points and a direction, will return a new point along the\r\n * line generated by pointOne and pointTwo which rests on the GZD boundary\r\n * @param {Dict} pointOne\r\n * @param {Dict} pointTwo\r\n * @param {String} direction\r\n */\r\nfunction connectToGzdBoundary(pointOne, pointTwo, direction) {\r\n  const slope = getLineSlope(pointOne, pointTwo);\r\n  // 10k mgrs resolution grid - e.g. 18TVR90\r\n  const grid = forward([pointOne.lng, pointOne.lat], 1);\r\n  let adjustedLongitude;\r\n  let adjustedLatitude;\r\n\r\n  switch (direction) {\r\n    case 'East':\r\n      const gzdEastLongitude = getGZD(grid.match(TEN_K_MGRS_REGEX)[GZD_INDEX]).geometry.coordinates[0][NE_INDEX][\r\n        LONGITUDE_INDEX\r\n      ];\r\n\r\n      adjustedLatitude = getAdjustedLatitude(slope, gzdEastLongitude, pointTwo);\r\n      adjustedLongitude = gzdEastLongitude;\r\n\r\n      return { lat: adjustedLatitude, lng: adjustedLongitude };\r\n\r\n    case 'West':\r\n      const gzdWestLongitude = getGZD(grid.match(TEN_K_MGRS_REGEX)[GZD_INDEX]).geometry.coordinates[0][NW_INDEX][\r\n        LONGITUDE_INDEX\r\n      ];\r\n\r\n      adjustedLatitude = getAdjustedLatitude(slope, gzdWestLongitude, pointTwo);\r\n\r\n      adjustedLongitude = gzdWestLongitude;\r\n      return { lat: adjustedLatitude, lng: adjustedLongitude };\r\n    case 'North':\r\n      const gzdNorthLatitude = getGZD(grid.match(TEN_K_MGRS_REGEX)[GZD_INDEX]).geometry.coordinates[0][NW_INDEX][\r\n        LATITUDE_INDEX\r\n      ];\r\n\r\n      adjustedLongitude = getAdjustedLongitude(slope, gzdNorthLatitude, pointTwo);\r\n\r\n      // Handle a special case where the west most 100k easting line in the 32V GZD extends\r\n      // west of the boundary\r\n      const WEST_LNG_32V_BOUNDARY = 3;\r\n      if (\r\n        grid.match(TEN_K_MGRS_REGEX)[GZD_INDEX] === '31V' &&\r\n        adjustedLongitude < WEST_LNG_32V_BOUNDARY &&\r\n        pointTwo.lng > WEST_LNG_32V_BOUNDARY\r\n      ) {\r\n        adjustedLatitude = getAdjustedLatitude(slope, WEST_LNG_32V_BOUNDARY, pointTwo);\r\n        adjustedLongitude = WEST_LNG_32V_BOUNDARY;\r\n      } else {\r\n        adjustedLatitude = gzdNorthLatitude;\r\n      }\r\n\r\n      return { lat: adjustedLatitude, lng: adjustedLongitude };\r\n\r\n    case 'South':\r\n      const gzdSouthLatitude = getGZD(grid.match(TEN_K_MGRS_REGEX)[GZD_INDEX]).geometry.coordinates[0][SW_INDEX][\r\n        LATITUDE_INDEX\r\n      ];\r\n\r\n      adjustedLongitude = getAdjustedLongitude(slope, gzdSouthLatitude, pointTwo);\r\n\r\n      adjustedLatitude = gzdSouthLatitude;\r\n      return { lat: adjustedLatitude, lng: adjustedLongitude };\r\n\r\n    default:\r\n      // TODO - lat/lng are undefined if we use this return statement\r\n      return { lat: adjustedLatitude, lng: adjustedLongitude };\r\n  }\r\n}\r\n\r\n// TODO - REFACTOR HACK\r\nfunction getAllVisibleGzds(nwGzd, neGzd, seGzd, swGzd) {\r\n  const GZD_REGEX = /([0-9]+)([A-Z])/;\r\n  const LONGITUDE_BAND_INDEX = 1;\r\n  const LATITUDE_BAND_INDEX = 2;\r\n\r\n  // Short circuit\r\n  if (nwGzd === seGzd) {\r\n    return [nwGzd];\r\n  }\r\n  const nwLongitudeBand = parseInt(nwGzd.match(GZD_REGEX)[LONGITUDE_BAND_INDEX]);\r\n  const nwLatitudeBand = nwGzd.match(GZD_REGEX)[LATITUDE_BAND_INDEX];\r\n\r\n  const neLongitudeBand = parseInt(neGzd.match(GZD_REGEX)[LONGITUDE_BAND_INDEX]);\r\n\r\n  const swLatitudeBand = swGzd.match(GZD_REGEX)[LATITUDE_BAND_INDEX];\r\n\r\n  let result = [];\r\n\r\n  const longitudeBands = []; // container for the formatted GZDs\r\n\r\n  // If the NW GZD is 32V then also include the relevant 31 series GZDs below it\r\n  // This ensures that grids are displayed (since 32V is larger at the expense of 31V)\r\n  if (nwGzd === '32V') {\r\n    longitudeBands.push('31');\r\n  }\r\n\r\n  // We span at least two vertical bands\r\n  if (nwLongitudeBand !== neLongitudeBand) {\r\n    for (let i = nwLongitudeBand; i <= neLongitudeBand; i++) {\r\n      longitudeBands.push(i.toString());\r\n    }\r\n    if (nwLatitudeBand !== swLatitudeBand) {\r\n      const initialLongitudeBand = [...longitudeBands];\r\n\r\n      let currentLatitudeBand = swLatitudeBand;\r\n      while (currentLatitudeBand <= nwLatitudeBand) {\r\n        const len = initialLongitudeBand.length;\r\n\r\n        for (let i = 0; i < len; i++) {\r\n          result.push(initialLongitudeBand[i] + currentLatitudeBand);\r\n        }\r\n\r\n        currentLatitudeBand = getNextMgrsGzdCharacter(currentLatitudeBand);\r\n      }\r\n\r\n      result = result.flat();\r\n    } else {\r\n      // Append the alpha character to the array of GZDs\r\n      const len = longitudeBands.length;\r\n      for (let i = 0; i < len; i++) {\r\n        longitudeBands[i] = longitudeBands[i].toString() + nwLatitudeBand;\r\n      }\r\n      result = longitudeBands;\r\n    }\r\n  } else {\r\n    // We span a single vertical band\r\n    let currentLatitudeBand = swLatitudeBand;\r\n    const longitudeBand = []; // Container for the formatted GZDs\r\n\r\n    while (currentLatitudeBand <= nwLatitudeBand) {\r\n      longitudeBand.push(nwLongitudeBand.toString() + currentLatitudeBand);\r\n\r\n      currentLatitudeBand = getNextMgrsGzdCharacter(currentLatitudeBand);\r\n    }\r\n    result = longitudeBand;\r\n  }\r\n  // Remove non-existant X series GZDs around Svalbard\r\n  result = result.filter(function (a) {\r\n    return a !== '32X' && a !== '34X' && a !== '36X';\r\n  });\r\n\r\n  // Add 32V if 31W is visible\r\n  // This ensures that grids are displayed (since 32V is larger at the expense of 31V)\r\n  if (result.includes('31W') && !result.includes('32V')) {\r\n    result.push('32V');\r\n  }\r\n\r\n  // Handles a special case where 32V can be the NW and NE GZD, but the algorithm\r\n  // doesn't show the 31U GZD\r\n  if (neGzd === '32V' && seGzd === '32U' && !result.includes('31U')) {\r\n    result.push('31U');\r\n  }\r\n\r\n  if (nwGzd === '32V' && neGzd === '32V' && !result.includes('31U')) {\r\n    result.push('31U');\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction drawLabel(ctx, labelText, textColor, backgroundColor, labelPosition) {\r\n  const textWidth = ctx.measureText(labelText).width;\r\n  const textHeight = ctx.measureText(labelText).fontBoundingBoxAscent;\r\n\r\n  // Calculate label xy position\r\n  const labelX = labelPosition.x;\r\n  const labelY = labelPosition.y;\r\n\r\n  ctx.fillStyle = backgroundColor;\r\n  // Magic numbers will centre the rectangle over the text\r\n  ctx.fillRect(labelX - textWidth / 2 - 1, labelY - textHeight + 1, textWidth + 3, textHeight + 2);\r\n  ctx.fillStyle = textColor;\r\n  ctx.fillText(labelText, labelX - textWidth / 2, labelY);\r\n}\r\n\r\nexport {\r\n  connectToGzdBoundary,\r\n  drawLabel,\r\n  getAdjustedLatitude,\r\n  getAdjustedLongitude,\r\n  getAllVisibleGzds,\r\n  getLineSlope,\r\n  getNextMgrsGzdCharacter,\r\n};\r\n","import { utmToLl, llToUtm, llToMgrs } from './Coordinates';\r\nimport { Layer } from 'leaflet';\r\nimport { useMap } from 'react-leaflet';\r\n\r\nimport {\r\n  connectToGzdBoundary,\r\n  drawLabel,\r\n  getAdjustedLatitude,\r\n  getAdjustedLongitude,\r\n  getAllVisibleGzds,\r\n  getLineSlope,\r\n} from './CommonUtils';\r\nimport { getGZD } from 'gzd-utils';\r\n\r\n// The following indicies are used to indentify coordinates returned from gzd-utils\r\nconst SW_INDEX = 0;\r\nconst NW_INDEX = 1;\r\nconst NE_INDEX = 2;\r\n\r\nconst LATITUDE_INDEX = 1;\r\nconst LONGITUDE_INDEX = 0;\r\n\r\nconst MGRS_REGEX = /([0-9]+[A-Z])([A-Z]{2})(\\d+)/;\r\nconst GZD_INDEX = 1;\r\nconst HK_INDEX = 2;\r\nconst GRID_INDEX = 3;\r\n\r\nconst MgrsGraticule = (props) => {\r\n  let map = useMap();\r\n  let g = new Graticule(map, props.name, props.checked);\r\n\r\n  return null;\r\n};\r\n\r\nclass Graticule {\r\n  constructor(map, name, checked) {\r\n    this.currLatInterval = 8;\r\n    this.currLngInterval = 6;\r\n\r\n    this.defaultOptions = {\r\n      showGrid: true,\r\n      showLabel: true,\r\n      color: '#888888',\r\n      font: '14px Courier New',\r\n      fontColor: '#FFF',\r\n      dashArray: [6, 6],\r\n      weight: 1.5,\r\n      gridColor: '#000',\r\n      hkColor: '#990000', //Font background colour and dash colour\r\n      hkDashArray: [4, 4],\r\n      gridFont: '14px Courier New',\r\n      gridFontColor: '#FFF',\r\n      gridDashArray: [],\r\n      hundredKMinZoom: 6,\r\n      tenKMinZoom: 9,\r\n      oneKMinZoom: 12,\r\n    };\r\n\r\n    this.options = this.defaultOptions;\r\n    this.map = map;\r\n    this.canvas = document.createElement('canvas');\r\n    this.canvas.classList.add('leaflet-zoom-animated');\r\n    this.canvas.classList.add(this.name);\r\n\r\n    this.map.on('viewreset', this.reset, this);\r\n    this.map.on('move', this.reset, this);\r\n    this.map.on('overlayadd', this.showGraticule, this);\r\n    this.map.on('overlayremove', this.clearRect, this);\r\n\r\n    // Strip any spaces as they can't be used in class names\r\n    this.name = name.replace(/\\s/g, '');\r\n\r\n    if (checked) {\r\n      this.options.showGrid = true;\r\n      this.reset();\r\n    } else {\r\n      this.options.showGrid = false;\r\n    }\r\n\r\n    // Add the canvas only if it hasn't already been added\r\n    if (!this.map.getPanes().overlayPane.classList.contains(this.name)) {\r\n      this.map.getPanes().overlayPane.appendChild(this.canvas);\r\n    }\r\n  }\r\n\r\n  clearRect(e) {\r\n    if (e.name === this.name) {\r\n      let ctx = this.canvas.getContext('2d');\r\n      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n      this.options.showGrid = false;\r\n    }\r\n  }\r\n\r\n  showGraticule(e) {\r\n    if (e.name === this.name) {\r\n      this.options.showGrid = true;\r\n      this.reset();\r\n    }\r\n  }\r\n\r\n  reset() {\r\n    if (!this.options.showGrid) {\r\n      return;\r\n    }\r\n    const mapSize = this.map.getSize();\r\n    const mapLeftTop = this.map.containerPointToLayerPoint([0, 0]);\r\n\r\n    this.canvas.style['transform'] = `translate3d(${mapLeftTop.x}px,${mapLeftTop.y}px,0)`;\r\n\r\n    this.canvas.width = mapSize.x;\r\n    this.canvas.height = mapSize.y;\r\n\r\n    if (this.map.getZoom() > this.options.oneKMinZoom) {\r\n      this.mgrsGridInterval = 1000; //1k resolution\r\n    } else if (this.map.getZoom() > this.options.tenKMinZoom) {\r\n      this.mgrsGridInterval = 10000; //10k resolution\r\n    } else if (this.map.getZoom() > this.options.hundredKMinZoom) {\r\n      this.mgrsGridInterval = 100000; //100k resolution\r\n    } else {\r\n      this.mgrsGridInterval = null;\r\n    }\r\n\r\n    let ctx = this.canvas.getContext('2d');\r\n    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n    this.drawGrid(ctx);\r\n    this.drawGzd(ctx);\r\n  }\r\n\r\n  drawGzd(ctx) {\r\n    if (!this.canvas || !this.map) {\r\n      return;\r\n    }\r\n\r\n    if (this.map.getZoom() < this.options.minZoom) {\r\n      return;\r\n    }\r\n\r\n    ctx.lineWidth = this.options.weight;\r\n    ctx.strokeStyle = this.options.color;\r\n    ctx.fillStyle = this.options.color;\r\n    ctx.setLineDash(this.options.dashArray);\r\n    if (this.options.font) {\r\n      ctx.font = this.options.font;\r\n    }\r\n\r\n    let leftTop = this.map.containerPointToLatLng({ x: 0, y: 0 });\r\n    let rightBottom = this.map.containerPointToLatLng({\r\n      x: this.canvas.width,\r\n      y: this.canvas.height,\r\n    });\r\n\r\n    let pointPerLat = (leftTop.lat - rightBottom.lat) / (this.canvas.height * 0.2);\r\n    let pointPerLon = (rightBottom.lng - leftTop.lng) / (this.canvas.width * 0.2);\r\n\r\n    if (isNaN(pointPerLat) || isNaN(pointPerLon)) {\r\n      return;\r\n    }\r\n\r\n    if (pointPerLat < 1) {\r\n      pointPerLat = 1;\r\n    }\r\n    if (pointPerLon < 1) {\r\n      pointPerLon = 1;\r\n    }\r\n\r\n    if (rightBottom.lat < -90) {\r\n      rightBottom.lat = -90;\r\n    } else {\r\n      rightBottom.lat = parseInt(rightBottom.lat - pointPerLat, 10);\r\n    }\r\n\r\n    if (leftTop.lat > 90) {\r\n      leftTop.lat = 90;\r\n    } else {\r\n      leftTop.lat = parseInt(leftTop.lat + pointPerLat, 10);\r\n    }\r\n\r\n    if (leftTop.lng > 0 && rightBottom.lng < 0) {\r\n      rightBottom.lng += 360;\r\n    }\r\n    rightBottom.lng = parseInt(rightBottom.lng + pointPerLon, 10);\r\n    leftTop.lng = parseInt(leftTop.lng - pointPerLon, 10);\r\n\r\n    // Northern hemisphere\r\n    for (let i = this.currLatInterval; i <= leftTop.lat; i += this.currLatInterval) {\r\n      if (i >= rightBottom.lat) {\r\n        // Handle 'X' MGRS Zone - Do not need it for the southern equivalent 'C'\r\n        if (i === 80) {\r\n          i = 84;\r\n        }\r\n        this.drawLatitudeLine(ctx, i, leftTop.lng, rightBottom.lng);\r\n      }\r\n    }\r\n\r\n    // Southern hemisphere\r\n    for (let i = 0; i >= rightBottom.lat; i -= this.currLatInterval) {\r\n      if (i <= leftTop.lat) {\r\n        this.drawLatitudeLine(ctx, i, leftTop.lng, rightBottom.lng);\r\n      }\r\n    }\r\n\r\n    // HACK - Add six to the right bottom lng to make sure the East 31V boundary is displayed at all times\r\n    for (let i = -180; i <= rightBottom.lng + 6; i += this.currLngInterval) {\r\n      this.drawLongitudeLine(ctx, i, leftTop.lat, rightBottom.lat);\r\n    }\r\n  }\r\n\r\n  drawLatitudeLine(ctx, tick, lngLeft, lngRight) {\r\n    const leftEnd = this.map.latLngToContainerPoint({\r\n      lat: tick,\r\n      lng: lngLeft,\r\n    });\r\n\r\n    const rightEnd = this.map.latLngToContainerPoint({\r\n      lat: tick,\r\n      lng: lngRight,\r\n    });\r\n\r\n    ctx.beginPath();\r\n    ctx.moveTo(leftEnd.x, leftEnd.y);\r\n    ctx.lineTo(rightEnd.x, rightEnd.y);\r\n    ctx.stroke();\r\n  }\r\n\r\n  drawLongitudeLine(ctx, tick, latTop, latBottom) {\r\n    if (latTop >= 84) {\r\n      latTop = 84; // Ensure GZD vertical lines do not extend into the arctic\r\n    }\r\n\r\n    if (latBottom <= -80) {\r\n      latBottom = -80; // Ensure GZD vertical lines do not extend into the antarctic\r\n    }\r\n\r\n    const canvasTop = this.map.latLngToContainerPoint({\r\n      lat: latTop,\r\n      lng: tick,\r\n    });\r\n\r\n    const canvasBottom = this.map.latLngToContainerPoint({\r\n      lat: latBottom,\r\n      lng: tick,\r\n    });\r\n\r\n    const TOP_OF_W_SERIES_GZD = 72;\r\n\r\n    ctx.beginPath();\r\n    // Handle Norway\r\n    if (tick === 6) {\r\n      const TOP_OF_V_SERIES_GZD = 64;\r\n      const BOTTOM_OF_V_SERIES_GZD = 56;\r\n      const RIGHT_OF_31_SERIES_GZD = 3;\r\n\r\n      const RIGHT_TOP_OF_GZD = this.map.latLngToContainerPoint({\r\n        lat: TOP_OF_V_SERIES_GZD,\r\n        lng: tick,\r\n      });\r\n\r\n      const LEFT_TOP_OF_GZD = this.map.latLngToContainerPoint({\r\n        lat: TOP_OF_V_SERIES_GZD,\r\n        lng: RIGHT_OF_31_SERIES_GZD,\r\n      });\r\n\r\n      const LEFT_BOTTOM_OF_GZD = this.map.latLngToContainerPoint({\r\n        lat: BOTTOM_OF_V_SERIES_GZD,\r\n        lng: RIGHT_OF_31_SERIES_GZD,\r\n      });\r\n\r\n      const RIGHT_BOTTOM_OF_GZD = this.map.latLngToContainerPoint({\r\n        lat: BOTTOM_OF_V_SERIES_GZD,\r\n        lng: tick,\r\n      });\r\n      if (latTop > TOP_OF_V_SERIES_GZD && latBottom > BOTTOM_OF_V_SERIES_GZD) {\r\n        // Top segment only\r\n        // Do not draw through Svalbard\r\n        if (latTop > TOP_OF_W_SERIES_GZD) {\r\n          const TOP_LEFT_OF_32_SERIES_GZD = this.map.latLngToContainerPoint({\r\n            lat: TOP_OF_W_SERIES_GZD,\r\n            lng: tick,\r\n          });\r\n          ctx.moveTo(TOP_LEFT_OF_32_SERIES_GZD.x, TOP_LEFT_OF_32_SERIES_GZD.y);\r\n        } else {\r\n          ctx.moveTo(canvasTop.x, canvasTop.y);\r\n        }\r\n\r\n        ctx.lineTo(RIGHT_TOP_OF_GZD.x, RIGHT_TOP_OF_GZD.y);\r\n\r\n        ctx.moveTo(LEFT_TOP_OF_GZD.x, LEFT_TOP_OF_GZD.y);\r\n\r\n        ctx.lineTo(LEFT_TOP_OF_GZD.x, canvasBottom.y);\r\n      } else if (\r\n        //Bottom segment only\r\n        latTop < TOP_OF_V_SERIES_GZD &&\r\n        latBottom < BOTTOM_OF_V_SERIES_GZD\r\n      ) {\r\n        ctx.moveTo(LEFT_TOP_OF_GZD.x, canvasTop.y);\r\n\r\n        ctx.lineTo(LEFT_BOTTOM_OF_GZD.x, LEFT_BOTTOM_OF_GZD.y);\r\n\r\n        ctx.moveTo(RIGHT_BOTTOM_OF_GZD.x, RIGHT_BOTTOM_OF_GZD.y);\r\n\r\n        ctx.lineTo(RIGHT_BOTTOM_OF_GZD.x, canvasBottom.y);\r\n      } else if (\r\n        // Entire thing\r\n        latTop >= TOP_OF_V_SERIES_GZD &&\r\n        latBottom <= BOTTOM_OF_V_SERIES_GZD\r\n      ) {\r\n        // Do not draw through Svalbard\r\n        if (latTop > TOP_OF_W_SERIES_GZD) {\r\n          const TOP_LEFT_OF_32_SERIES_GZD = this.map.latLngToContainerPoint({\r\n            lat: TOP_OF_W_SERIES_GZD,\r\n            lng: tick,\r\n          });\r\n          ctx.moveTo(TOP_LEFT_OF_32_SERIES_GZD.x, TOP_LEFT_OF_32_SERIES_GZD.y);\r\n        } else {\r\n          ctx.moveTo(canvasTop.x, canvasTop.y);\r\n        }\r\n\r\n        ctx.lineTo(RIGHT_TOP_OF_GZD.x, RIGHT_TOP_OF_GZD.y);\r\n\r\n        ctx.moveTo(LEFT_TOP_OF_GZD.x, LEFT_TOP_OF_GZD.y);\r\n\r\n        ctx.lineTo(LEFT_BOTTOM_OF_GZD.x, LEFT_BOTTOM_OF_GZD.y);\r\n\r\n        ctx.moveTo(RIGHT_TOP_OF_GZD.x, LEFT_BOTTOM_OF_GZD.y);\r\n\r\n        ctx.lineTo(RIGHT_TOP_OF_GZD.x, canvasBottom.y);\r\n      } else if (\r\n        // Modified vertical only\r\n        latTop <= TOP_OF_V_SERIES_GZD &&\r\n        latBottom >= BOTTOM_OF_V_SERIES_GZD\r\n      ) {\r\n        ctx.moveTo(LEFT_TOP_OF_GZD.x, canvasTop.y);\r\n\r\n        ctx.lineTo(LEFT_BOTTOM_OF_GZD.x, canvasBottom.y);\r\n      }\r\n    } else if (tick === 12) {\r\n      if (latTop > TOP_OF_W_SERIES_GZD && latTop <= 84) {\r\n        // Handle Svalbard\r\n        const TOP_LEFT_OF_33X_GZD = this.map.latLngToContainerPoint({\r\n          lat: latTop,\r\n          lng: 9,\r\n        });\r\n        ctx.moveTo(TOP_LEFT_OF_33X_GZD.x, TOP_LEFT_OF_33X_GZD.y);\r\n\r\n        const BOTTOM_LEFT_OF_33X_GZD = this.map.latLngToContainerPoint({\r\n          lat: TOP_OF_W_SERIES_GZD,\r\n          lng: 9,\r\n        });\r\n\r\n        ctx.lineTo(BOTTOM_LEFT_OF_33X_GZD.x, BOTTOM_LEFT_OF_33X_GZD.y);\r\n\r\n        const TOP_RIGHT_OF_32W_GZD = this.map.latLngToContainerPoint({\r\n          lat: TOP_OF_W_SERIES_GZD,\r\n          lng: tick,\r\n        });\r\n\r\n        ctx.moveTo(TOP_RIGHT_OF_32W_GZD.x, TOP_RIGHT_OF_32W_GZD.y);\r\n\r\n        ctx.lineTo(canvasBottom.x, canvasBottom.y);\r\n      } else {\r\n        // Normal use case\r\n        ctx.moveTo(canvasTop.x, canvasTop.y);\r\n        ctx.lineTo(canvasBottom.x, canvasBottom.y);\r\n      }\r\n    } else if (tick === 18) {\r\n      // Do not draw through Svalbard\r\n      if (latTop > TOP_OF_W_SERIES_GZD) {\r\n        const TOP_LEFT_OF_34_SERIES_GZD = this.map.latLngToContainerPoint({\r\n          lat: TOP_OF_W_SERIES_GZD,\r\n          lng: tick,\r\n        });\r\n        ctx.moveTo(TOP_LEFT_OF_34_SERIES_GZD.x, TOP_LEFT_OF_34_SERIES_GZD.y);\r\n      } else {\r\n        ctx.moveTo(canvasTop.x, canvasTop.y);\r\n      }\r\n      ctx.lineTo(canvasBottom.x, canvasBottom.y);\r\n    } else if (tick === 24) {\r\n      if (latTop > TOP_OF_W_SERIES_GZD && latTop <= 84) {\r\n        // Handle Svalbard\r\n        const TOP_LEFT_OF_35X_GZD = this.map.latLngToContainerPoint({\r\n          lat: latTop,\r\n          lng: 21,\r\n        });\r\n        ctx.moveTo(TOP_LEFT_OF_35X_GZD.x, TOP_LEFT_OF_35X_GZD.y);\r\n\r\n        const BOTTOM_LEFT_OF_35X_GZD = this.map.latLngToContainerPoint({\r\n          lat: TOP_OF_W_SERIES_GZD,\r\n          lng: 21,\r\n        });\r\n\r\n        ctx.lineTo(BOTTOM_LEFT_OF_35X_GZD.x, BOTTOM_LEFT_OF_35X_GZD.y);\r\n\r\n        const TOP_RIGHT_OF_34W_GZD = this.map.latLngToContainerPoint({\r\n          lat: TOP_OF_W_SERIES_GZD,\r\n          lng: tick,\r\n        });\r\n\r\n        ctx.moveTo(TOP_RIGHT_OF_34W_GZD.x, TOP_RIGHT_OF_34W_GZD.y);\r\n\r\n        ctx.lineTo(canvasBottom.x, canvasBottom.y);\r\n      } else {\r\n        // Normal use case\r\n        ctx.moveTo(canvasTop.x, canvasTop.y);\r\n        ctx.lineTo(canvasBottom.x, canvasBottom.y);\r\n      }\r\n    } else if (tick === 30) {\r\n      // Do not draw through Svalbard\r\n      if (latTop > TOP_OF_W_SERIES_GZD) {\r\n        const TOP_LEFT_OF_35_SERIES_GZD = this.map.latLngToContainerPoint({\r\n          lat: TOP_OF_W_SERIES_GZD,\r\n          lng: tick,\r\n        });\r\n        ctx.moveTo(TOP_LEFT_OF_35_SERIES_GZD.x, TOP_LEFT_OF_35_SERIES_GZD.y);\r\n      } else {\r\n        ctx.moveTo(canvasTop.x, canvasTop.y);\r\n      }\r\n      ctx.lineTo(canvasBottom.x, canvasBottom.y);\r\n    } else if (tick === 36) {\r\n      if (latTop > TOP_OF_W_SERIES_GZD && latTop <= 84) {\r\n        // Handle Svalbard\r\n        const TOP_LEFT_OF_37X_GZD = this.map.latLngToContainerPoint({\r\n          lat: latTop,\r\n          lng: 33,\r\n        });\r\n        ctx.moveTo(TOP_LEFT_OF_37X_GZD.x, TOP_LEFT_OF_37X_GZD.y);\r\n\r\n        const BOTTOM_LEFT_OF_37X_GZD = this.map.latLngToContainerPoint({\r\n          lat: TOP_OF_W_SERIES_GZD,\r\n          lng: 33,\r\n        });\r\n\r\n        ctx.lineTo(BOTTOM_LEFT_OF_37X_GZD.x, BOTTOM_LEFT_OF_37X_GZD.y);\r\n\r\n        const TOP_RIGHT_OF_36W_GZD = this.map.latLngToContainerPoint({\r\n          lat: TOP_OF_W_SERIES_GZD,\r\n          lng: tick,\r\n        });\r\n\r\n        ctx.moveTo(TOP_RIGHT_OF_36W_GZD.x, TOP_RIGHT_OF_36W_GZD.y);\r\n\r\n        ctx.lineTo(canvasBottom.x, canvasBottom.y);\r\n      } else {\r\n        // Normal use case\r\n        ctx.moveTo(canvasTop.x, canvasTop.y);\r\n        ctx.lineTo(canvasBottom.x, canvasBottom.y);\r\n      }\r\n    }\r\n    // The rest of the world...\r\n    else {\r\n      ctx.moveTo(canvasTop.x, canvasTop.y);\r\n      ctx.lineTo(canvasBottom.x, canvasBottom.y);\r\n    }\r\n    ctx.stroke();\r\n\r\n    this.drawGzdLabels(ctx, tick);\r\n  }\r\n\r\n  /** This function encapsulates drawing labels for GZDs\r\n   *\r\n   * @param {Obj} ctx - The HTML5 canvas' context\r\n   * @param {Int} longitude - The longitude (representing a boundary of a GZD) for which needs labels drawn for\r\n   */\r\n  drawGzdLabels(ctx, longitude) {\r\n    // -76 = middle latitude of the 'C' band - place the label in the middle\r\n    for (let labelLatitude = -76; labelLatitude < 84; labelLatitude += 8) {\r\n      let labelLongitude;\r\n      if (labelLatitude === 60) {\r\n        if (longitude === 0) {\r\n          //31V\r\n          labelLongitude = 1.5;\r\n        } else if (longitude === 6) {\r\n          //32V\r\n          labelLongitude = 7.5;\r\n        } else {\r\n          labelLongitude = longitude + 3;\r\n        }\r\n      } else if (labelLatitude === 76) {\r\n        if (longitude === 0) {\r\n          //31X\r\n          labelLongitude = 4.5;\r\n        } else if (longitude === 12) {\r\n          //33X\r\n          labelLongitude = 15;\r\n        } else if (longitude === 24) {\r\n          //35X\r\n          labelLongitude = 27;\r\n        } else if (longitude === 36) {\r\n          //37X\r\n          labelLongitude = 37.5;\r\n        } else {\r\n          labelLongitude = longitude + 3;\r\n        }\r\n      } else {\r\n        // Rest of the world...\r\n        labelLongitude = longitude + 3;\r\n      }\r\n\r\n      let gzdLabel;\r\n      try {\r\n        gzdLabel = llToMgrs([labelLongitude, labelLatitude], 1).match(MGRS_REGEX)[GZD_INDEX];\r\n      } catch (error) {\r\n        return; //Invalid MGRS value returned, so no need to try to display a label\r\n      }\r\n\r\n      // Don't want to display duplicates of the following zones\r\n      if (\r\n        !(gzdLabel === '33X' && longitude === 6) &&\r\n        !(gzdLabel === '35X' && longitude === 18) &&\r\n        !(gzdLabel === '37X' && longitude === 30)\r\n      ) {\r\n        const labelXy = this.map.latLngToContainerPoint({\r\n          lat: labelLatitude,\r\n          lng: labelLongitude,\r\n        });\r\n\r\n        drawLabel(ctx, gzdLabel, this.options.fontColor, this.options.color, labelXy);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {String} element - A UTM easting or northing element\r\n   */\r\n  _getLabelText(element) {\r\n    // Divide by 1000 so that the labels will always be correct (10k vs 1k resolution)\r\n    let label = ((element % 100000) / 1000).toString();\r\n\r\n    if (this.mgrsGridInterval === 10000 && label === '0') {\r\n      label = '00';\r\n    }\r\n\r\n    return label;\r\n  }\r\n\r\n  _drawLine(ctx, notHkLine) {\r\n    if (notHkLine) {\r\n      ctx.setLineDash(this.options.gridDashArray);\r\n      ctx.lineWidth = this.options.weight + 1;\r\n      ctx.strokeStyle = this.options.gridFontColor;\r\n      ctx.stroke();\r\n      ctx.lineWidth = this.options.weight;\r\n      ctx.strokeStyle = this.options.gridColor;\r\n      ctx.stroke();\r\n    } else {\r\n      ctx.lineWidth = this.options.weight;\r\n      ctx.strokeStyle = this.options.hkColor;\r\n      ctx.setLineDash(this.options.hkDashArray);\r\n      ctx.stroke();\r\n    }\r\n  }\r\n\r\n  getVizGzds() {\r\n    const nwBoundMgrs = llToMgrs(\r\n      [this.map.getBounds().getNorthWest()['lng'], this.map.getBounds().getNorthWest()['lat']],\r\n      1\r\n    );\r\n    const neBoundMgrs = llToMgrs(\r\n      [this.map.getBounds().getNorthEast()['lng'], this.map.getBounds().getNorthEast()['lat']],\r\n      1\r\n    );\r\n    const seBoundMgrs = llToMgrs(\r\n      [this.map.getBounds().getSouthEast()['lng'], this.map.getBounds().getSouthEast()['lat']],\r\n      1\r\n    );\r\n    const swBoundMgrs = llToMgrs(\r\n      [this.map.getBounds().getSouthWest()['lng'], this.map.getBounds().getSouthWest()['lat']],\r\n      1\r\n    );\r\n    let visibleGzds;\r\n    try {\r\n      visibleGzds = getAllVisibleGzds(\r\n        nwBoundMgrs.match(MGRS_REGEX)[GZD_INDEX],\r\n        neBoundMgrs.match(MGRS_REGEX)[GZD_INDEX],\r\n        seBoundMgrs.match(MGRS_REGEX)[GZD_INDEX],\r\n        swBoundMgrs.match(MGRS_REGEX)[GZD_INDEX]\r\n      );\r\n    } catch (e) {\r\n      visibleGzds = null;\r\n    }\r\n    return visibleGzds;\r\n  }\r\n\r\n  drawGrid(ctx) {\r\n    if (!this.canvas || !this.map) {\r\n      return;\r\n    }\r\n\r\n    if (this.map.getZoom() < this.options.hundredKMinZoom) {\r\n      return;\r\n    }\r\n\r\n    ctx.lineWidth = this.options.weight + 0.75;\r\n    ctx.strokeStyle = this.options.gridFontColor;\r\n    ctx.fillStyle = this.options.gridColor;\r\n    ctx.setLineDash(this.options.dashArray);\r\n    ctx.font = this.options.gridFont;\r\n    const visibleGzds = this.getVizGzds();\r\n\r\n    const mapBounds = this.map.getBounds();\r\n\r\n    // Just return if there's no visible grids.  Possible if the getVizGzds\r\n    // has an exception\r\n    if (!visibleGzds) {\r\n      return;\r\n    }\r\n    visibleGzds.forEach((gzd, gzdIndex, visibleGridArr) => {\r\n      let gzdObject;\r\n      try {\r\n        gzdObject = getGZD(gzd);\r\n      } catch (e) {\r\n        return;\r\n      }\r\n\r\n      const gzdWestBoundary = gzdObject['geometry']['coordinates'][0][NW_INDEX][LONGITUDE_INDEX];\r\n      const gzdEastBoundary = gzdObject['geometry']['coordinates'][0][NE_INDEX][LONGITUDE_INDEX];\r\n      const gzdNorthBoundary = gzdObject['geometry']['coordinates'][0][NW_INDEX][LATITUDE_INDEX];\r\n      const gzdSouthBoundary = gzdObject['geometry']['coordinates'][0][SW_INDEX][LATITUDE_INDEX];\r\n\r\n      // If drawing HK grids, just draw the entire GZD regardless\r\n      const effectiveWestBoundary =\r\n        gzdWestBoundary < mapBounds.getWest() && this.mgrsGridInterval !== 100000\r\n          ? mapBounds.getWest()\r\n          : gzdWestBoundary;\r\n      const effectiveEastBoundary =\r\n        gzdEastBoundary > mapBounds.getEast() && this.mgrsGridInterval !== 100000\r\n          ? mapBounds.getEast()\r\n          : gzdEastBoundary;\r\n      const effectiveNorthBoundary = gzdNorthBoundary > mapBounds.getNorth() ? mapBounds.getNorth() : gzdNorthBoundary;\r\n      const effectiveSouthBoundary = gzdSouthBoundary < mapBounds.getSouth() ? mapBounds.getSouth() : gzdSouthBoundary;\r\n\r\n      // Buffer is used to ensure that if we're right on the GZD boundary that we don't get the adjacent GZD\r\n      const buffer = 0.00001;\r\n      const swCornerUtm = llToUtm(effectiveSouthBoundary + buffer, effectiveWestBoundary + buffer);\r\n      const seCornerUtm = llToUtm(effectiveSouthBoundary + buffer, effectiveEastBoundary - buffer);\r\n      const nwCornerUtm = llToUtm(effectiveNorthBoundary - buffer, effectiveWestBoundary + buffer);\r\n      const neCornerUtm = llToUtm(effectiveNorthBoundary - buffer, effectiveEastBoundary - buffer);\r\n\r\n      let startingEasting = this.map.getCenter().lat >= 0 ? swCornerUtm.easting : nwCornerUtm.easting;\r\n      let finalEasting = this.map.getCenter().lat >= 0 ? seCornerUtm.easting : neCornerUtm.easting;\r\n\r\n      // Since northings are not perfectly horizontal, we need to find the 'largest' northing value\r\n      // in order to make sure that the entire screen has a grid over it\r\n      let startingNorthing = swCornerUtm.northing > seCornerUtm.northing ? seCornerUtm.northing : swCornerUtm.northing;\r\n      let finalNorthing = nwCornerUtm.northing > neCornerUtm.northing ? nwCornerUtm.northing : neCornerUtm.northing;\r\n\r\n      startingEasting = Math.floor(startingEasting / this.mgrsGridInterval) * this.mgrsGridInterval;\r\n      finalEasting = Math.ceil(finalEasting / this.mgrsGridInterval) * this.mgrsGridInterval;\r\n      startingNorthing = Math.floor(startingNorthing / this.mgrsGridInterval) * this.mgrsGridInterval;\r\n      finalNorthing = Math.ceil(finalNorthing / this.mgrsGridInterval) * this.mgrsGridInterval;\r\n\r\n      let eastingArray = [];\r\n      for (let i = startingEasting; i <= finalEasting; i += this.mgrsGridInterval) {\r\n        eastingArray.push(i);\r\n      }\r\n\r\n      let northingArray = [];\r\n      for (let i = startingNorthing; i <= finalNorthing; i += this.mgrsGridInterval) {\r\n        northingArray.push(i);\r\n      }\r\n\r\n      let zoneLetter = nwCornerUtm.zoneLetter;\r\n      let zoneNumber = nwCornerUtm.zoneNumber;\r\n\r\n      // Lines of constant Eastings\r\n\r\n      eastingArray.forEach((eastingElem, eastingIndex, eastArr) => {\r\n        let initialPlacementCompleted = false;\r\n        ctx.beginPath();\r\n        // HACK - If you navigate to the A/B or X/Y GZDs gzd-utils will crash.  Catch the exception.\r\n        try {\r\n          northingArray.forEach((northingElem, northingIndex, northArr) => {\r\n            let gridIntersectionLl = utmToLl(eastingElem, northingElem, zoneNumber, zoneLetter);\r\n\r\n            // The grid array is larger than the GZD.  As such the first and last elements of the easting/northing\r\n            // arrays will be outside of the GZD.  These points are required because they are used to derive the\r\n            // point of intersection with the GZD boundary.\r\n            if (gridIntersectionLl.lng > gzdEastBoundary) {\r\n              return;\r\n            } else if (gridIntersectionLl.lng < gzdWestBoundary) {\r\n              return;\r\n            }\r\n            // This block will truncate the line at the southern boundary of the GZD\r\n            if (gridIntersectionLl.lat < gzdSouthBoundary) {\r\n              let nextIntersectionLl = utmToLl(eastingElem, northArr[northingIndex + 1], zoneNumber, zoneLetter);\r\n              gridIntersectionLl = connectToGzdBoundary(gridIntersectionLl, nextIntersectionLl, 'North');\r\n              // This block will truncate the line at the northern boundary of the GZD\r\n            } else if (gridIntersectionLl.lat > gzdNorthBoundary) {\r\n              let previousIntersectionLl = utmToLl(eastingElem, northArr[northingIndex - 1], zoneNumber, zoneLetter);\r\n              gridIntersectionLl = connectToGzdBoundary(gridIntersectionLl, previousIntersectionLl, 'South');\r\n            }\r\n            let gridIntersectionXy;\r\n            if (Number.isFinite(gridIntersectionLl.lat) && Number.isFinite(gridIntersectionLl.lng)) {\r\n              gridIntersectionXy = this.map.latLngToContainerPoint(gridIntersectionLl);\r\n              if (!initialPlacementCompleted) {\r\n                ctx.moveTo(gridIntersectionXy.x, gridIntersectionXy.y);\r\n                initialPlacementCompleted = true;\r\n              } else {\r\n                ctx.lineTo(gridIntersectionXy.x, gridIntersectionXy.y);\r\n              }\r\n            } else {\r\n              return;\r\n            }\r\n          });\r\n          const notHkLine = eastingElem % 100000 !== 0;\r\n          this._drawLine(ctx, notHkLine);\r\n        } catch (e) {}\r\n      });\r\n\r\n      // Lines of constant Northings\r\n      northingArray.forEach((northingElem, northingIndex, northArr) => {\r\n        let beginPathCalled = false;\r\n        eastingArray.forEach((eastingElem, eastingIndex, eastArr) => {\r\n          let gridIntersectionLl = utmToLl(eastingElem, northingElem, zoneNumber, zoneLetter);\r\n\r\n          // The grid array is larger than the GZD.  As such the first and last elements of the easting/northing\r\n          // arrays will be outside of the GZD.  These points are required because they are used to derive the\r\n          // point of intersection with the GZD boundary.\r\n          if (gridIntersectionLl.lat > gzdNorthBoundary || gridIntersectionLl.lat < gzdSouthBoundary) {\r\n            if (!beginPathCalled) {\r\n              ctx.beginPath();\r\n              beginPathCalled = true;\r\n            }\r\n            return;\r\n          }\r\n          // Need to check to see whether the next point will be inside the GZD if the current point isn't.\r\n          // From there we can truncate the first point so it's on the boundary.\r\n          let gridIntersectionXy = this.map.latLngToContainerPoint(gridIntersectionLl);\r\n          if (!beginPathCalled) {\r\n            // Truncate the line to the effective western boundary\r\n            if (gridIntersectionLl.lng < effectiveWestBoundary) {\r\n              const nextGridIntersectionLl = utmToLl(eastArr[eastingIndex + 1], northingElem, zoneNumber, zoneLetter);\r\n              // If the next intersection isn't inside the boundary, return and try again on the\r\n              // next iteration\r\n              if (nextGridIntersectionLl.lng < effectiveWestBoundary) {\r\n                return;\r\n              }\r\n              const slope = getLineSlope(gridIntersectionLl, nextGridIntersectionLl);\r\n\r\n              try {\r\n                gridIntersectionLl.lat = getAdjustedLatitude(slope, effectiveWestBoundary, gridIntersectionLl);\r\n\r\n                gridIntersectionLl.lng = effectiveWestBoundary;\r\n\r\n                gridIntersectionXy = this.map.latLngToContainerPoint(gridIntersectionLl);\r\n              } catch (e) {\r\n                console.error(e);\r\n                console.trace();\r\n              }\r\n            }\r\n            ctx.beginPath();\r\n            beginPathCalled = true;\r\n            ctx.moveTo(gridIntersectionXy.x, gridIntersectionXy.y);\r\n          } else {\r\n            // Truncate the line to the effective eastern boundary\r\n            if (gridIntersectionLl.lng > effectiveEastBoundary) {\r\n              const previousGridIntersectionLl = utmToLl(\r\n                eastArr[eastingIndex - 1],\r\n                northingElem,\r\n                zoneNumber,\r\n                zoneLetter\r\n              );\r\n              const slope = getLineSlope(gridIntersectionLl, previousGridIntersectionLl);\r\n\r\n              try {\r\n                gridIntersectionLl.lat = getAdjustedLatitude(slope, effectiveEastBoundary, gridIntersectionLl);\r\n\r\n                gridIntersectionLl.lng = effectiveEastBoundary;\r\n\r\n                gridIntersectionXy = this.map.latLngToContainerPoint(gridIntersectionLl);\r\n              } catch (e) {\r\n                console.error(e);\r\n                console.trace();\r\n              }\r\n            }\r\n            ctx.lineTo(gridIntersectionXy.x, gridIntersectionXy.y);\r\n          }\r\n        });\r\n\r\n        const notHkLine = northingElem % 100000 !== 0;\r\n        this._drawLine(ctx, notHkLine);\r\n      });\r\n      // Draw the labels\r\n      if (this.mgrsGridInterval === 100000) {\r\n        eastingArray.forEach((eastingElem, eastingIndex, ea) => {\r\n          northingArray.forEach((northingElem, northingIndex, na) => {\r\n            let labelLl;\r\n            let currentLl = utmToLl(eastingElem, northingElem, zoneNumber, zoneLetter);\r\n            let adjacentLlNorthing;\r\n            let adjacentLlEasting;\r\n\r\n            if (ea[eastingIndex + 1]) {\r\n              adjacentLlEasting = utmToLl(ea[eastingIndex + 1], northingElem, zoneNumber, zoneLetter);\r\n\r\n              if (adjacentLlEasting.lng > effectiveEastBoundary) {\r\n                const slope = getLineSlope(currentLl, adjacentLlEasting);\r\n                adjacentLlEasting.lat = getAdjustedLatitude(slope, effectiveEastBoundary, adjacentLlEasting);\r\n                adjacentLlEasting.lng = effectiveEastBoundary;\r\n              }\r\n            } else {\r\n              return; // don't care about the very last index\r\n            }\r\n\r\n            if (na[northingIndex + 1]) {\r\n              // The west-most HK label would be at a lower latitude than the adjacent east-most HK label.\r\n              // This is because the currentLl has been adjusted to be inside the GZD and as such the easting\r\n              // line needs to be adjusted too.  Rather than doing this, use the next northing in the adjacent\r\n              // easting line.\r\n              if (eastingIndex === 0) {\r\n                adjacentLlNorthing = utmToLl(ea[eastingIndex + 1], na[northingIndex + 1], zoneNumber, zoneLetter);\r\n              } else {\r\n                adjacentLlNorthing = utmToLl(eastingElem, na[northingIndex + 1], zoneNumber, zoneLetter);\r\n              }\r\n            } else {\r\n              return; // don't care about the very last index\r\n            }\r\n\r\n            // Boundary check\r\n            if (currentLl.lng < effectiveWestBoundary) {\r\n              const slope = getLineSlope(currentLl, adjacentLlEasting);\r\n              currentLl.lat = getAdjustedLatitude(slope, effectiveWestBoundary, currentLl);\r\n              currentLl.lng = effectiveWestBoundary;\r\n            } else if (currentLl.lng > effectiveEastBoundary) {\r\n              return; // don't care if the cursor is outside the effective bounds\r\n            }\r\n\r\n            labelLl = {\r\n              lat: (currentLl.lat + adjacentLlNorthing.lat) / 2,\r\n              lng: (currentLl.lng + adjacentLlEasting.lng) / 2,\r\n            };\r\n\r\n            try {\r\n              const effectiveBounds = L.latLngBounds(\r\n                L.latLng(effectiveNorthBoundary, effectiveWestBoundary),\r\n                L.latLng(effectiveSouthBoundary, effectiveEastBoundary)\r\n              );\r\n\r\n              if (labelLl && effectiveBounds.contains(labelLl)) {\r\n                let labelText = llToMgrs([labelLl.lng, labelLl.lat]).match(MGRS_REGEX)[HK_INDEX];\r\n                if (\r\n                  this.map\r\n                    .latLngToContainerPoint(L.latLng(currentLl))\r\n                    .distanceTo(this.map.latLngToContainerPoint(L.latLng(adjacentLlEasting))) <\r\n                  ctx.measureText(labelText).width * 2\r\n                ) {\r\n                  return;\r\n                }\r\n\r\n                drawLabel(\r\n                  ctx,\r\n                  labelText,\r\n                  this.options.gridFontColor,\r\n                  this.options.hkColor,\r\n                  this.map.latLngToContainerPoint(labelLl)\r\n                );\r\n              }\r\n            } catch (e) {\r\n              return;\r\n            }\r\n          });\r\n        });\r\n      } else {\r\n        eastingArray.forEach((eastingElem, eastingIndex, ea) => {\r\n          if (!(eastingIndex === 0 || eastingIndex === ea.length - 1)) {\r\n            let labelXy;\r\n            try {\r\n              let labelLl = utmToLl(eastingElem, northingArray[1], zoneNumber, zoneLetter);\r\n\r\n              labelXy = this.map.latLngToContainerPoint({ lat: effectiveSouthBoundary, lng: labelLl.lng });\r\n            } catch (e) {\r\n              return;\r\n            }\r\n\r\n            let labelText = this._getLabelText(eastingElem);\r\n\r\n            drawLabel(ctx, labelText, this.options.gridFontColor, this.options.gridColor, {\r\n              x: labelXy.x,\r\n              y: labelXy.y - 15,\r\n            });\r\n          }\r\n        });\r\n\r\n        northingArray.forEach((northingElem, northingIndex, na) => {\r\n          let labelXy;\r\n          try {\r\n            let labelLl = utmToLl(eastingArray[eastingArray.length - 1], northingElem, zoneNumber, zoneLetter);\r\n\r\n            labelXy = this.map.latLngToContainerPoint({ lat: labelLl.lat, lng: effectiveEastBoundary });\r\n          } catch (e) {\r\n            return;\r\n          }\r\n\r\n          let labelText = this._getLabelText(northingElem);\r\n\r\n          drawLabel(ctx, labelText, this.options.gridFontColor, this.options.gridColor, {\r\n            x: labelXy.x - 15,\r\n            y: labelXy.y,\r\n          });\r\n        });\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexport { MgrsGraticule };\r\n","import React from 'react';\r\nimport { LayerGroup, LayersControl, MapContainer, TileLayer } from 'react-leaflet';\r\nimport { MgrsGraticule } from 'react-leaflet-mgrs-graticule';\r\nimport './App.css';\r\n\r\n// Assigning the same name to the overlay as it's named in the control box\r\n// makes it much easier to toggle it on and off when multiple overlays\r\n// are employed.\r\nconst mgrsGraticuleName = 'MGRS';\r\n// Controls whether the overlay is displayed on map load\r\nconst overlayEnabled = true;\r\nfunction App() {\r\n  return (\r\n    <MapContainer\r\n      center={[45.4, -75.7]}\r\n      zoom={7}\r\n      minZoom={3}\r\n      maxZoom={16}\r\n      maxNativeZoom={15}\r\n      maxBounds={[\r\n        [-90, -180],\r\n        [90, 180],\r\n      ]}\r\n    >\r\n      <LayersControl position=\"topright\">\r\n        <LayersControl.BaseLayer checked name=\"ESRI Satellite\">\r\n          <TileLayer\r\n            url=\"https://services.arcgisonline.com/arcgis/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\"\r\n            attribution='&copy; <a href=\"https://wiki.openstreetmap.org/wiki/Esri\"></a> contributors'\r\n          />\r\n        </LayersControl.BaseLayer>\r\n        <LayersControl.BaseLayer name=\"ESRI Clarity\">\r\n          <TileLayer\r\n            url=\"https://clarity.maptiles.arcgis.com/arcgis/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\"\r\n            attribution='&copy; <a href=\"https://wiki.openstreetmap.org/wiki/Esri\"></a> contributors'\r\n          />\r\n        </LayersControl.BaseLayer>\r\n        <LayersControl.BaseLayer name=\"OSM\">\r\n          <TileLayer\r\n            url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\r\n            attribution='&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\r\n          />\r\n        </LayersControl.BaseLayer>\r\n        <LayersControl.BaseLayer name=\"OSM Topo\">\r\n          <TileLayer url=\"https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png\" attribution=\"OSM\" />\r\n        </LayersControl.BaseLayer>\r\n        <LayersControl.Overlay checked={overlayEnabled} name={mgrsGraticuleName}>\r\n          <LayerGroup>\r\n            <MgrsGraticule name={mgrsGraticuleName} checked={overlayEnabled} />\r\n          </LayerGroup>\r\n        </LayersControl.Overlay>\r\n      </LayersControl>\r\n    </MapContainer>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n"],"sourceRoot":""}